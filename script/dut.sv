



// Generated by IP Generator (Version 2020.1-SP5 build 56918)


    
////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module test_ddr #(
 
   parameter MEM_ROW_ADDR_WIDTH   = 15         ,
    
   parameter MEM_COL_ADDR_WIDTH   = 10         ,
   
   parameter MEM_BADDR_WIDTH      = 3          ,
  
  parameter MEM_DQ_WIDTH         =  32         ,
  
  parameter MEM_DQS_WIDTH        =  32/8       
 
)(
input           ref_clk,
input           rst_board,
output          pll_lock,  
output          ddrphy_cpd_lock,
output          ddr_init_done,

output          mem_rst_n ,
output          mem_ck    ,
output          mem_ck_n  ,
output          mem_cke   ,
output          mem_cs_n  ,
output          mem_ras_n ,
output          mem_cas_n ,
output          mem_we_n  , 
output          mem_odt   ,
output [MEM_ROW_ADDR_WIDTH-1:0] mem_a     ,   
output [MEM_BADDR_WIDTH-1:0]    mem_ba    ,   
inout  [MEM_DQ_WIDTH/8-1:0]     mem_dqs   ,
inout  [MEM_DQ_WIDTH/8-1:0]     mem_dqs_n ,
inout  [MEM_DQ_WIDTH-1:0]       mem_dq    ,
output [MEM_DQ_WIDTH/8-1:0]     mem_dm    , 
output reg      heart_beat_led ,
input           random_data_en,
input           read_double_en,
output          err_flag_led    

);


parameter CTRL_ADDR_WIDTH = MEM_ROW_ADDR_WIDTH + MEM_BADDR_WIDTH + MEM_COL_ADDR_WIDTH;
parameter TH_1S = 27'd33000000;

wire core_clk;
wire [CTRL_ADDR_WIDTH-1:0] axi_awaddr;
wire axi_awuser_ap;
wire [3:0] axi_awuser_id;
wire [3:0] axi_awlen;
wire axi_awready;
wire axi_awvalid;
wire [MEM_DQ_WIDTH*8-1:0] axi_wdata;
wire [MEM_DQ_WIDTH*8/8-1:0] axi_wstrb;
wire axi_wready;
wire [3:0] axi_wusero_id;
wire axi_wusero_last;
wire [CTRL_ADDR_WIDTH-1:0] axi_araddr;
wire axi_aruser_ap;
wire [3:0] axi_aruser_id;
wire [3:0] axi_arlen;
wire axi_arready;
wire axi_arvalid;
wire [MEM_DQ_WIDTH*8-1:0] axi_rdata /* synthesis syn_keep = 1 */;
wire axi_rvalid /* synthesis syn_keep = 1 */;
wire [3:0] axi_rid;
wire axi_rlast;
wire [CTRL_ADDR_WIDTH-1:0] random_rw_addr;
wire [3:0] random_axi_id;
wire [3:0] random_axi_len;
wire random_axi_ap;
wire resetn;
wire init_start  ;
wire init_done   ;
wire write_en    ;
wire write_done_p;
wire read_en     ;
wire read_done_p ;

reg [26:0] cnt;
//wire nt_ref_clk;
//***********************************************************************************

assign resetn = rst_board;

//***********************************************************************************

`ifdef SIMULATION
parameter MEM_SPACE_AW = 13; //to reduce simulation time
`else
parameter MEM_SPACE_AW = CTRL_ADDR_WIDTH;
`endif

//***********************************************************************************
always@(posedge core_clk or negedge resetn)
begin
   if (!resetn)
      cnt <= 27'd0;
   else if ( cnt >= TH_1S )
      cnt <= 27'd0;
   else
      cnt <= cnt + 27'd1;
end

always @(posedge core_clk or negedge resetn)
begin
   if (!resetn)
      heart_beat_led <= 1'd1;
   else if ( cnt >= TH_1S )
      heart_beat_led <= ~heart_beat_led;
end
ddr3 #(
   .MEM_ROW_ADDR_WIDTH (MEM_ROW_ADDR_WIDTH),
   .MEM_COL_ADDR_WIDTH (MEM_COL_ADDR_WIDTH),
   .MEM_BADDR_WIDTH    (MEM_BADDR_WIDTH),
   .MEM_DQ_WIDTH       (MEM_DQ_WIDTH),
   .MEM_DM_WIDTH       (MEM_DQS_WIDTH),
   .MEM_DQS_WIDTH      (MEM_DQS_WIDTH),
   .CTRL_ADDR_WIDTH    (CTRL_ADDR_WIDTH)
  )I_ips_ddr_top(
   .ref_clk           (ref_clk           ),
   .resetn            (resetn            ),
   .ddr_init_done     (ddr_init_done     ),
   .core_clk          (core_clk          ),
   .pll_lock          (pll_lock          ),
   .ddrphy_cpd_lock   (ddrphy_cpd_lock  ),

   .axi_awaddr        (axi_awaddr        ),
   .axi_awuser_ap     (axi_awuser_ap     ),
   .axi_awuser_id     (axi_awuser_id     ),
   .axi_awlen         (axi_awlen         ),
   .axi_awready       (axi_awready       ),
   .axi_awvalid       (axi_awvalid       ),

   .axi_wdata         (axi_wdata         ),
   .axi_wstrb         (axi_wstrb         ),
   .axi_wready        (axi_wready        ),
   .axi_wusero_id     (axi_wusero_id     ),
   .axi_wusero_last   (axi_wusero_last   ),

   .axi_araddr        (axi_araddr        ),
   .axi_aruser_ap     (axi_aruser_ap     ),
   .axi_aruser_id     (axi_aruser_id     ),
   .axi_arlen         (axi_arlen         ),
   .axi_arready       (axi_arready       ),
   .axi_arvalid       (axi_arvalid       ),

   .axi_rdata         (axi_rdata         ),
   .axi_rid           (axi_rid           ),
   .axi_rlast         (axi_rlast         ),
   .axi_rvalid        (axi_rvalid        ),

   .apb_clk           (1'b0),
   .apb_rst_n         (1'b0),
   .apb_sel           (1'b0),
   .apb_enable        (1'b0),
   .apb_addr          (8'd0),
   .apb_write         (1'b0),
   .apb_ready         (),
   .apb_wdata         (16'd0),
   .apb_rdata         (),

   .debug_calib_ctrl  ( ),
   .debug_data        ( ),

   .mem_rst_n         (mem_rst_n    ),
   .mem_ck            (mem_ck       ),
   .mem_ck_n          (mem_ck_n     ),
   .mem_cke           (mem_cke      ),
   .mem_cs_n          (mem_cs_n     ),
   .mem_ras_n         (mem_ras_n    ),
   .mem_cas_n         (mem_cas_n    ),
   .mem_we_n          (mem_we_n     ),
   .mem_odt           (mem_odt      ),
   .mem_a             (mem_a        ),
   .mem_ba            (mem_ba       ),
   .mem_dqs           (mem_dqs      ),
   .mem_dqs_n         (mem_dqs_n    ),
   .mem_dq            (mem_dq       ),
   .mem_dm            (mem_dm       )
  );

//***********************************************************************************
test_main_ctrl #(
 .CTRL_ADDR_WIDTH (CTRL_ADDR_WIDTH),
 .MEM_DQ_WIDTH    (MEM_DQ_WIDTH),
 .MEM_SPACE_AW    (MEM_SPACE_AW)
) u_test_main_ctrl (
 .random_rw_addr        (random_rw_addr   ),
 .random_axi_id         (random_axi_id    ),
 .random_axi_len        (random_axi_len   ),
  .random_axi_ap        (random_axi_ap    ),
 .clk                   (core_clk         ),
 .rst_n                 (resetn           ), 
 .ddrc_init_done        (ddr_init_done    ),
 .init_start            (init_start       ),
 .init_done             (init_done        ),
 .write_en              (write_en         ),
 .write_done_p          (write_done_p     ),
 .read_en               (read_en          ),
 .read_done_p           (read_done_p      )
);

test_wr_ctrl #(
   .CTRL_ADDR_WIDTH     (CTRL_ADDR_WIDTH),
   .MEM_DQ_WIDTH        (MEM_DQ_WIDTH),
   .MEM_COL_ADDR_WIDTH  (MEM_COL_ADDR_WIDTH),
   .MEM_SPACE_AW        (MEM_SPACE_AW)
) u_test_wr_ctrl (
 .clk                 (core_clk        ),
 .rst_n               (resetn          ),    
 .init_start          (init_start      ),
 .write_en            (write_en        ),
 .write_done_p        (write_done_p    ),
 .init_done           (init_done       ),
 .random_rw_addr      (random_rw_addr  ),     
 .random_axi_id       (random_axi_id   ),
 .random_axi_len      (random_axi_len  ),
 .random_axi_ap       (random_axi_ap   ),
 .data_pattern_01     (1'b0 ),
 .random_data_en      (random_data_en  ),
 .axi_awaddr          (axi_awaddr      ),
 .axi_awuser_ap       (axi_awuser_ap   ),
 .axi_awuser_id       (axi_awuser_id   ),
 .axi_awlen           (axi_awlen       ),
 .axi_awready         (axi_awready     ),
 .axi_awvalid         (axi_awvalid     ),       
 .axi_wdata           (axi_wdata       ),
 .axi_wstrb           (axi_wstrb       ),
 .axi_wready          (axi_wready      ),
 .axi_wusero_id       (axi_wusero_id   ),
 .axi_wusero_last     (axi_wusero_last )       
);


test_rd_ctrl #(
 .CTRL_ADDR_WIDTH (CTRL_ADDR_WIDTH),
 .MEM_DQ_WIDTH    (MEM_DQ_WIDTH),
 .MEM_SPACE_AW    (MEM_SPACE_AW)
)u_test_rd_ctrl(
 .random_rw_addr      (random_rw_addr  ),
 .random_axi_id       (random_axi_id   ),
 .random_axi_len      (random_axi_len  ),
 .random_axi_ap       (random_axi_ap   ),
 .clk                 (core_clk        ),
 .rst_n               (resetn          ),   
 .read_en             (read_en         ),
 .data_pattern_01     (1'b0            ),
 .read_double_en      (read_double_en  ),   
 .read_done_p         (read_done_p     ),   
 .axi_araddr          (axi_araddr      ),
 .axi_aruser_ap       (axi_aruser_ap   ),
 .axi_aruser_id       (axi_aruser_id   ),
 .axi_arlen           (axi_arlen       ),
 .axi_arready         (axi_arready     ),
 .axi_arvalid         (axi_arvalid     ), 
 
 .axi_rdata           (axi_rdata       ),
 .axi_rid             (axi_rid         ),
 .axi_rlast           (axi_rlast       ),
 .axi_rvalid          (axi_rvalid      ),
 .err_cnt             (                ),   
 .err_flag_led        (err_flag_led    )
);

endmodule






//////////////////////////////////////////////////////////////////////////////
//
// Copyright [c] 2016 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//
// THE SOURCE CODE CONTAINED HEREIN IS PROPRIETARY TO PANGO MICROSYSTEMS, INC.
// IT SHALL NOT BE REPRODUCED OR DISCLOSED IN WHOLE OR IN PART OR USED BY
// PARTIES WITHOUT WRITTEN AUTHORIZATION FROM THE OWNER.
//
//////////////////////////////////////////////////////////////////////////////
module prbs31_128bit #(
    parameter PRBS_INIT = 128'b0,
    parameter PRBS_GEN_EN = 1'b0
)(
input clk,
input rstn,
input clk_en,

input cnt_mode,
input [127:0] din,
output [127:0] dout,
input insert_er,
output reg error
);

wire [128:1] Y;
wire [128:1] X;
wire [128:1] y_comb;
reg  [128:1] latch_y_all;
reg  [128:1] latch_y;
reg  [2:0] insert_er_d;

assign  Y[128] = X[31] ^ X[28] ^ 1 ;
assign  Y[127] = X[30] ^ X[27] ^ 1 ;
assign  Y[126] = X[29] ^ X[26] ^ 1 ;
assign  Y[125] = X[28] ^ X[25] ^ 1 ;
assign  Y[124] = X[27] ^ X[24] ^ 1 ;
assign  Y[123] = X[26] ^ X[23] ^ 1 ;
assign  Y[122] = X[25] ^ X[22] ^ 1 ;
assign  Y[121] = X[24] ^ X[21] ^ 1 ;
assign  Y[120] = X[23] ^ X[20] ^ 1 ;
assign  Y[119] = X[22] ^ X[19] ^ 1 ;
assign  Y[118] = X[21] ^ X[18] ^ 1 ;
assign  Y[117] = X[20] ^ X[17] ^ 1 ;
assign  Y[116] = X[19] ^ X[16] ^ 1 ;
assign  Y[115] = X[18] ^ X[15] ^ 1 ;
assign  Y[114] = X[17] ^ X[14] ^ 1 ;
assign  Y[113] = X[16] ^ X[13] ^ 1 ;
assign  Y[112] = X[15] ^ X[12] ^ 1 ;
assign  Y[111] = X[14] ^ X[11] ^ 1 ;
assign  Y[110] = X[13] ^ X[10] ^ 1 ;
assign  Y[109] = X[12] ^ X[9] ^ 1 ;
assign  Y[108] = X[11] ^ X[8] ^ 1 ;
assign  Y[107] = X[10] ^ X[7] ^ 1 ;
assign  Y[106] = X[9] ^ X[6] ^ 1 ;
assign  Y[105] = X[8] ^ X[5] ^ 1 ;
assign  Y[104] = X[7] ^ X[4] ^ 1 ;
assign  Y[103] = X[6] ^ X[3] ^ 1 ;
assign  Y[102] = X[5] ^ X[2] ^ 1 ;
assign  Y[101] = X[4] ^ X[1] ^ 1 ;
assign  Y[100] = X[31] ^ X[28] ^ X[3] ^ 0 ;
assign  Y[99] = X[30] ^ X[27] ^ X[2] ^ 0 ;
assign  Y[98] = X[29] ^ X[26] ^ X[1] ^ 0 ;
assign  Y[97] = X[31] ^ X[25] ^ 1 ;
assign  Y[96] = X[30] ^ X[24] ^ 1 ;
assign  Y[95] = X[29] ^ X[23] ^ 1 ;
assign  Y[94] = X[28] ^ X[22] ^ 1 ;
assign  Y[93] = X[27] ^ X[21] ^ 1 ;
assign  Y[92] = X[26] ^ X[20] ^ 1 ;
assign  Y[91] = X[25] ^ X[19] ^ 1 ;
assign  Y[90] = X[24] ^ X[18] ^ 1 ;
assign  Y[89] = X[23] ^ X[17] ^ 1 ;
assign  Y[88] = X[22] ^ X[16] ^ 1 ;
assign  Y[87] = X[21] ^ X[15] ^ 1 ;
assign  Y[86] = X[20] ^ X[14] ^ 1 ;
assign  Y[85] = X[19] ^ X[13] ^ 1 ;
assign  Y[84] = X[18] ^ X[12] ^ 1 ;
assign  Y[83] = X[17] ^ X[11] ^ 1 ;
assign  Y[82] = X[16] ^ X[10] ^ 1 ;
assign  Y[81] = X[15] ^ X[9] ^ 1 ;
assign  Y[80] = X[14] ^ X[8] ^ 1 ;
assign  Y[79] = X[13] ^ X[7] ^ 1 ;
assign  Y[78] = X[12] ^ X[6] ^ 1 ;
assign  Y[77] = X[11] ^ X[5] ^ 1 ;
assign  Y[76] = X[10] ^ X[4] ^ 1 ;
assign  Y[75] = X[9] ^ X[3] ^ 1 ;
assign  Y[74] = X[8] ^ X[2] ^ 1 ;
assign  Y[73] = X[7] ^ X[1] ^ 1 ;
assign  Y[72] = X[31] ^ X[28] ^ X[6] ^ 0 ;
assign  Y[71] = X[30] ^ X[27] ^ X[5] ^ 0 ;
assign  Y[70] = X[29] ^ X[26] ^ X[4] ^ 0 ;
assign  Y[69] = X[28] ^ X[25] ^ X[3] ^ 0 ;
assign  Y[68] = X[27] ^ X[24] ^ X[2] ^ 0 ;
assign  Y[67] = X[26] ^ X[23] ^ X[1] ^ 0 ;
assign  Y[66] = X[31] ^ X[28] ^ X[25] ^ X[22] ^ 1 ;
assign  Y[65] = X[30] ^ X[27] ^ X[24] ^ X[21] ^ 1 ;
assign  Y[64] = X[29] ^ X[26] ^ X[23] ^ X[20] ^ 1 ;
assign  Y[63] = X[28] ^ X[25] ^ X[22] ^ X[19] ^ 1 ;
assign  Y[62] = X[27] ^ X[24] ^ X[21] ^ X[18] ^ 1 ;
assign  Y[61] = X[26] ^ X[23] ^ X[20] ^ X[17] ^ 1 ;
assign  Y[60] = X[25] ^ X[22] ^ X[19] ^ X[16] ^ 1 ;
assign  Y[59] = X[24] ^ X[21] ^ X[18] ^ X[15] ^ 1 ;
assign  Y[58] = X[23] ^ X[20] ^ X[17] ^ X[14] ^ 1 ;
assign  Y[57] = X[22] ^ X[19] ^ X[16] ^ X[13] ^ 1 ;
assign  Y[56] = X[21] ^ X[18] ^ X[15] ^ X[12] ^ 1 ;
assign  Y[55] = X[20] ^ X[17] ^ X[14] ^ X[11] ^ 1 ;
assign  Y[54] = X[19] ^ X[16] ^ X[13] ^ X[10] ^ 1 ;
assign  Y[53] = X[18] ^ X[15] ^ X[12] ^ X[9] ^ 1 ;
assign  Y[52] = X[17] ^ X[14] ^ X[11] ^ X[8] ^ 1 ;
assign  Y[51] = X[16] ^ X[13] ^ X[10] ^ X[7] ^ 1 ;
assign  Y[50] = X[15] ^ X[12] ^ X[9] ^ X[6] ^ 1 ;
assign  Y[49] = X[14] ^ X[11] ^ X[8] ^ X[5] ^ 1 ;
assign  Y[48] = X[13] ^ X[10] ^ X[7] ^ X[4] ^ 1 ;
assign  Y[47] = X[12] ^ X[9] ^ X[6] ^ X[3] ^ 1 ;
assign  Y[46] = X[11] ^ X[8] ^ X[5] ^ X[2] ^ 1 ;
assign  Y[45] = X[10] ^ X[7] ^ X[4] ^ X[1] ^ 1 ;
assign  Y[44] = X[31] ^ X[28] ^ X[9] ^ X[6] ^ X[3] ^ 0 ;
assign  Y[43] = X[30] ^ X[27] ^ X[8] ^ X[5] ^ X[2] ^ 0 ;
assign  Y[42] = X[29] ^ X[26] ^ X[7] ^ X[4] ^ X[1] ^ 0 ;
assign  Y[41] = X[31] ^ X[25] ^ X[6] ^ X[3] ^ 1 ;
assign  Y[40] = X[30] ^ X[24] ^ X[5] ^ X[2] ^ 1 ;
assign  Y[39] = X[29] ^ X[23] ^ X[4] ^ X[1] ^ 1 ;
assign  Y[38] = X[31] ^ X[22] ^ X[3] ^ 0 ;
assign  Y[37] = X[30] ^ X[21] ^ X[2] ^ 0 ;
assign  Y[36] = X[29] ^ X[20] ^ X[1] ^ 0 ;
assign  Y[35] = X[31] ^ X[19] ^ 1 ;
assign  Y[34] = X[30] ^ X[18] ^ 1 ;
assign  Y[33] = X[29] ^ X[17] ^ 1 ;
assign  Y[32] = X[28] ^ X[16] ^ 1 ;
assign  Y[31] = X[27] ^ X[15] ^ 1 ;
assign  Y[30] = X[26] ^ X[14] ^ 1 ;
assign  Y[29] = X[25] ^ X[13] ^ 1 ;
assign  Y[28] = X[24] ^ X[12] ^ 1 ;
assign  Y[27] = X[23] ^ X[11] ^ 1 ;
assign  Y[26] = X[22] ^ X[10] ^ 1 ;
assign  Y[25] = X[21] ^ X[9] ^ 1 ;
assign  Y[24] = X[20] ^ X[8] ^ 1 ;
assign  Y[23] = X[19] ^ X[7] ^ 1 ;
assign  Y[22] = X[18] ^ X[6] ^ 1 ;
assign  Y[21] = X[17] ^ X[5] ^ 1 ;
assign  Y[20] = X[16] ^ X[4] ^ 1 ;
assign  Y[19] = X[15] ^ X[3] ^ 1 ;
assign  Y[18] = X[14] ^ X[2] ^ 1 ;
assign  Y[17] = X[13] ^ X[1] ^ 1 ;
assign  Y[16] = X[31] ^ X[28] ^ X[12] ^ 0 ;
assign  Y[15] = X[30] ^ X[27] ^ X[11] ^ 0 ;
assign  Y[14] = X[29] ^ X[26] ^ X[10] ^ 0 ;
assign  Y[13] = X[28] ^ X[25] ^ X[9] ^ 0 ;
assign  Y[12] = X[27] ^ X[24] ^ X[8] ^ 0 ;
assign  Y[11] = X[26] ^ X[23] ^ X[7] ^ 0 ;
assign  Y[10] = X[25] ^ X[22] ^ X[6] ^ 0 ;
assign  Y[9] = X[24] ^ X[21] ^ X[5] ^ 0 ;
assign  Y[8] = X[23] ^ X[20] ^ X[4] ^ 0 ;
assign  Y[7] = X[22] ^ X[19] ^ X[3] ^ 0 ;
assign  Y[6] = X[21] ^ X[18] ^ X[2] ^ 0 ;
assign  Y[5] = X[20] ^ X[17] ^ X[1] ^ 0 ;
assign  Y[4] = X[31] ^ X[28] ^ X[19] ^ X[16] ^ 1 ;
assign  Y[3] = X[30] ^ X[27] ^ X[18] ^ X[15] ^ 1 ;
assign  Y[2] = X[29] ^ X[26] ^ X[17] ^ X[14] ^ 1 ;
assign  Y[1] = X[28] ^ X[25] ^ X[16] ^ X[13] ^ 1 ;

assign y_comb[128:1] = cnt_mode ? (latch_y + 128'b1) : (PRBS_GEN_EN ? Y[128:1] : din[127:0]);

always @(posedge clk or negedge rstn)
   if (!rstn) begin
      latch_y         <= PRBS_INIT;
      latch_y_all     <= PRBS_INIT;
   end
   else if (clk_en) begin
      latch_y         <= y_comb; 
      latch_y_all     <= Y;
   end
   
always @(posedge clk or negedge rstn)
   if (!rstn) begin
      insert_er_d       <= 3'b0;
      error            <= 1'b0;
   end
   else if (clk_en) begin
      insert_er_d       <= {insert_er_d[1:0], insert_er};
      error            <= latch_y_all != latch_y; //for cfg_prbs_mode 1~6
   end

assign X = latch_y;

assign dout[127:1]  = X[128:2];

assign dout[0] = (insert_er_d[2] ^ insert_er_d[1]) ? (~X[1]) : X[1];

endmodule




////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2015 Shenzhen Pango Microsystems CO.,LTD                       
// All Rights Reserved.                                                         
////////////////////////////////////////////////////////////////////////////////
`timescale 1ns/1ps

module test_main_ctrl #(
parameter CTRL_ADDR_WIDTH = 28,
parameter MEM_DQ_WIDTH = 16,
parameter MEM_SPACE_AW = 18
)(
   output [CTRL_ADDR_WIDTH-1:0] random_rw_addr,
   output [3:0] random_axi_id,
   output [3:0] random_axi_len,
   output random_axi_ap,
      
   input clk,
   input rst_n,
   
   input ddrc_init_done,
   output reg init_start,
   input init_done,
   output reg write_en,
   input  write_done_p,
   output reg read_en,
   input  read_done_p      
);

wire [127:0] prbs_dout;
wire random_write_en;

localparam E_IDLE      = 0;
localparam E_INIT      = 1;
localparam E_WR        = 2;
localparam E_RD        = 3;
localparam E_END       = 4;

reg [3:0] state;
always @(posedge clk or negedge rst_n)
   if (!rst_n) begin
      state    <= E_IDLE;
      write_en <= 1'b0;
      read_en  <= 1'b0;
      init_start <= 1'b0;
   end
   else begin
            case (state)
               E_IDLE: begin
                  if (ddrc_init_done)
                     state <= E_INIT;
                     else
                     state <= E_IDLE;
               end
               E_INIT : begin
                init_start <= 1'b1;
                if(init_done) begin
                state <= E_WR;
                init_start <= 1'b0;
            end
            end
               E_WR: begin
                  if (write_done_p) begin
                     write_en <= 1'b0;
                     state <= E_END;
                  end
                  else
                     write_en <= 1'b1;
               end
               E_RD: begin
                  if (read_done_p) begin
                     read_en <= 1'b0;
                     state <= E_END;
                  end
                  else
                     read_en <= 1'b1;                  
               end               
               E_END: begin
               	  if (random_write_en)
               	     state <= E_WR;
               	  else
               	     state <= E_RD;
               end
               default: begin
                  state <= E_IDLE;
               end                                               
      endcase
   end
   
assign prbs_clk_en = write_done_p | read_done_p;

prbs31_128bit  #(
.PRBS_INIT  (128'h1234_5678_9abc_def0_8686_2016_0707_336a),
.PRBS_GEN_EN (1'b1)
)
I_prbs31_128bit(
.clk       (clk),
.rstn      (rst_n),
.clk_en    (prbs_clk_en),

.cnt_mode  (1'b0   ),
.din       (128'd0),
.dout      (prbs_dout),
.insert_er (1'b0),
.error     ()
);

wire [CTRL_ADDR_WIDTH-1:0] random_rw_addr_mask = {CTRL_ADDR_WIDTH{1'b0}} + {MEM_SPACE_AW{1'b1}};

assign random_rw_addr  =  {prbs_dout[96+CTRL_ADDR_WIDTH-8:96], 7'd0} & random_rw_addr_mask;
assign random_axi_id   =  prbs_dout[39:36];
assign random_axi_len  =  prbs_dout[35:32];
assign random_write_en =  prbs_dout[0];
assign random_axi_ap   =  1'b0;//prbs_dout[1];

endmodule




`timescale 1ns/1ps


module test_rd_ctrl #(
   parameter CTRL_ADDR_WIDTH = 28,
   parameter MEM_DQ_WIDTH = 16,
   parameter MEM_COL_ADDR_WIDTH = 10,
   parameter MEM_SPACE_AW = 18
   
)(
   input [CTRL_ADDR_WIDTH-1:0] random_rw_addr,
   input [3:0] random_axi_id,
   input [3:0] random_axi_len,
   input random_axi_ap,

   input clk,
   input rst_n,   
   input read_en,
   input data_pattern_01,
   input read_double_en,

   output reg read_done_p,
   
    output reg [CTRL_ADDR_WIDTH-1:0]    axi_araddr          ,
    output reg                          axi_aruser_ap  ,    
    output reg [3:0]       axi_aruser_id       ,
    output reg [3:0]       axi_arlen           ,
    input               axi_arready         ,
    output reg             axi_arvalid         ,

    input   [MEM_DQ_WIDTH*8-1:0]   axi_rdata,
    input   [3:0]       axi_rid             ,
    input               axi_rlast           ,
    input               axi_rvalid          ,
    output reg [7:0] err_cnt,
    output reg err_flag_led
   
);

localparam E_IDLE = 0;
localparam E_RD   = 1;
localparam E_END  = 2;
localparam DQ_NUM = MEM_DQ_WIDTH/8; 


reg [15:0] req_rd_cnt;
reg [15:0] execute_rd_cnt;
wire  read_finished;

wire [MEM_DQ_WIDTH-1:0] rd_data0;
wire [MEM_DQ_WIDTH-1:0] rd_data1;
wire [MEM_DQ_WIDTH-1:0] rd_data2;
wire [MEM_DQ_WIDTH-1:0] rd_data3;
wire [MEM_DQ_WIDTH-1:0] rd_data4;
wire [MEM_DQ_WIDTH-1:0] rd_data5;
wire [MEM_DQ_WIDTH-1:0] rd_data6;
wire [MEM_DQ_WIDTH-1:0] rd_data7;

wire [3:0]   addr_0_mux;
wire [3:0]   addr_1_mux;
wire [3:0]   addr_2_mux;
wire [3:0]   addr_3_mux;
wire [3:0]   addr_4_mux;
wire [3:0]   addr_5_mux;
wire [3:0]   addr_6_mux;
wire [3:0]   addr_7_mux;

wire [3:0] rd_data_addr;
reg [7:0]   data_err;

reg         axi_rvalid_d1;
//reg         axi_rvalid_d2;
reg [31:0] normal_rd_addr;
reg [2:0] state;
//reg [7:0] cnt_len;
reg rd_cnt;
//reg [7:0] err_cnt;

always @(posedge clk or negedge rst_n)
begin
   if (!rst_n) begin
      axi_araddr     <= 'b0; 
      axi_aruser_id  <= 'b0; 
      axi_arlen      <= 4'b0; 
      axi_arvalid    <= 1'b0; 
      axi_aruser_ap  <= 'b0;
      state          <= E_IDLE;
      read_done_p    <= 1'b0;
      rd_cnt <= 0;
   end
   else begin          
             if ((state == E_IDLE) & read_en & read_finished) begin
             axi_aruser_id <= random_axi_id;
   	         axi_araddr <= random_rw_addr;
   	  	     axi_arlen <= random_axi_len; 
   	  	     axi_aruser_ap <= random_axi_ap;  	         
   	      end         
          
          case (state)
              E_IDLE: begin
                   if (read_en & read_finished)
                      state <= E_RD;
//                      rd_cnt <= 0;
              end
              E_RD: begin
                   axi_arvalid <= 1'b1;                  
                   if (axi_arvalid&axi_arready) begin
                      axi_arvalid <= 1'b0; 
                      state <= E_END;
                      rd_cnt <= ~rd_cnt;
                      if(read_double_en) begin
                      if(rd_cnt==1)
                      read_done_p <= 1'b1;
                      else 
                      read_done_p <= 1'b0;
                      end
                     else
                      read_done_p <= 1'b1;
                   end
              end
              E_END: begin
                   axi_arvalid <= 1'b0;
                   read_done_p <= 1'b0;
                   if (read_finished)
                      state <= E_IDLE;
              end
              default: begin
              	  state <= E_IDLE;
              end
          endcase     
        end
end        

always @(posedge clk or negedge rst_n)
begin
   if (!rst_n) begin
     normal_rd_addr <= 32'd0;
//     cnt_len <= 8'd0; 
   end
   else begin 
    if(state == E_RD) begin 
      normal_rd_addr <= axi_araddr;
//      cnt_len <= 8'd0;  
    end
    else if(state == E_END) begin
//      if(cnt_len <= axi_arlen) begin
        if(axi_rvalid) begin
          normal_rd_addr <= normal_rd_addr + 32'd8;
//          cnt_len <= cnt_len + 1;
        end
//    end
    end
end
end

always @(posedge clk or negedge rst_n)
   if (!rst_n) begin
   	  req_rd_cnt     <= 16'd0;
   	  execute_rd_cnt <= 16'd0;
   end
   else begin
   	  if (axi_arvalid & axi_arready) begin
//   	        if(axi_arlen == 4'd0)
//   	        req_rd_cnt <= req_rd_cnt + 16;
//   	        else
   	  	    req_rd_cnt <= req_rd_cnt + axi_arlen + 1;
   	  end   	  
   	  if (axi_rvalid) begin
   	     execute_rd_cnt <= execute_rd_cnt + 1;
   	  end      
   end

assign  read_finished = (req_rd_cnt == execute_rd_cnt);

assign rd_data0 = axi_rdata[MEM_DQ_WIDTH-1:0];
assign rd_data1 = axi_rdata[MEM_DQ_WIDTH*2-1:MEM_DQ_WIDTH];
assign rd_data2 = axi_rdata[MEM_DQ_WIDTH*3-1:MEM_DQ_WIDTH*2];
assign rd_data3 = axi_rdata[MEM_DQ_WIDTH*4-1:MEM_DQ_WIDTH*3];
assign rd_data4 = axi_rdata[MEM_DQ_WIDTH*5-1:MEM_DQ_WIDTH*4];
assign rd_data5 = axi_rdata[MEM_DQ_WIDTH*6-1:MEM_DQ_WIDTH*5];
assign rd_data6 = axi_rdata[MEM_DQ_WIDTH*7-1:MEM_DQ_WIDTH*6];
assign rd_data7 = axi_rdata[MEM_DQ_WIDTH*8-1:MEM_DQ_WIDTH*7];

always @(posedge clk or negedge rst_n)
begin
    if(~rst_n)
    begin
        axi_rvalid_d1 <= 1'b0;
//        axi_rvalid_d2 <= 1'b0;
    end
    else
    begin
        axi_rvalid_d1 <= axi_rvalid;
//        axi_rvalid_d2 <= axi_rvalid_d1;
    end
end

assign rd_data_addr = normal_rd_addr[3:0];

assign addr_0_mux = rd_data_addr + 4'd0;
assign addr_1_mux = rd_data_addr + 4'd1;
assign addr_2_mux = rd_data_addr + 4'd2;
assign addr_3_mux = rd_data_addr + 4'd3;
assign addr_4_mux = rd_data_addr + 4'd4;
assign addr_5_mux = rd_data_addr + 4'd5;
assign addr_6_mux = rd_data_addr + 4'd6;
assign addr_7_mux = rd_data_addr + 4'd7;

always @(posedge clk or negedge rst_n)
begin
    if(~rst_n)
    begin
        data_err[0] <= 1'b0;
        data_err[1] <= 1'b0;
        data_err[2] <= 1'b0;
        data_err[3] <= 1'b0;
        data_err[4] <= 1'b0;
        data_err[5] <= 1'b0;
        data_err[6] <= 1'b0;
        data_err[7] <= 1'b0;
    end
    else
    begin
        if(data_pattern_01) begin
        data_err[0] <= rd_data0 == {DQ_NUM{8'hff}};
        data_err[1] <= rd_data1 == {DQ_NUM{8'h00}};
        data_err[2] <= rd_data2 == {DQ_NUM{8'hff}};
        data_err[3] <= rd_data3 == {DQ_NUM{8'h00}};
        data_err[4] <= rd_data4 == {DQ_NUM{8'hff}};
        data_err[5] <= rd_data5 == {DQ_NUM{8'h00}};
        data_err[6] <= rd_data6 == {DQ_NUM{8'hff}};
        data_err[7] <= rd_data7 == {DQ_NUM{8'h00}};
    end
    else begin
        data_err[0] <= DATA_CHK(rd_data0,addr_0_mux);
        data_err[1] <= DATA_CHK(rd_data1,addr_1_mux);
        data_err[2] <= DATA_CHK(rd_data2,addr_2_mux);
        data_err[3] <= DATA_CHK(rd_data3,addr_3_mux);
        data_err[4] <= DATA_CHK(rd_data4,addr_4_mux);
        data_err[5] <= DATA_CHK(rd_data5,addr_5_mux);
        data_err[6] <= DATA_CHK(rd_data6,addr_6_mux);
        data_err[7] <= DATA_CHK(rd_data7,addr_7_mux);
end
    end
end


assign err = |data_err;

function DATA_CHK;
    input [MEM_DQ_WIDTH-1:0] data_in;
    input   [3:0]   addr;
    reg     [3:0]   data_random;
    reg     [MEM_DQ_WIDTH-1:0]  expect_data;
    begin
        data_random = data_in[7:4];
        expect_data = {DQ_NUM{data_random,(data_random ^ addr)}};
        DATA_CHK = data_in != expect_data;
    end
endfunction

always @(posedge clk or negedge rst_n)
begin
    if(~rst_n)
    begin
        err_cnt <= 8'b0;
        err_flag_led <= 1'b0;
    end
    else if(err && axi_rvalid_d1)
    begin
        if(err_cnt == 8'hff)
            err_cnt <= err_cnt;
        else
            err_cnt <= err_cnt + 8'b1;
        err_flag_led <= 1'b1;
    end
end        
        
 endmodule
    
      	  	




`timescale 1ns/1ns
module test_wr_ctrl #(
    parameter          CTRL_ADDR_WIDTH      =    28,
    parameter          MEM_DQ_WIDTH         =    16,
    parameter          MEM_COL_ADDR_WIDTH   =    10,
    parameter          MEM_SPACE_AW         =    18
)(                        
    input                                clk                ,
    input                                rst_n              ,   
    input                                init_start         ,
    input                                write_en           ,
    output reg                           write_done_p       ,
    output reg                           init_done          ,

    input [CTRL_ADDR_WIDTH-1:0]          random_rw_addr     ,     
    input [3:0]                          random_axi_id      ,
    input [3:0]                          random_axi_len     ,
    input                                random_axi_ap      ,

    input                                data_pattern_01    ,
    input                                random_data_en     ,

    output reg [CTRL_ADDR_WIDTH-1:0]     axi_awaddr          ,
    output reg                           axi_awuser_ap       ,    
    output reg [3:0]                     axi_awuser_id       ,
    output reg [3:0]                     axi_awlen           ,
    input                                axi_awready         ,
    output reg                           axi_awvalid         ,
          
    output reg [MEM_DQ_WIDTH*8-1:0]      axi_wdata        ,
    output     [MEM_DQ_WIDTH*8/8-1:0]    axi_wstrb        ,
    input                                axi_wready       ,
    input [3:0]                          axi_wusero_id    , 
    input                                axi_wusero_last                    
);

localparam DQ_NUM = MEM_DQ_WIDTH/8;

localparam AXI_ADDR_MAX = (1<<MEM_SPACE_AW);

localparam E_IDLE = 0;
localparam E_WR = 1;
localparam E_END = 2;

reg [1:0] axi_wready_d;
reg [CTRL_ADDR_WIDTH:0] init_addr;
reg [CTRL_ADDR_WIDTH-1:0] normal_wr_addr;
reg [3:0] state;
wire [3:0] wr_data_addr;
wire [3:0] wr_data_addr0;
reg [15:0] req_wr_cnt     ;
reg [15:0] execute_wr_cnt ;
wire  write_finished ;
reg [7:0] cnt_len;
wire[127:0] prbs_out;

wire[3:0]   wr_data_random_0;
wire[3:0]   wr_data_random_1;
wire[3:0]   wr_data_random_2;
wire[3:0]   wr_data_random_3;
wire[3:0]   wr_data_random_4;
wire[3:0]   wr_data_random_5;
wire[3:0]   wr_data_random_6;
wire[3:0]   wr_data_random_7;

wire [3:0]   data_0;
wire [3:0]   data_1;
wire [3:0]   data_2;
wire [3:0]   data_3;
wire [3:0]   data_4;
wire [3:0]   data_5;
wire [3:0]   data_6;
wire [3:0]   data_7;

wire [7:0]   wr_data_0;
wire [7:0]   wr_data_1;
wire [7:0]   wr_data_2;
wire [7:0]   wr_data_3;
wire [7:0]   wr_data_4;
wire [7:0]   wr_data_5;
wire [7:0]   wr_data_6;
wire [7:0]   wr_data_7;

assign axi_wstrb = {MEM_DQ_WIDTH{1'b1}};


always @(posedge clk or negedge rst_n)
begin
   if (!rst_n) begin
      axi_awaddr     <= 'b0; 
      axi_awuser_ap  <= 'b0; 
      axi_awuser_id  <= 4'b0; 
      axi_awlen      <= 4'b0; 
      axi_awvalid    <= 1'b0;
//      cnt            <= 32'd0; 
      state          <= E_IDLE;
      write_done_p   <= 1'b0;
   end
   else begin
    if(init_start) begin
        axi_awlen <= 4'd15;
        axi_awuser_ap  <= 'b0;
        if (axi_awaddr < (AXI_ADDR_MAX - 8'd128)) begin
            axi_awvalid <= 1;
            if(axi_awvalid&axi_awready) begin
             axi_awaddr <= axi_awaddr + 8'd128;
             axi_awuser_id  <= axi_awuser_id + 1;
            end
        end
        else if(axi_awaddr == (AXI_ADDR_MAX - 8'd128)) begin
           if(axi_awvalid&axi_awready) 
           axi_awvalid <= 0;
        end
        else
         axi_awvalid <= 0;
    end
    else begin
        if ((state == E_IDLE) && write_en && write_finished) begin //add more condition for easy debug
        axi_awuser_id <= random_axi_id;
   	    axi_awaddr    <= random_rw_addr;
   	    axi_awlen     <= random_axi_len;
   	    axi_awuser_ap <= random_axi_ap;
   	    end 
   	    case(state) 
  	     	 E_IDLE: begin
   	     	 	  if (write_en && write_finished)
   	     	 	     state <= E_WR;
   	     	 end
   	     	 E_WR: begin
   	     	 	  axi_awvalid <= 1'b1;   	     	 	  
   	     	 	  if (axi_awvalid&axi_awready) begin
   	     	 	     state <= E_END;
   	     	 	     write_done_p <= 1'b1;
   	     	 	     axi_awvalid <= 1'b0;
   	     	 	  end
   	     	 end
   	     	 E_END: begin
   	     	      axi_awvalid <= 1'b0;
   	     	 	  write_done_p <= 1'b0;
   	     	 	  if (write_finished)
   	     	 	     state <= E_IDLE;
   	     	 end
   	     	 default: begin
   	     	 	  state <= E_IDLE;
   	     	 end   	        
   	endcase 
    end
end
end

always @(posedge clk or negedge rst_n)
   if (!rst_n)
      axi_wready_d <= 2'd0;
   else
   	  axi_wready_d <= {axi_wready_d[0], axi_wready};


always @(posedge clk or negedge rst_n)
begin
   if (!rst_n) begin
     axi_wdata <= 'h0;
     init_addr <= 'd0;
     normal_wr_addr <= 'd0;
     init_done <= 0;   
   end
   else begin
    if(init_start) begin
      if(init_addr < AXI_ADDR_MAX)begin
        axi_wdata <= {{DQ_NUM{wr_data_7}},{DQ_NUM{wr_data_6}},{DQ_NUM{wr_data_5}},{DQ_NUM{wr_data_4}},{DQ_NUM{wr_data_3}},{DQ_NUM{wr_data_2}},{DQ_NUM{wr_data_1}},{DQ_NUM{wr_data_0}}};
        if(axi_wready) begin 
        init_addr <= init_addr + 8;   
    end   
    end
    else begin
       axi_wdata <= 'h0;
       init_done <= 1; 
    end
    end
    else begin
        if(state == E_WR)begin 
        normal_wr_addr <= axi_awaddr;
        axi_wdata <= 'h0; 
        end
        else if(state == E_END) begin
        axi_wdata <= {{DQ_NUM{wr_data_7}},{DQ_NUM{wr_data_6}},{DQ_NUM{wr_data_5}},{DQ_NUM{wr_data_4}},{DQ_NUM{wr_data_3}},{DQ_NUM{wr_data_2}},{DQ_NUM{wr_data_1}},{DQ_NUM{wr_data_0}}};
        if(axi_wready) begin
        normal_wr_addr <= normal_wr_addr + 8;
        end
        end   
        else
          axi_wdata <= 'h0;
    end
end
end


assign wr_data_addr0 = (init_start==1) ? init_addr[3:0] : normal_wr_addr[3:0];
assign wr_data_addr = (axi_wready == 1) ? (wr_data_addr0 + 8) : wr_data_addr0;


always @(posedge clk or negedge rst_n)
   if (!rst_n) begin
   	  req_wr_cnt     <= 16'd0;
   	  execute_wr_cnt <= 16'd0;
   end
   else if (!init_start)
   begin
   	  if (axi_awvalid & axi_awready) begin
//   	    if(axi_awlen == 4'd0)
//   	    req_wr_cnt <= req_wr_cnt + 16;
//   	    else
   	  	req_wr_cnt <= req_wr_cnt + axi_awlen + 1;
   	  end   	  
   	  if (axi_wready) begin
   	     execute_wr_cnt <= execute_wr_cnt + 1;
   	  end      
   end
   else begin
   	  req_wr_cnt     <= 16'd0;
   	  execute_wr_cnt <= 16'd0;   
end

assign write_finished = (req_wr_cnt == execute_wr_cnt);

assign  data_0 = wr_data_addr + 4'd0;
assign  data_1 = wr_data_addr + 4'd1;
assign  data_2 = wr_data_addr + 4'd2;
assign  data_3 = wr_data_addr + 4'd3;
assign  data_4 = wr_data_addr + 4'd4;
assign  data_5 = wr_data_addr + 4'd5;
assign  data_6 = wr_data_addr + 4'd6;
assign  data_7 = wr_data_addr + 4'd7;

assign wr_data_0 = data_pattern_01 ? 8'hff : {wr_data_random_0,(wr_data_random_0 ^ data_0)};
assign wr_data_1 = data_pattern_01 ? 8'h00 : {wr_data_random_1,(wr_data_random_1 ^ data_1)};
assign wr_data_2 = data_pattern_01 ? 8'hff : {wr_data_random_2,(wr_data_random_2 ^ data_2)};
assign wr_data_3 = data_pattern_01 ? 8'h00 : {wr_data_random_3,(wr_data_random_3 ^ data_3)};
assign wr_data_4 = data_pattern_01 ? 8'hff : {wr_data_random_4,(wr_data_random_4 ^ data_4)};
assign wr_data_5 = data_pattern_01 ? 8'h00 : {wr_data_random_5,(wr_data_random_5 ^ data_5)};
assign wr_data_6 = data_pattern_01 ? 8'hff : {wr_data_random_6,(wr_data_random_6 ^ data_6)};
assign wr_data_7 = data_pattern_01 ? 8'h00 : {wr_data_random_7,(wr_data_random_7 ^ data_7)};

assign wr_data_random_0 = random_data_en ? prbs_out[3:0]   : 4'b0 ;
assign wr_data_random_1 = random_data_en ? prbs_out[7:4]   : 4'b0 ;
assign wr_data_random_2 = random_data_en ? prbs_out[11:8]  : 4'b0 ;
assign wr_data_random_3 = random_data_en ? prbs_out[15:12] : 4'b0 ;
assign wr_data_random_4 = random_data_en ? prbs_out[19:16] : 4'b0 ;
assign wr_data_random_5 = random_data_en ? prbs_out[23:20] : 4'b0 ;
assign wr_data_random_6 = random_data_en ? prbs_out[27:24] : 4'b0 ;
assign wr_data_random_7 = random_data_en ? prbs_out[31:28] : 4'b0 ;

prbs31_128bit #(
    .PRBS_INIT      (128'h1234_5678_9abc_def0_8686_2016_0707_336a),
//    .PRBS_INIT      (128'h0),
    .PRBS_GEN_EN    (1'b1       )
)u_prbs(
    .clk            (clk        ),
    .rstn           (rst_n      ),
    .clk_en         (1'b1       ),

    .cnt_mode       (1'b0       ),
    .din            (128'b0     ),
    .dout           (prbs_out   ),
    .insert_er      (1'b0       ),
    .error          (           )
);
                    
endmodule




////////////////////////////////////////////////////////////////////////////// 
// Copyright (c) 2014 Shenzhen Pango Microsystems CO.,LTD                      
// All Rights Reserved.                                                        
///////////////////////////////////////////////////////////////////////////////
`timescale 1ns/10ps
module ips2l_rst_sync_v1_0 (
    input rclk,
    input sync_din,
    output sync_dout
);
    reg [1:0] sync_d;
    always @(posedge rclk) 
        sync_d <= {sync_d[0], sync_din};
    
    assign sync_dout = sync_d[1];

endmodule



////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module   ips2l_ddrphy_wrlvl_v1_0 #(
  parameter [7:0]   TMOD        = 8'd3,
  parameter [7:0]   TRFC        = 8'd16,
  parameter MEM_ADDR_WIDTH      = 16,
  parameter MEM_BANKADDR_WIDTH  = 3
)(

  input [15:0]       mr1_ddr3       ,
  input              ddrphy_sysclk  ,
  input              ddrphy_rst_n   ,

  input              wrlvl_start    ,
  output reg         wrlvl_done     ,
  input              wrlvl_error    ,

  output reg         wrlvl_dqs_req  ,
  input              wrlvl_dqs_resp ,

  output [3:0]       dbg_wrlvl      ,

  output reg [MEM_BANKADDR_WIDTH-1:0]   wrlvl_ba       ,
  output reg [MEM_ADDR_WIDTH-1:0]       wrlvl_address  ,
  output reg  wrlvl_cs_n     ,
  output reg  wrlvl_ras_n    ,
  output reg  wrlvl_cas_n    ,
  output reg  wrlvl_we_n     ,
  output reg  wrlvl_cke      ,
  output reg  wrlvl_odt
 );

  localparam   WRLVL_IDLE          = 4'd0;
  localparam   WRLVL_LOAD_MR1      = 4'd1;
  localparam   WRLVL_WAIT_DQSEN    = 4'd2;
  localparam   WRLVL_TRAIN_STATRT  = 4'd3;
  localparam   WRLVL_WAIT          = 4'd4;
  localparam   WRLVL_ODT_WAIT      = 4'd5;
  localparam   WRLVL_LOAD_MR1_WAIT = 4'd6;
  localparam   WRLVL_TRAIN_DONE    = 4'd7;
  localparam   WRLVL_TRAIN_ERROR   = 4'd8;

  reg [3:0]  wrlvl_state        ;
  reg [3:0]  wrlvl_next_state   ;

  reg [7:0]  cmd_cnt ;

  reg        cnt_tmod_pass ;
  reg        cnt_twldqsen_pass ;
  reg        wrlvl_dqs_resp_r ;

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
         wrlvl_state  <= WRLVL_IDLE ;
      else
         wrlvl_state  <= wrlvl_next_state ;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
          cmd_cnt   <= 8'b0;
      else
        case(wrlvl_next_state)
            WRLVL_WAIT_DQSEN,
            WRLVL_LOAD_MR1_WAIT,
            WRLVL_ODT_WAIT: cmd_cnt <= cmd_cnt + 8'b1;
            default       : cmd_cnt   <= 8'b0;
        endcase
  end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n)
       wrlvl_dqs_resp_r  <= 1'b0;
    else if(wrlvl_next_state == WRLVL_IDLE)
       wrlvl_dqs_resp_r  <= 1'b0;
    else if(wrlvl_dqs_resp)               //write leveling training done
       wrlvl_dqs_resp_r  <= 1'b1;   
 end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)
       cnt_tmod_pass   <= 1'b0;
    else
       cnt_tmod_pass   <= (cmd_cnt == TMOD);
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)
       cnt_twldqsen_pass  <= 1'b0;
    else
       cnt_twldqsen_pass <= cmd_cnt[5] ;  //twldqsen:25   32
  end

  always @(*) 
  begin
       wrlvl_next_state =  WRLVL_IDLE ;
    case(wrlvl_state)
         WRLVL_IDLE : if(wrlvl_start)
                           wrlvl_next_state = WRLVL_LOAD_MR1 ;

        WRLVL_LOAD_MR1 : if(wrlvl_dqs_resp_r)                         //write leveling training done
                              wrlvl_next_state = WRLVL_LOAD_MR1_WAIT;
                         else
                              wrlvl_next_state = WRLVL_WAIT_DQSEN;

        WRLVL_WAIT_DQSEN : begin
                              if(cnt_twldqsen_pass)                   //delay twldqsen
                                 wrlvl_next_state = WRLVL_TRAIN_STATRT;
                              else
                                 wrlvl_next_state = WRLVL_WAIT_DQSEN;
                           end

        WRLVL_TRAIN_STATRT :   wrlvl_next_state = WRLVL_WAIT ;        //training start,wrlvl_dqs_req = 1

        WRLVL_WAIT :    begin                                         //write leveling training process
                           if(wrlvl_error)
                                 wrlvl_next_state = WRLVL_TRAIN_ERROR;
                           else if(wrlvl_dqs_resp)                         //write leveling training done
                                 wrlvl_next_state = WRLVL_ODT_WAIT;
                           else
                                 wrlvl_next_state = WRLVL_WAIT;
                        end

        WRLVL_ODT_WAIT : begin                                       //delay
                            if(cmd_cnt[4])
                                wrlvl_next_state = WRLVL_LOAD_MR1;
                            else
                                wrlvl_next_state = WRLVL_ODT_WAIT;
                         end

        WRLVL_LOAD_MR1_WAIT :begin
                               if(cnt_tmod_pass)            //delay tmod
                                  wrlvl_next_state = WRLVL_TRAIN_DONE ;
                               else
                                  wrlvl_next_state = WRLVL_LOAD_MR1_WAIT;
                             end

        WRLVL_TRAIN_DONE :     wrlvl_next_state = WRLVL_IDLE ;   
        
        WRLVL_TRAIN_ERROR :begin
                               wrlvl_next_state = WRLVL_TRAIN_ERROR ;
                           end

    endcase
  end


  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
          wrlvl_cke   <= 1'b0;
      else
          wrlvl_cke   <= 1'b1;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
        wrlvl_odt   <= 1'b0;
      else if ((wrlvl_next_state ==WRLVL_WAIT_DQSEN) & (cmd_cnt == TMOD))
        wrlvl_odt   <= 1'b1;
      else if(wrlvl_dqs_resp)
        wrlvl_odt   <= 1'b0;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)  begin
          wrlvl_ba       <= {MEM_BANKADDR_WIDTH{1'b0}};
          wrlvl_address  <= {MEM_ADDR_WIDTH{1'b0}};
          wrlvl_cs_n     <= 1'b1;
          wrlvl_ras_n    <= 1'b1;
          wrlvl_cas_n    <= 1'b1;
          wrlvl_we_n     <= 1'b1;
      end
      else
        case(wrlvl_next_state)
           WRLVL_LOAD_MR1  : begin
                                 wrlvl_cs_n      <= 1'b0;
                                 wrlvl_ras_n     <= 1'b0;
                                 wrlvl_cas_n     <= 1'b0;
                                 wrlvl_we_n      <= 1'b0;
                                 wrlvl_ba        <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b01};
                               begin
                                 if(wrlvl_dqs_resp_r)
                                    wrlvl_address  <= {{(MEM_ADDR_WIDTH-13){1'b0}},mr1_ddr3[12:8],1'b0,mr1_ddr3[6:0]}; //write leveling disable
                                else
                                    wrlvl_address  <= {{(MEM_ADDR_WIDTH-13){1'b0}},mr1_ddr3[12:8],1'b1,mr1_ddr3[6:0]}; //write leveling enable
                              end
                            end

         default      :  begin
                            wrlvl_cs_n      <= 1'b1;
                            wrlvl_ras_n     <= 1'b1;
                            wrlvl_cas_n     <= 1'b1;
                            wrlvl_we_n      <= 1'b1;
                            wrlvl_ba        <= {MEM_BANKADDR_WIDTH{1'b0}};
                            wrlvl_address   <= {MEM_ADDR_WIDTH{1'b0}};
                         end
     endcase
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)
       wrlvl_dqs_req   <= 1'b0;
   else if (wrlvl_dqs_resp)            ///clear wrlvl_dqs_req
       wrlvl_dqs_req   <= 1'b0;
    else if(wrlvl_next_state == WRLVL_TRAIN_STATRT)
       wrlvl_dqs_req   <= 1'b1;
  end


  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)
       wrlvl_done   <= 1'b0;
    else
       wrlvl_done   <= (wrlvl_next_state == WRLVL_TRAIN_DONE);
  end

  assign  dbg_wrlvl  = wrlvl_next_state;

endmodule




// Generated by IP Generator (Version 2020.1-SP5 build 56918)



////////////////////////////////////////////////////////////////     
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                        
// ALL RIGHTS REVERVED.                                              
////////////////////////////////////////////////////////////////     
//Description:                                                       
//Author:  wxxiao                                                    
//History: v1.0                                                      
////////////////////////////////////////////////////////////////     
`timescale 1ns/1ps                                                   
module   ips2l_ddrphy_slice_top_v1_0 #( 
  parameter real CLKIN_FREQ       = 50.0, 
  parameter   PPLL_BANDWIDTH      = "OPTIMIZED",
  parameter   [1:0] DDR_TYPE      = 2'b00 ,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR 
  parameter   GATE_MODE           = 0 ,
  parameter   TEST_DATA_PATTERN0  = 64'h55_aa_55_aa_08_f7_08_f7,  
  parameter   TEST_DATA_PATTERN1  = 64'h7f_9f_7f_9f_80_fe_80_fe,  
  parameter   TEST_DATA_PATTERN2  = 64'hf0_0f_f0_0f_01_ff_01_ff,  
  parameter   TEST_DATA_PATTERN3  = 64'hdf_aa_df_aa_55_aa_55_aa,  
  parameter   [1:0] SC_LDO_CTRL   = 2'b00,
  parameter   [0:0] SC_DLY_2X     = 1'b0 ,    //1'b0  1x delay chain, 1'b1 2x delay chain 
  parameter   PPLL_IDIV           = 2,
  parameter   PPLL_FDIV           = 64,
  parameter   PPLL_ODIVPHY        = 4,      
  parameter   MEM_ADDR_WIDTH      = 16,
  parameter   MEM_BANKADDR_WIDTH  = 3,
  parameter   MEM_DQ_WIDTH        = 16,
  parameter   MEM_DQS_WIDTH       = 2,
  parameter   MEM_DM_WIDTH        = 2
)(                          
  input [4:0]                      mc_rl                ,
  input                            force_read_clk_ctrl  ,
  input [3*MEM_DQS_WIDTH-1:0]      init_read_clk_ctrl   ,
  input [4*MEM_DQS_WIDTH-1:0]      init_slip_step       ,
  input                            force_samp_position  ,
  input [8*MEM_DQS_WIDTH-1:0]      init_samp_position_even,
  input [8*MEM_DQS_WIDTH-1:0]      init_samp_position_odd,
  input                            wrlvl_en             ,
  input [8*MEM_DQS_WIDTH-1:0]      init_wrlvl_step      ,
                                                        
  input                            ddrphy_sysclk        ,
  input                            ddrphy_rst_n         ,
  input                            phy_refclk           ,
  input                            phy_pll_rst          ,
  input                            clkoutphy_gate       , 
  input                            ioclkdiv_rst         , 
  input                            dll_rstn             ,
  input                            dll_freeze           ,
  input                            dll_update_n         ,
  output                           phy_pll_lock         ,
  output                           phy_dll_lock         ,
  output                           phy_sysclk_fb        ,
  output                           phy_ioclk_fb         ,
  input                            ddrphy_dqs_rst       ,
  input                            ddrphy_dqs_training_rstn,
  input                            ddrphy_iol_rst      ,
//wrlvl                                                  
  input                            wrlvl_dqs_req        ,
  output                           wrlvl_dqs_resp       ,
  output                           wrlvl_error          ,
                                   
//dqs                                              
  input                            gatecal_start        ,
  output                           gate_check_pass      ,
  output                           gate_adj_done        ,
  output                           gate_cal_error       ,
  input                            gate_move_en         ,
                                                         
  input                            rddata_cal           ,
  output                           rddata_check_pass    ,
  input [3:0]                      read_cmd             ,

  output [2*MEM_DQS_WIDTH-1:0]     dqs_drift            ,
  input [2*MEM_DQS_WIDTH-1:0]      comp_val             ,
  input [MEM_DQS_WIDTH-1:0]        comp_dir             ,
  input                            dqs_gate_comp_en     ,
  output                           dqs_gate_comp_done   ,
                                   
///rdel                                                  
  input                            init_adj_rdel        ,
  output                           adj_rdel_done        ,
  input                            rdel_calibration     ,
  output                           rdel_calib_done      ,
  output                           rdel_calib_error     ,
  input                            rdel_move_en         ,
  output                           rdel_move_done       ,
  input                            bitslip_ctrl         ,
  
  output                           wrcal_check_pass     ,
  input                            write_calibration    ,
  input                            wrcal_move_en        ,
  output                           wrcal_move_done      ,
                                                         
  input                            eye_calibration      ,
  output                           eyecal_check_pass    ,
  output                           eyecal_move_done     ,
  input                            eyecal_move_en       ,
                                              
//rdata                                                  
  output    	                   read_valid           ,
  output reg [8*MEM_DQ_WIDTH-1:0]  o_read_data          ,
  output                           align_error          , 
//wdata                                                  
  input [3:0]                      phy_wrdata_en        ,
  input [8*MEM_DM_WIDTH-1:0]       phy_wrdata_mask      ,
  input [8*MEM_DQ_WIDTH-1:0]       phy_wrdata           ,
  input [3:0]                      phy_cke              ,
  input [3:0]                      phy_cs_n             ,
  input [3:0]                      phy_ras_n            ,
  input [3:0]                      phy_cas_n            ,
  input [3:0]                      phy_we_n             ,
  input [4*MEM_ADDR_WIDTH-1:0]     phy_addr             ,
  input [4*MEM_BANKADDR_WIDTH-1:0] phy_ba               ,
  input [3:0]                      phy_odt              ,
  input [3:0]                      phy_ck               ,
  input                            phy_rst              ,
  output                           mem_rst_n            ,
  output                           mem_ck               ,
  output                           mem_ck_n             ,
  output                           mem_cke              ,
  output                           mem_cs_n             ,
  output                           mem_ras_n            ,
  output                           mem_cas_n            ,
  output                           mem_we_n             ,
  output                           mem_odt              ,
  output [MEM_ADDR_WIDTH-1:0]      mem_a                ,
  output [MEM_BANKADDR_WIDTH-1:0]  mem_ba               ,
  inout [MEM_DQS_WIDTH-1:0]        mem_dqs              ,
  inout [MEM_DQS_WIDTH-1:0]        mem_dqs_n            ,
  inout [MEM_DQ_WIDTH-1:0]         mem_dq               ,
  output [MEM_DM_WIDTH-1:0]        mem_dm               ,
  output [66*MEM_DQS_WIDTH -1:0]   debug_data   
  );                                            

  localparam  BANK_NUM = 2;

  localparam  MEM_CA_GROUP = 4;

localparam DQ0_BANK_NUM = 1;

localparam DQ8_BANK_NUM = 1;

localparam DQ16_BANK_NUM = 1;

localparam DQ24_BANK_NUM = 1;

localparam DQ32_BANK_NUM = 2;

localparam DQ40_BANK_NUM = 1;

localparam DQ48_BANK_NUM = 1;

localparam DQ56_BANK_NUM = 1;

localparam DQ64_BANK_NUM = 0;

localparam CKE_GROUP_NUM = 0;

localparam CK_GROUP_NUM = 1;

localparam CS_GROUP_NUM = 2;

localparam RAS_GROUP_NUM = 1;

localparam CAS_GROUP_NUM = 1;

localparam WE_GROUP_NUM = 1;

localparam ODT_GROUP_NUM = 2;

localparam BA0_GROUP_NUM = 3;

localparam BA1_GROUP_NUM = 2;

localparam BA2_GROUP_NUM = 1;

localparam A0_GROUP_NUM = 1;

localparam A1_GROUP_NUM = 0;

localparam A2_GROUP_NUM = 0;

localparam A3_GROUP_NUM = 3;

localparam A4_GROUP_NUM = 0;

localparam A5_GROUP_NUM = 0;

localparam A6_GROUP_NUM = 1;

localparam A7_GROUP_NUM = 0;

localparam A8_GROUP_NUM = 1;

localparam A9_GROUP_NUM = 1;

localparam A10_GROUP_NUM = 0;

localparam A11_GROUP_NUM = 2;

localparam A12_GROUP_NUM = 0;

localparam A13_GROUP_NUM = 0;

localparam A14_GROUP_NUM = 2;

localparam A15_GROUP_NUM = 0;


  wire [MEM_DQS_WIDTH-1:0]     dqs_read_valid     ;
  wire [8*MEM_DQ_WIDTH-1:0]    dqs_read_data      ;
  wire                         dqs_align_valid    ;
  wire [8*MEM_DQ_WIDTH-1:0]    dqs_align_data     ;
  
  integer i,j;
  reg [8*MEM_DQ_WIDTH-1:0]    phy_wrdata_reorder; 
  reg [8*MEM_DM_WIDTH-1:0]    phy_wrdata_mask_reorder; 
  reg [4*MEM_BANKADDR_WIDTH-1:0]  phy_ba_reorder ;
  reg [4*MEM_ADDR_WIDTH-1:0]  phy_addr_reorder ;
  
  wire [MEM_DQS_WIDTH-1:0]    wrlvl_error_tmp       ;
  wire [MEM_DQS_WIDTH-1:0]    wrlvl_dqs_resp_tmp    ;
  wire [MEM_DQS_WIDTH-1:0]    adj_rdel_done_tmp     ;
  wire [MEM_DQS_WIDTH-1:0]    rdel_calib_done_tmp   ;
  wire [MEM_DQS_WIDTH-1:0]    rdel_calib_error_tmp  ;
  wire [MEM_DQS_WIDTH-1:0]    rdel_move_done_tmp    ;
  wire [MEM_DQS_WIDTH-1:0]    gate_check_pass_tmp   ;
  wire [MEM_DQS_WIDTH-1:0]    gate_adj_done_tmp     ;
  wire [MEM_DQS_WIDTH-1:0]    gate_cal_error_tmp    ;
  wire [MEM_DQS_WIDTH-1:0]    rddata_check_pass_tmp ;
  wire [MEM_DQS_WIDTH-1:0]    dqs_gate_comp_done_tmp;  
  wire [MEM_DQS_WIDTH-1:0]    dll_lock_tmp          ;
  wire [MEM_DQS_WIDTH-1:0]    wrcal_check_pass_tmp  ;
  wire [MEM_DQS_WIDTH-1:0]    wrcal_move_done_tmp   ;
  wire [MEM_DQS_WIDTH-1:0]    eyecal_check_pass_tmp ;
  wire [MEM_DQS_WIDTH-1:0]    eyecal_move_done_tmp  ;
  
//  wire align_error;
  
  wire [7:0]  adj_cke       ;
  wire [7:0]  adj_cs_n      ;
  wire [7:0]  adj_ras_n     ;
  wire [7:0]  adj_cas_n     ;
  wire [7:0]  adj_we_n      ;
  wire [8*MEM_ADDR_WIDTH-1:0]     adj_addr      ;
  wire [8*MEM_BANKADDR_WIDTH-1:0] adj_ba        ;
  wire [7:0]  adj_odt       ;
  wire [7:0]  adj_ck        ;
  
  wire [MEM_CA_GROUP-1:0] wclk_ca         ;
  wire [MEM_CA_GROUP-1:0] padt_ca         ;
  wire [MEM_CA_GROUP-1:0] wclk_del_ca     ;
  wire [MEM_CA_GROUP-1:0] padt_del_ca     ;
  wire wclk_ck                             ;
  wire padt_ck                             ;
  wire pado_mem_ck                         ;
  wire padt_mem_ck                         ;
  wire wclk_odt                            ;
  wire padt_odt                            ;  
  wire pado_mem_odt                        ;
  wire padt_mem_odt                        ;
  wire wclk_cs_n                           ;
  wire padt_cs_n                           ;  
  wire pado_mem_cs_n                       ;
  wire padt_mem_cs_n                       ;
  wire wclk_ras_n                          ;
  wire padt_ras_n                          ;  
  wire pado_mem_ras_n                      ;
  wire padt_mem_ras_n                      ;
  wire wclk_cas_n                          ;
  wire padt_cas_n                          ;  
  wire pado_mem_cas_n                      ;
  wire padt_mem_cas_n                      ;
  wire wclk_we_n                           ;
  wire padt_we_n                           ;  
  wire pado_mem_we_n                       ;
  wire padt_mem_we_n                       ;
  wire wclk_cke                            ;
  wire padt_cke                            ;  
  wire pado_mem_cke                        ;
  wire padt_mem_cke                        ;
  wire [MEM_BANKADDR_WIDTH-1:0] wclk_ba    ;
  wire [MEM_BANKADDR_WIDTH-1:0] padt_ba    ;  
  wire [MEM_BANKADDR_WIDTH-1:0] pado_mem_ba;
  wire [MEM_BANKADDR_WIDTH-1:0] padt_mem_ba;
  wire [MEM_ADDR_WIDTH-1:0] wclk_a         ;
  wire [MEM_ADDR_WIDTH-1:0] padt_a         ;  
  wire [MEM_ADDR_WIDTH-1:0] pado_mem_a     ;
  wire [MEM_ADDR_WIDTH-1:0] padt_mem_a     ;
  
   
  wire [BANK_NUM-1:0] pll_lock_tmp;
  wire [BANK_NUM-1:0] phy_clk_p;
  wire [BANK_NUM-1:0] phy_sysclk_p;
  wire [BANK_NUM-1:0] ppll_clkin;
  wire phy_ca_clk_p       ; 
  wire phy_ca_sysclk_p    ;
  wire [MEM_DQS_WIDTH-1:0] phy_dq_clk_p    ;
  wire [MEM_DQS_WIDTH-1:0] phy_dq_sysclk_p ;

  
//************************************************// 
 
 assign   wrlvl_error        = |wrlvl_error_tmp       ; 
 assign   wrlvl_dqs_resp     = &wrlvl_dqs_resp_tmp    ;                                                 
 assign   adj_rdel_done      = &adj_rdel_done_tmp     ;
 assign   rdel_calib_done    = &rdel_calib_done_tmp   ;
 assign   rdel_calib_error   = |rdel_calib_error_tmp  ;
 assign   rdel_move_done     = &rdel_move_done_tmp    ;
 assign   gate_check_pass    = &gate_check_pass_tmp   ;  
 assign   gate_adj_done      = &gate_adj_done_tmp     ; 
 assign   gate_cal_error     = |gate_cal_error_tmp    ;
 assign   rddata_check_pass  = &rddata_check_pass_tmp ; 
 assign   dqs_gate_comp_done = &dqs_gate_comp_done_tmp;
 assign   phy_pll_lock       = &pll_lock_tmp;
 assign   phy_dll_lock       = &dll_lock_tmp;
 assign   wrcal_check_pass   = &wrcal_check_pass_tmp  ;
 assign   wrcal_move_done    = &wrcal_move_done_tmp   ;
 assign   eyecal_check_pass  = &eyecal_check_pass_tmp ;
 assign   eyecal_move_done   = &eyecal_move_done_tmp  ;


assign phy_ca_clk_p = phy_clk_p[0];
assign phy_ca_sysclk_p = phy_sysclk_p[0];

 
assign phy_dq_clk_p[0] = phy_clk_p[DQ0_BANK_NUM];
assign phy_dq_sysclk_p[0] = phy_sysclk_p[DQ0_BANK_NUM];
 
assign phy_dq_clk_p[1] = phy_clk_p[DQ8_BANK_NUM];
assign phy_dq_sysclk_p[1] = phy_sysclk_p[DQ8_BANK_NUM];

assign phy_dq_clk_p[2] = phy_clk_p[DQ16_BANK_NUM];
assign phy_dq_sysclk_p[2] = phy_sysclk_p[DQ16_BANK_NUM];

assign phy_dq_clk_p[3] = phy_clk_p[DQ24_BANK_NUM];
assign phy_dq_sysclk_p[3] = phy_sysclk_p[DQ24_BANK_NUM];
 

assign phy_ioclk_fb  = phy_clk_p[0];
assign phy_sysclk_fb = phy_sysclk_p[0];


assign wclk_cke    = wclk_ca[CKE_GROUP_NUM];
assign padt_cke    = padt_ca[CKE_GROUP_NUM];

assign wclk_ck     = wclk_ca[CK_GROUP_NUM];
assign padt_ck     = padt_ca[CK_GROUP_NUM];

assign wclk_cs_n   = wclk_ca[CS_GROUP_NUM];
assign padt_cs_n   = padt_ca[CS_GROUP_NUM];

assign wclk_ras_n  = wclk_del_ca[RAS_GROUP_NUM];
assign padt_ras_n  = padt_del_ca[RAS_GROUP_NUM];

assign wclk_cas_n  = wclk_ca[CAS_GROUP_NUM];
assign padt_cas_n  = padt_ca[CAS_GROUP_NUM]; 

assign wclk_we_n   = wclk_ca[WE_GROUP_NUM];
assign padt_we_n   = padt_ca[WE_GROUP_NUM];

assign wclk_odt    = wclk_ca[ODT_GROUP_NUM];
assign padt_odt    = padt_ca[ODT_GROUP_NUM];

assign wclk_ba[0]  = wclk_ca[BA0_GROUP_NUM];
assign padt_ba[0]  = padt_ca[BA0_GROUP_NUM];

assign wclk_ba[1]  = wclk_ca[BA1_GROUP_NUM];
assign padt_ba[1]  = padt_ca[BA1_GROUP_NUM];

assign wclk_ba[2]  = wclk_ca[BA2_GROUP_NUM];
assign padt_ba[2]  = padt_ca[BA2_GROUP_NUM];

assign wclk_a[0]  = wclk_ca[A0_GROUP_NUM];
assign padt_a[0]  = padt_ca[A0_GROUP_NUM];

assign wclk_a[1]  = wclk_ca[A1_GROUP_NUM];
assign padt_a[1]  = padt_ca[A1_GROUP_NUM];

assign wclk_a[2]  = wclk_ca[A2_GROUP_NUM];
assign padt_a[2]  = padt_ca[A2_GROUP_NUM];

assign wclk_a[3]  = wclk_del_ca[A3_GROUP_NUM];
assign padt_a[3]  = padt_del_ca[A3_GROUP_NUM];

assign wclk_a[4]  = wclk_del_ca[A4_GROUP_NUM];
assign padt_a[4]  = padt_del_ca[A4_GROUP_NUM];

assign wclk_a[5]  = wclk_ca[A5_GROUP_NUM];
assign padt_a[5]  = padt_ca[A5_GROUP_NUM];

assign wclk_a[6]  = wclk_ca[A6_GROUP_NUM];
assign padt_a[6]  = padt_ca[A6_GROUP_NUM];

assign wclk_a[7]  = wclk_ca[A7_GROUP_NUM];
assign padt_a[7]  = padt_ca[A7_GROUP_NUM];

assign wclk_a[8]  = wclk_ca[A8_GROUP_NUM];
assign padt_a[8]  = padt_ca[A8_GROUP_NUM];

assign wclk_a[9]  = wclk_ca[A9_GROUP_NUM];
assign padt_a[9]  = padt_ca[A9_GROUP_NUM];

assign wclk_a[10]  = wclk_ca[A10_GROUP_NUM];
assign padt_a[10]  = padt_ca[A10_GROUP_NUM];

assign wclk_a[11]  = wclk_ca[A11_GROUP_NUM];
assign padt_a[11]  = padt_ca[A11_GROUP_NUM];

assign wclk_a[12]  = wclk_ca[A12_GROUP_NUM];
assign padt_a[12]  = padt_ca[A12_GROUP_NUM];

assign wclk_a[13]  = wclk_ca[A13_GROUP_NUM];
assign padt_a[13]  = padt_ca[A13_GROUP_NUM];

assign wclk_a[14]  = wclk_ca[A14_GROUP_NUM];
assign padt_a[14]  = padt_ca[A14_GROUP_NUM];

////wrdata  reorder                                                                                                                   
 always @(*) begin
      for (i=0; i<8; i=i+1)
         for (j=0; j<MEM_DQ_WIDTH; j=j+1)            
           phy_wrdata_reorder[j*8 + i] = phy_wrdata[i*MEM_DQ_WIDTH+j];
 end

// write_data_mask_reorder                                                                
 always @(*) begin
     for(i=0; i<8; i=i+1)
         for(j=0; j<MEM_DM_WIDTH; j=j+1)          
             phy_wrdata_mask_reorder[j*8 + i] = phy_wrdata_mask[i*MEM_DM_WIDTH+j];
 end
 
//rddata reorder
  always @(*) begin                                                        
       for (i=0; i<8; i=i+1)                                             
          for (j=0; j<MEM_DQ_WIDTH; j=j+1)                                 
            o_read_data[i*MEM_DQ_WIDTH + j] = dqs_align_data[j*8 + 7 - i];     
  end                                                                      

  assign read_valid = dqs_align_valid ;

//bank reoder
 always @(*) begin
    for(i=0; i<4; i=i+1)
       for(j=0;j<MEM_BANKADDR_WIDTH ; j=j+1)
           phy_ba_reorder[j*4+i] = phy_ba[i*MEM_BANKADDR_WIDTH + j] ;
 end
 
//addr reoder
 always @(*) begin
    for(i=0; i<4; i=i+1)
       for(j=0;j<MEM_ADDR_WIDTH;j=j+1)
          phy_addr_reorder[j*4+i] = phy_addr[i*MEM_ADDR_WIDTH+j];
 end                                                            

genvar gen_b;
generate
for(gen_b=0; gen_b<BANK_NUM; gen_b=gen_b+1) begin   : i_dqs_bank

GTP_CLKBUFR u_clkbufr
(
 .CLKOUT(ppll_clkin[gen_b]),
 .CLKIN (phy_refclk)
);

ips2l_ddrphy_ppll_v1_0 #(
.CLKIN_FREQ(CLKIN_FREQ     ),
.BANDWIDTH (PPLL_BANDWIDTH ),
.IDIV      (PPLL_IDIV      ),
.FDIV      (PPLL_FDIV      ),
.ODIVPHY   (PPLL_ODIVPHY   )   
)ddrphy_ppll(
.clk_in0         (ppll_clkin[gen_b]),
.pll_rst         (phy_pll_rst   ),
.clkoutphy_gate  (clkoutphy_gate),
.clkout0         (),
.clkout0n        (),
.clkoutphy       (phy_clk_p[gen_b]),
.clkoutphyn      (),
.pll_lock        (pll_lock_tmp[gen_b])
);

GTP_IOCLKDIV_E3 #(
 .DIV_FACTOR    ("8"),  
 .PHASE_SHIFT   ("2")   
)u_ddrphy_ioclkdiv(
 .RST         (ioclkdiv_rst),
 .CLKIN       (phy_clk_p[gen_b]),
 .CLKDIVOUT   (phy_sysclk_p[gen_b])
);
end
endgenerate

genvar gen_d;
generate
   for(gen_d=0; gen_d<MEM_DQS_WIDTH; gen_d=gen_d+1) begin   : i_dqs_group
   ips2l_ddrphy_data_slice_v1_0 #(
      .DDR_TYPE           (DDR_TYPE),
      .TEST_DATA_PATTERN0 (TEST_DATA_PATTERN0),      
      .TEST_DATA_PATTERN1 (TEST_DATA_PATTERN1),      
      .TEST_DATA_PATTERN2 (TEST_DATA_PATTERN2),      
      .TEST_DATA_PATTERN3 (TEST_DATA_PATTERN3),       
      .GATE_MODE          (GATE_MODE),
      .SC_LDO_CTRL        (SC_LDO_CTRL),
      .SC_DLY_2X          (SC_DLY_2X),
      .WL_MAX_STEP        (8'hff  ),
      .WL_MAX_CHECK       (5'h1f  ),
      .MIN_DQSI_WIN       (9'd10  )
   )ddrphy_data_slice( 
      .mc_rl                     (mc_rl                    ), 
      .force_read_clk_ctrl       (force_read_clk_ctrl      ),                               
      .init_read_clk_ctrl        (init_read_clk_ctrl[3*gen_d+2:3*gen_d] ),
      .init_slip_step            (init_slip_step[4*gen_d+3:4*gen_d]     ), 
      .force_samp_position       (force_samp_position      ),           
      .init_samp_position_even   (init_samp_position_even[8*gen_d+7:8*gen_d]),
      .init_samp_position_odd    (init_samp_position_odd[8*gen_d+7:8*gen_d] ),
      
      .ddrphy_sysclk             (ddrphy_sysclk            ),
      .ddrphy_rst_n              (ddrphy_rst_n             ),
      .phy_clk_p                 (phy_dq_clk_p[gen_d]      ), 
      .sysclk_p                  (phy_dq_sysclk_p[gen_d]   ),
      .ddrphy_dqs_rst            (ddrphy_dqs_rst           ),
      .ddrphy_dqs_training_rstn  (ddrphy_dqs_training_rstn ),
      .ddrphy_iol_rst            (ddrphy_iol_rst           ),
      
      .wrlvl_en                  (wrlvl_en),
      .init_wrlvl_step           (init_wrlvl_step[8*gen_d+7:8*gen_d]),     
      .wrlvl_dqs_req             (wrlvl_dqs_req            ),
      .wrlvl_dqs_resp            (wrlvl_dqs_resp_tmp[gen_d]    ),
      .wrlvl_error               (wrlvl_error_tmp[gen_d]       ), 
      
      .gatecal_start             (gatecal_start            ),
      .gate_check_pass           (gate_check_pass_tmp[gen_d]   ),
      .gate_adj_done             (gate_adj_done_tmp[gen_d]     ),
      .gate_cal_error            (gate_cal_error_tmp[gen_d]    ),
      .gate_move_en              (gate_move_en             ), 
      .rddata_cal                (rddata_cal               ), 
      .rddata_check_pass         (rddata_check_pass_tmp[gen_d] ),

      .wrcal_check_pass          (wrcal_check_pass_tmp[gen_d] ),
      .write_calibration         (write_calibration     ),
      .wrcal_move_en             (wrcal_move_en         ),
      .wrcal_move_done           (wrcal_move_done_tmp[gen_d]  ),

      .eye_calibration           (eye_calibration      ),
      .eyecal_check_pass         (eyecal_check_pass_tmp[gen_d]    ),
      .eyecal_move_done          (eyecal_move_done_tmp[gen_d]     ),
      .eyecal_move_en            (eyecal_move_en       ),
      
      .read_cmd                  (read_cmd                 ),  
      
      .comp_val                  (comp_val[2*gen_d+1:2*gen_d]),
      .comp_dir                  (comp_dir[gen_d]            ),
      .dqs_drift                 (dqs_drift[2*gen_d+1:2*gen_d]),
      .dqs_gate_comp_en          (dqs_gate_comp_en           ),
      .dqs_gate_comp_done        (dqs_gate_comp_done_tmp[gen_d]  ),
      
      .dll_lock                  (dll_lock_tmp[gen_d]),
      .dll_rstn                  (dll_rstn           ),
      .dll_freeze                (dll_freeze         ),
      .dll_update_n              (dll_update_n       ),
      
      .init_adj_rdel             (init_adj_rdel              ),
      .adj_rdel_done             (adj_rdel_done_tmp[gen_d]       ),  
      .rdel_calibration          (rdel_calibration           ),
      .rdel_calib_done           (rdel_calib_done_tmp[gen_d]     ),
      .rdel_calib_error          (rdel_calib_error_tmp[gen_d]    ),
      .rdel_move_en              (rdel_move_en               ),
      .rdel_move_done            (rdel_move_done_tmp[gen_d]      ),
      .bitslip_ctrl              (bitslip_ctrl                   ),
      
      .read_valid                (dqs_read_valid[gen_d]               ),
      .read_data                 (dqs_read_data[64*gen_d+63:64*gen_d] ),
      
      .phy_wrdata_en             (phy_wrdata_en            ), 
      .phy_wrdata_mask           (phy_wrdata_mask_reorder[8*gen_d+7 : 8*gen_d]), 
      .phy_wrdata                (phy_wrdata_reorder[64*gen_d+63:64*gen_d]    ),
      .dqs                       (mem_dqs[gen_d]                      ),
      .dqs_n                     (mem_dqs_n[gen_d]                    ),
      .dq                        (mem_dq[8*gen_d+7 : 8*gen_d]         ), 
      .dm                        (mem_dm[gen_d]                       ),
      .debug_data                (debug_data[66*gen_d+65:66*gen_d]    )
  ); 
  end     
endgenerate

   ips2l_ddrphy_slice_rddata_align_v1_0 #(
    .MEM_DQ_WIDTH       (MEM_DQ_WIDTH ),
    .MEM_DQS_WIDTH      (MEM_DQS_WIDTH)
   )ddrphy_slice_rddata_align(
    .ddrphy_sysclk     (ddrphy_sysclk   ),
    .ddrphy_rst_n      (ddrphy_rst_n    ),

    .dqs_read_valid    (dqs_read_valid  ),
    .dqs_read_data     (dqs_read_data   ),

    .dqs_align_valid   (dqs_align_valid ),
    .dqs_align_data    (dqs_align_data  ),
    .align_error       (align_error     )
    ); 
  
  ips2l_ddrphy_control_path_adj_v1_0 #(
    .DDR_TYPE            (DDR_TYPE          ),
    .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH    ),
    .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH),
    .SLIP_BIT_NUM        (1                 )     
  )ddrphy_control_path_adj(
    .ddrphy_sysclk (ddrphy_sysclk),
    .ddrphy_rst_n  (ddrphy_rst_n ),

    .phy_cke       (phy_cke         ),
    .phy_cs_n      (phy_cs_n        ),
    .phy_ras_n     (phy_ras_n       ),
    .phy_cas_n     (phy_cas_n       ),
    .phy_we_n      (phy_we_n        ),
    .phy_addr      (phy_addr_reorder),
    .phy_ba        (phy_ba_reorder  ),
    .phy_odt       (phy_odt         ),
    .phy_ck        (phy_ck          ),
    .adj_cke       (adj_cke         ),
    .adj_cs_n      (adj_cs_n        ),
    .adj_ras_n     (adj_ras_n       ),
    .adj_cas_n     (adj_cas_n       ),
    .adj_we_n      (adj_we_n        ),
    .adj_addr      (adj_addr        ),
    .adj_ba        (adj_ba          ),
    .adj_odt       (adj_odt         ),
    .adj_ck        (adj_ck          )
  );   

genvar gen_ca;
generate
   for(gen_ca=0; gen_ca<MEM_CA_GROUP; gen_ca=gen_ca+1) begin   : i_ca_group
GTP_DDC_E2 #(
 .CLKA_GATE_EN     ("TRUE"),         
 .WCLK_DELAY_SEL   ("FALSE"),        
 .DDC_MODE         ("QUAD_RATE"),    
 .R_EXTEND         ("FALSE"),        
 .DELAY_SEL        (SC_DLY_2X),      
 .GRS_EN           ("TRUE"),         
 .IFIFO_GENERIC    ("FALSE"),        
 .RADDR_INIT       (3'b000),         
 .DATA_RATE        (SC_LDO_CTRL)     
)u_ddc_ca(
    //output
  .WCLK                (wclk_ca[gen_ca]),
  .WCLK_DELAY          (wclk_del_ca[gen_ca]),
  .DQSI_DELAY          (),
  .DQSIB_DELAY         (),
  .DGTS                (),
  .IFIFO_WADDR         (),
  .IFIFO_RADDR         (),
  .READ_VALID          (),
  .DQS_DRIFT           (),
  .DRIFT_DETECT_ERR    (),
  .DQS_DRIFT_STATUS    (),
  .DQS_SAMPLE          (),
  .RST                 (ddrphy_dqs_rst),
  .RST_TRAINING_N      (ddrphy_dqs_training_rstn),
  .CLKA                (phy_ca_clk_p),
  .CLKB                (phy_ca_sysclk_p),
  .DQSI                (),
  .DQSIB               (),
  .DELAY_STEP0         (8'd0),
  .DELAY_STEP1         (8'd0),
  .DELAY_STEP2         (8'd0),
  .DELAY_STEP3         (8'd0),
  .DELAY_STEP4         (8'd0),
  .DQS_GATE_CTRL       (4'd0),
  .GATE_SEL            (1'b0),
  .CLK_GATE_CTRL       (2'd0),
  .CLKA_GATE           (1'b0)
 );

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),               
   .OSERDES_MODE     ("HMSDR8TO1"),
   .TSERDES_EN       ("TRUE"),          
   .UPD0_SHIFT_EN    ("FALSE"),                 
   .UPD1_SHIFT_EN    ("FALSE"),                 
   .INIT_SET         (2'b00),                
   .GRS_TYPE_DQ      ("RESET"),              
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),        
   .GRS_TYPE_TQ      ("RESET"),              
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),        
   .TRI_EN           ("TRUE"),              
   .TBYTE_EN         ("FALSE"),              
   .MIPI_EN          ("FALSE"),              
   .OCASCADE_EN      ("FALSE")               
)u_tserdes_ca0(
   .RST             (ddrphy_iol_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),                
   .SERCLK          (phy_ca_clk_p),
   .OCLK            (wclk_ca[gen_ca]),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (8'd0),
   .TI              (2'b00),
   .TBYTE_IN        (),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (),
   .DO              (padt_ca[gen_ca])
);

GTP_OSERDES_E2 #(                                       
   .GRS_EN           ("TRUE"),               
   .OSERDES_MODE     ("HMSDR8TO1"),
   .TSERDES_EN       ("TRUE"),          
   .UPD0_SHIFT_EN    ("FALSE"),                 
   .UPD1_SHIFT_EN    ("FALSE"),                 
   .INIT_SET         (2'b00),                
   .GRS_TYPE_DQ      ("RESET"),              
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),        
   .GRS_TYPE_TQ      ("RESET"),              
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),        
   .TRI_EN           ("TRUE"),              
   .TBYTE_EN         ("FALSE"),              
   .MIPI_EN          ("FALSE"),              
   .OCASCADE_EN      ("FALSE")               
)u_tserdes_ca1(
   .RST             (ddrphy_iol_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),               
   .SERCLK          (phy_ca_clk_p),
   .OCLK            (wclk_del_ca[gen_ca]),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (8'd0),
   .TI              (2'b00),
   .TBYTE_IN        (),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (),
   .DO              (padt_del_ca[gen_ca])
);
  end     
endgenerate


GTP_OSERDES_E2 #(                             
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),           
   .TSERDES_EN       ("FALSE"),
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_ck(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),            
   .SERCLK          (phy_ca_clk_p),
   .OCLK            (wclk_ck),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_ck),
   .TI              (),
   .TBYTE_IN        (padt_ck),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_ck),
   .DO              (pado_mem_ck)
);


 GTP_OUTBUFTCO u_outbuftco_ck
 (
 .O    (mem_ck),
 .OB   (mem_ck_n),
 .I    (pado_mem_ck),
 .T    (padt_mem_ck)
 );


GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),    
   .TSERDES_EN       ("FALSE"),       
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_odt(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),    
   .SERCLK          (phy_ca_clk_p),      
   .OCLK            (wclk_odt),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_odt),
   .TI              (),
   .TBYTE_IN        (padt_odt),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_odt),
   .DO              (pado_mem_odt)
);


GTP_OUTBUFT  u_outbuft_odt
(
    .O     (mem_odt),
    .I     (pado_mem_odt),
    .T     (padt_mem_odt)
);


GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),
   .TSERDES_EN       ("FALSE"),           
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_csn(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),      
   .SERCLK          (phy_ca_clk_p),      
   .OCLK            (wclk_cs_n),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_cs_n),
   .TI              (),
   .TBYTE_IN        (padt_cs_n),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_cs_n),
   .DO              (pado_mem_cs_n)
);


GTP_OUTBUFT  u_outbuft_csn
(
    .O     (mem_cs_n),
    .I     (pado_mem_cs_n),
    .T     (padt_mem_cs_n)
);


GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),  
   .TSERDES_EN       ("FALSE"),         
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_rasn(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),      
   .SERCLK          (phy_ca_clk_p),      
   .OCLK            (wclk_ras_n),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_ras_n),
   .TI              (),
   .TBYTE_IN        (padt_ras_n),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_ras_n),
   .DO              (pado_mem_ras_n)
);

GTP_OUTBUFT  u_outbuft_rasn
(
    .O     (mem_ras_n),
    .I     (pado_mem_ras_n),
    .T     (padt_mem_ras_n)
);


GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),
   .TSERDES_EN       ("FALSE"),           
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_casn(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p), 
   .SERCLK          (phy_ca_clk_p),     
   .OCLK            (wclk_cas_n),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_cas_n),
   .TI              (),
   .TBYTE_IN        (padt_cas_n),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_cas_n),
   .DO              (pado_mem_cas_n)
);


GTP_OUTBUFT  u_outbuft_casn
(
    .O     (mem_cas_n),
    .I     (pado_mem_cas_n),
    .T     (padt_mem_cas_n)
);

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"), 
   .TSERDES_EN       ("FALSE"),          
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_wen(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),  
   .SERCLK          (phy_ca_clk_p),      
   .OCLK            (wclk_we_n),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_we_n),
   .TI              (),
   .TBYTE_IN        (padt_we_n),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_we_n),
   .DO              (pado_mem_we_n)
);


GTP_OUTBUFT  u_outbuft_wen
(
    .O     (mem_we_n),
    .I     (pado_mem_we_n),
    .T     (padt_mem_we_n)
);


GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),   
   .TSERDES_EN       ("FALSE"),        
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_cke(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),     
   .SERCLK          (phy_ca_clk_p),      
   .OCLK            (wclk_cke),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_cke),
   .TI              (),
   .TBYTE_IN        (padt_cke),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_cke),
   .DO              (pado_mem_cke)
);

GTP_OUTBUFT  u_outbuft_cke
(
    .O     (mem_cke),
    .I     (pado_mem_cke),
    .T     (padt_mem_cke)
);

assign mem_rst_n = phy_rst;

//address
genvar gen_i;
generate
   for(gen_i=0; gen_i<MEM_ADDR_WIDTH; gen_i=gen_i+1) begin   : i_mem_addr_0   

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),
   .TSERDES_EN       ("FALSE"),           
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_addr(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),            
   .SERCLK          (phy_ca_clk_p),      
   .OCLK            (wclk_a[gen_i]),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_addr[gen_i*8+7:gen_i*8]),
   .TI              (),
   .TBYTE_IN        (padt_a[gen_i]),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_a[gen_i]),
   .DO              (pado_mem_a[gen_i])
);


 GTP_OUTBUFT  u_outbuft_addr0
 (
     .O     (mem_a[gen_i]),
     .I     (pado_mem_a[gen_i]),
     .T     (padt_mem_a[gen_i])
 );
   end
endgenerate

genvar gen_k;
generate
    for(gen_k=0; gen_k<MEM_BANKADDR_WIDTH; gen_k=gen_k+1) begin : k_mem_ba

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"), 
   .TSERDES_EN       ("FALSE"),          
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_ba(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (phy_ca_sysclk_p),                          
   .SERCLK          (phy_ca_clk_p),      
   .OCLK            (wclk_ba[gen_k]),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_ba[gen_k*8+7:gen_k*8]),
   .TI              (),
   .TBYTE_IN        (padt_ba[gen_k]),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padt_mem_ba[gen_k]),
   .DO              (pado_mem_ba[gen_k])
);


GTP_OUTBUFT  u_outbuft_ba
(
    .O     (mem_ba[gen_k]),
    .I     (pado_mem_ba[gen_k]),
    .T     (padt_mem_ba[gen_k])
);
    end
endgenerate

endmodule   





////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_wrcal_v1_0 #(
  parameter       WRCAL_EN         = 1    ,
  parameter [7:0]   TRFC           = 8'd16,
  parameter [7:0]   TRCD           = 8'd2 ,
  parameter TEST_DATA_PATTERN0     = 64'h55_aa_55_aa_08_f7_08_f7,
  parameter TEST_DATA_PATTERN1     = 64'h7f_9f_7f_9f_80_fe_80_fe,
  parameter TEST_DATA_PATTERN2     = 64'hf0_0f_f0_0f_01_ff_01_ff,
  parameter TEST_DATA_PATTERN3     = 64'hdf_aa_df_aa_55_aa_55_aa,
  parameter MEM_ADDR_WIDTH         = 16,
  parameter MEM_BANKADDR_WIDTH     = 3 ,
  parameter MEM_DQ_WIDTH           = 16
)(
   input [4:0]    mc_wl              ,
   input          ddrphy_sysclk      ,
   input          ddrphy_rst_n       ,
   input          wrcal_start        ,
   output reg     wrcal_done         ,
   
   input          wrcal_check_pass   ,
   output reg     write_calibration  ,
   output reg     wrcal_move_en      ,
   input          wrcal_move_done    ,
   
   output reg [MEM_BANKADDR_WIDTH-1:0]  wrcal_ba          ,
   output reg [MEM_ADDR_WIDTH-1:0]      wrcal_address     ,
   output reg wrcal_cs_n        ,
   output reg wrcal_ras_n       ,
   output reg wrcal_cas_n       ,
   output reg wrcal_we_n        ,
   output reg wrcal_cke         ,
   output reg wrcal_odt         ,
   output reg [MEM_DQ_WIDTH*8-1:0] wrcal_wrdata,
   output reg [3:0]  wrcal_wrdata_en,
   output [3:0]   dbg_wrcal         
);

  localparam WRCAL_IDLE             = 0;  
  localparam WRCAL_REFRESH          = 1;
  localparam WRCAL_REF_WAIT         = 2;
  localparam WRCAL_ACT              = 3;
  localparam WRCAL_WR               = 4;
  localparam WRCAL_WR_WAIT          = 5;
  localparam WRCAL_RD               = 6;
  localparam WRCAL_RD_WAIT          = 7;
  localparam WRCAL_RD_CHECK         = 8;
  localparam WRCAL_PRE              = 9;
  localparam WRCAL_DONE             = 10;  

  localparam DFI_DQ_WIDTH = MEM_DQ_WIDTH * 8;

  reg [17:0]    cnt;
  reg [3:0]     wrcal_state;
  reg           cnt_trfc_pass;
  reg           ref_cnt_done;
  reg [1:0]     ref_cnt;
  reg [2:0]     wr_cnt;
  reg [2:0]     wr_cnt_d;
  reg           wr_enable;
  reg           wr_enable_d;
  wire [3:0]    bus_wr_enable   ;
  wire [3:0]    bus_wr_enable_d ;
  wire [DFI_DQ_WIDTH-1:0]    bus_wr_data    ;
  wire [DFI_DQ_WIDTH-1:0]    bus_wr_data_d  ;
  wire [63:0]   group0_data;
  wire [63:0]   group1_data;
  wire [63:0]   group2_data;
  wire [63:0]   group3_data;
  wire [MEM_DQ_WIDTH*8-1:0] pattern0;
  wire [MEM_DQ_WIDTH*8-1:0] pattern1;
  wire [MEM_DQ_WIDTH*8-1:0] pattern2;
  wire [MEM_DQ_WIDTH*8-1:0] pattern3;

//refresh
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
          cnt_trfc_pass  <= 1'b0;
     else
         cnt_trfc_pass   <= (TRFC == cnt[7:0]);
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)  begin
          ref_cnt_done  <= 1'b0;
          ref_cnt       <= 2'b0;
     end
     else if(wrcal_state == WRCAL_REFRESH) begin
         ref_cnt       <= ref_cnt + 2'b1;
         ref_cnt_done  <= (&ref_cnt);                   //refresh 4
     end
  end
  
    
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if (!ddrphy_rst_n) begin
         wrcal_state        <= WRCAL_IDLE;
         cnt                <= 0;
      end
      else begin
         case (wrcal_state)
            WRCAL_IDLE: begin
                           cnt <= 0;
                           if (wrcal_start)
                           wrcal_state <= WRCAL_REFRESH;
                         end

          WRCAL_REFRESH: begin                                   //refresh
                                cnt         <= 0;
                                wrcal_state <= WRCAL_REF_WAIT;
                         end

         WRCAL_REF_WAIT: begin
                              if(cnt_trfc_pass) begin            //delay trfc
                                 if(ref_cnt_done)  begin         //refresh 4
                                     wrcal_state   <= WRCAL_ACT ;
                                       cnt         <= 0;
                                 end
                                 else
                                     wrcal_state   <= WRCAL_REFRESH;
                              end
                              else
                                      cnt          <= cnt + 1'b1;
                            end
                            
               WRCAL_ACT : begin                                 //active bank 0 row 0
                              if(cnt == TRCD) begin
                                   wrcal_state   <= WRCAL_WR;
                                   cnt           <= 'b0;
                               end
                               else
                                   cnt           <= cnt + 1'b1;
                            end

                WRCAL_WR : begin                                //write row 0 burst 4
                               if(cnt[3]) begin
                                      cnt      <=   'b0;
                                      wrcal_state   <=  WRCAL_WR_WAIT;
                               end
                               else
                                    cnt           <= cnt + 1'b1;
                           end  
                     
            WRCAL_WR_WAIT : begin
                              if(cnt[2]) begin
                                cnt <= 'b0;
                                if(WRCAL_EN == 1)
                                wrcal_state <= WRCAL_RD;
                                else
                                wrcal_state <= WRCAL_PRE;
                              end
                              else
                                cnt       <= cnt + 1'b1;
                            end                         
                           
                 WRCAL_RD : begin
                              if(cnt[2]) begin
                                cnt <= 'b0;
                                wrcal_state <= WRCAL_RD_WAIT;
                              end
                              else
                                cnt  <= cnt + 1'b1;
                            end
                            
             WRCAL_RD_WAIT : begin
                               if(cnt[4]) begin
                                 cnt <= 'b0;
                                 wrcal_state <= WRCAL_RD_CHECK;
                               end
                               else
                                 cnt  <= cnt + 1'b1;
                             end
                             
              WRCAL_RD_CHECK : begin
                                 if(wrcal_check_pass) begin
                                    wrcal_state <= WRCAL_PRE;
                                    cnt <= 'b0;
                                 end
                                 else if(wrcal_move_done) begin
                                    wrcal_state <= WRCAL_WR;
                                    cnt <= 'b0;
                                 end
                                 else if (~cnt[4]) 
                                   cnt <= cnt + 1;
                               end
                               
                   WRCAL_PRE : begin
                                 if(cnt[4]) begin
                                   cnt <= 'b0;
                                   wrcal_state <= WRCAL_DONE;
                                   end
                                else
                                   cnt  <= cnt + 1'b1;
                               end                 
                               
                  WRCAL_DONE : begin
                                 cnt  <=  cnt + 1'b1;
                                 if(cnt[3]) begin
                                    wrcal_state <= WRCAL_IDLE;
                                    cnt         <= 'h0;
                                 end
                               end
                               
                       default:  wrcal_state <= WRCAL_IDLE;
                       
                    endcase
      end
  end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
   if (!ddrphy_rst_n)
       wrcal_done   <=  1'b0;
   else if(wrcal_state == WRCAL_DONE)
   begin
       if(cnt[2:0]==3'b111)
       wrcal_done   <=  1'b1;    
   end
   else
       wrcal_done   <=  1'b0;
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if (!ddrphy_rst_n) begin
       write_calibration  <= 1'b0;
       wrcal_move_en      <= 1'b0;
    end
    else begin
       write_calibration <= (wrcal_state != WRCAL_IDLE);
       wrcal_move_en     <= (wrcal_state == WRCAL_RD_CHECK) && cnt[4];
    end
 end


  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n) begin
        wrcal_cs_n       <= 1'b1;
        wrcal_ras_n      <= 1'b0;
        wrcal_cas_n      <= 1'b0;
        wrcal_we_n       <= 1'b0;
        wrcal_ba         <= {MEM_BANKADDR_WIDTH{1'b0}};
        wrcal_address    <= {MEM_ADDR_WIDTH{1'b0}};
     end
     else  begin
        wrcal_cs_n       <= 1'b1;
        wrcal_ras_n      <= 1'b1;
        wrcal_cas_n      <= 1'b1;
        wrcal_we_n       <= 1'b1;
        wrcal_ba         <= {MEM_BANKADDR_WIDTH{1'b0}};
        wrcal_address    <= {MEM_ADDR_WIDTH{1'b0}};
        case(wrcal_state)
           WRCAL_REFRESH : begin //ref
                             wrcal_cs_n       <= 1'b0;
                             wrcal_ras_n      <= 1'b0;
                             wrcal_cas_n      <= 1'b0;
                             wrcal_we_n       <= 1'b1;
                           end

             WRCAL_ACT : begin //act
                           if(~|cnt)begin     //cnt = 0
                             wrcal_cs_n       <= 1'b0;
                             wrcal_ras_n      <= 1'b0;
                             wrcal_cas_n      <= 1'b1;
                             wrcal_we_n       <= 1'b1;
                           end
                         end

             WRCAL_WR : begin   //wr
                          if(cnt[4:0] < 5'd4) begin
                               wrcal_cs_n            <= 1'b0;
                               wrcal_ras_n           <= 1'b1;
                               wrcal_cas_n           <= 1'b0;
                               wrcal_we_n            <= 1'b0;
                               wrcal_address         <= {{(MEM_ADDR_WIDTH-5){1'b0}},cnt[1:0],3'b000};
                            end
                        end
                        
              WRCAL_RD : begin
                          if(cnt[4:0] < 5'd4) begin
                               wrcal_cs_n            <= 1'b0;
                               wrcal_ras_n           <= 1'b1;
                               wrcal_cas_n           <= 1'b0;
                               wrcal_we_n            <= 1'b1;
                               wrcal_address         <= {{(MEM_ADDR_WIDTH-5){1'b0}},cnt[1:0],3'b000};
                           end
                         end
                                                                     
              WRCAL_PRE: begin                                                   
                            if(cnt== 18'd4) begin                     
                                wrcal_cs_n          <= 1'b0 ;           
                                wrcal_ras_n         <= 1'b0 ;           
                                wrcal_cas_n         <= 1'b1 ;           
                                wrcal_we_n          <= 1'b0 ;         
                                wrcal_address       <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0};           
                             end                                        
                         end 
                              
//              WRCAL_DONE: begin
//                           if(~|cnt)begin
//                              wrcal_cs_n          <= 1'b0; 
//                              wrcal_ras_n         <= 1'b0; 
//                              wrcal_cas_n         <= 1'b1; 
//                              wrcal_we_n          <= 1'b0; 
//                              wrcal_address       <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0}; 
//                           end
//                         end
                            
          endcase
     end
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
        wrcal_odt   <= 1'b0;
     else if(wrcal_state == WRCAL_WR)
        wrcal_odt   <= 1'b1;
     else
        wrcal_odt   <= 1'b0;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
        wrcal_cke   <= 1'b0;
     else
        wrcal_cke   <= 1'b1;
  end

////--------------------DDR data write---------------------------------///
always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
   if (!ddrphy_rst_n) begin
   	  wr_enable  <= 1'b0;
   end
   else begin
   	  if (wrcal_state == WRCAL_WR) begin
   	     case (mc_wl[4:2])
            3'b000 : begin
                        if((cnt[4:0] == 5'd0)||(cnt[4:0] == 5'd1)||(cnt[4:0] == 5'd2)||(cnt[4:0] == 5'd3))
                           wr_enable  <= 1'b1;
                        else
                           wr_enable  <= 1'b0;
                      end
            3'b001 : begin
                       if((cnt[4:0] == 5'd1)||(cnt[4:0] == 5'd2)||(cnt[4:0] == 5'd3)||(cnt[4:0] == 5'd4))
   	                       wr_enable <= 1'b1;
   	                   else    	                        
                           wr_enable <= 1'b0;
                      end

            3'b010 : begin
                        if((cnt[4:0] == 5'd2)||(cnt[4:0] == 5'd3)||(cnt[4:0] == 5'd4)||(cnt[4:0] == 5'd5))
                           wr_enable   <= 1'b1;
                        else
                           wr_enable   <= 1'b0;
                      end

            3'b011 : begin
                        if((cnt[4:0] == 5'd3)||(cnt[4:0] == 5'd4)||(cnt[4:0] == 5'd5)||(cnt[4:0] == 5'd6))
                            wr_enable <= 1'b1;
                        else
                            wr_enable <= 1'b0;
                      end
                      
//            3'b100 : begin
//                       if((cnt[4:0] == 5'd4)||(cnt[4:0] == 5'd5)||(cnt[4:0] == 5'd6)||(cnt[4:0] == 5'd7))
//                            wr_enable <= 1'b1;
//                        else
//                            wr_enable <= 1'b0;
//                     end           
            default:
                    wr_enable <= 1'b0;
          endcase
       end
    else
         wr_enable <= 1'b0;
  end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if (!ddrphy_rst_n) begin
          wr_enable_d <= 1'b0;
          wr_cnt      <= 3'h0;
          wr_cnt_d    <= 3'h0;
     end
    else begin
         wr_enable_d <= wr_enable;
         wr_cnt_d    <= wr_cnt;
         if (wr_enable)
            wr_cnt  <= wr_cnt + 3'h1;
         else
            wr_cnt  <= 3'h0;
    end
 end

  assign bus_wr_enable   = {4{wr_enable}};
  assign bus_wr_enable_d = {4{wr_enable_d}};
  
  assign group0_data = {TEST_DATA_PATTERN0[56],TEST_DATA_PATTERN0[48],TEST_DATA_PATTERN0[40],TEST_DATA_PATTERN0[32],TEST_DATA_PATTERN0[24],TEST_DATA_PATTERN0[16],TEST_DATA_PATTERN0[8] ,TEST_DATA_PATTERN0[0],
                        TEST_DATA_PATTERN0[57],TEST_DATA_PATTERN0[49],TEST_DATA_PATTERN0[41],TEST_DATA_PATTERN0[33],TEST_DATA_PATTERN0[25],TEST_DATA_PATTERN0[17],TEST_DATA_PATTERN0[9] ,TEST_DATA_PATTERN0[1],
                        TEST_DATA_PATTERN0[58],TEST_DATA_PATTERN0[50],TEST_DATA_PATTERN0[42],TEST_DATA_PATTERN0[34],TEST_DATA_PATTERN0[26],TEST_DATA_PATTERN0[18],TEST_DATA_PATTERN0[10],TEST_DATA_PATTERN0[2],
                        TEST_DATA_PATTERN0[59],TEST_DATA_PATTERN0[51],TEST_DATA_PATTERN0[43],TEST_DATA_PATTERN0[35],TEST_DATA_PATTERN0[27],TEST_DATA_PATTERN0[19],TEST_DATA_PATTERN0[11],TEST_DATA_PATTERN0[3],
                        TEST_DATA_PATTERN0[60],TEST_DATA_PATTERN0[52],TEST_DATA_PATTERN0[44],TEST_DATA_PATTERN0[36],TEST_DATA_PATTERN0[28],TEST_DATA_PATTERN0[20],TEST_DATA_PATTERN0[12],TEST_DATA_PATTERN0[4],
                        TEST_DATA_PATTERN0[61],TEST_DATA_PATTERN0[53],TEST_DATA_PATTERN0[45],TEST_DATA_PATTERN0[37],TEST_DATA_PATTERN0[29],TEST_DATA_PATTERN0[21],TEST_DATA_PATTERN0[13],TEST_DATA_PATTERN0[5],
                        TEST_DATA_PATTERN0[62],TEST_DATA_PATTERN0[54],TEST_DATA_PATTERN0[46],TEST_DATA_PATTERN0[38],TEST_DATA_PATTERN0[30],TEST_DATA_PATTERN0[22],TEST_DATA_PATTERN0[14],TEST_DATA_PATTERN0[6],
                        TEST_DATA_PATTERN0[63],TEST_DATA_PATTERN0[55],TEST_DATA_PATTERN0[47],TEST_DATA_PATTERN0[39],TEST_DATA_PATTERN0[31],TEST_DATA_PATTERN0[23],TEST_DATA_PATTERN0[15],TEST_DATA_PATTERN0[7]};

  assign group1_data = {TEST_DATA_PATTERN1[56],TEST_DATA_PATTERN1[48],TEST_DATA_PATTERN1[40],TEST_DATA_PATTERN1[32],TEST_DATA_PATTERN1[24],TEST_DATA_PATTERN1[16],TEST_DATA_PATTERN1[8] ,TEST_DATA_PATTERN1[0],
                        TEST_DATA_PATTERN1[57],TEST_DATA_PATTERN1[49],TEST_DATA_PATTERN1[41],TEST_DATA_PATTERN1[33],TEST_DATA_PATTERN1[25],TEST_DATA_PATTERN1[17],TEST_DATA_PATTERN1[9] ,TEST_DATA_PATTERN1[1],
                        TEST_DATA_PATTERN1[58],TEST_DATA_PATTERN1[50],TEST_DATA_PATTERN1[42],TEST_DATA_PATTERN1[34],TEST_DATA_PATTERN1[26],TEST_DATA_PATTERN1[18],TEST_DATA_PATTERN1[10],TEST_DATA_PATTERN1[2],
                        TEST_DATA_PATTERN1[59],TEST_DATA_PATTERN1[51],TEST_DATA_PATTERN1[43],TEST_DATA_PATTERN1[35],TEST_DATA_PATTERN1[27],TEST_DATA_PATTERN1[19],TEST_DATA_PATTERN1[11],TEST_DATA_PATTERN1[3],
                        TEST_DATA_PATTERN1[60],TEST_DATA_PATTERN1[52],TEST_DATA_PATTERN1[44],TEST_DATA_PATTERN1[36],TEST_DATA_PATTERN1[28],TEST_DATA_PATTERN1[20],TEST_DATA_PATTERN1[12],TEST_DATA_PATTERN1[4],
                        TEST_DATA_PATTERN1[61],TEST_DATA_PATTERN1[53],TEST_DATA_PATTERN1[45],TEST_DATA_PATTERN1[37],TEST_DATA_PATTERN1[29],TEST_DATA_PATTERN1[21],TEST_DATA_PATTERN1[13],TEST_DATA_PATTERN1[5],
                        TEST_DATA_PATTERN1[62],TEST_DATA_PATTERN1[54],TEST_DATA_PATTERN1[46],TEST_DATA_PATTERN1[38],TEST_DATA_PATTERN1[30],TEST_DATA_PATTERN1[22],TEST_DATA_PATTERN1[14],TEST_DATA_PATTERN1[6],
                        TEST_DATA_PATTERN1[63],TEST_DATA_PATTERN1[55],TEST_DATA_PATTERN1[47],TEST_DATA_PATTERN1[39],TEST_DATA_PATTERN1[31],TEST_DATA_PATTERN1[23],TEST_DATA_PATTERN1[15],TEST_DATA_PATTERN1[7]};

  assign group2_data = {TEST_DATA_PATTERN2[56],TEST_DATA_PATTERN2[48],TEST_DATA_PATTERN2[40],TEST_DATA_PATTERN2[32],TEST_DATA_PATTERN2[24],TEST_DATA_PATTERN2[16],TEST_DATA_PATTERN2[8] ,TEST_DATA_PATTERN2[0],
                        TEST_DATA_PATTERN2[57],TEST_DATA_PATTERN2[49],TEST_DATA_PATTERN2[41],TEST_DATA_PATTERN2[33],TEST_DATA_PATTERN2[25],TEST_DATA_PATTERN2[17],TEST_DATA_PATTERN2[9] ,TEST_DATA_PATTERN2[1],
                        TEST_DATA_PATTERN2[58],TEST_DATA_PATTERN2[50],TEST_DATA_PATTERN2[42],TEST_DATA_PATTERN2[34],TEST_DATA_PATTERN2[26],TEST_DATA_PATTERN2[18],TEST_DATA_PATTERN2[10],TEST_DATA_PATTERN2[2],
                        TEST_DATA_PATTERN2[59],TEST_DATA_PATTERN2[51],TEST_DATA_PATTERN2[43],TEST_DATA_PATTERN2[35],TEST_DATA_PATTERN2[27],TEST_DATA_PATTERN2[19],TEST_DATA_PATTERN2[11],TEST_DATA_PATTERN2[3],
                        TEST_DATA_PATTERN2[60],TEST_DATA_PATTERN2[52],TEST_DATA_PATTERN2[44],TEST_DATA_PATTERN2[36],TEST_DATA_PATTERN2[28],TEST_DATA_PATTERN2[20],TEST_DATA_PATTERN2[12],TEST_DATA_PATTERN2[4],
                        TEST_DATA_PATTERN2[61],TEST_DATA_PATTERN2[53],TEST_DATA_PATTERN2[45],TEST_DATA_PATTERN2[37],TEST_DATA_PATTERN2[29],TEST_DATA_PATTERN2[21],TEST_DATA_PATTERN2[13],TEST_DATA_PATTERN2[5],
                        TEST_DATA_PATTERN2[62],TEST_DATA_PATTERN2[54],TEST_DATA_PATTERN2[46],TEST_DATA_PATTERN2[38],TEST_DATA_PATTERN2[30],TEST_DATA_PATTERN2[22],TEST_DATA_PATTERN2[14],TEST_DATA_PATTERN2[6],
                        TEST_DATA_PATTERN2[63],TEST_DATA_PATTERN2[55],TEST_DATA_PATTERN2[47],TEST_DATA_PATTERN2[39],TEST_DATA_PATTERN2[31],TEST_DATA_PATTERN2[23],TEST_DATA_PATTERN2[15],TEST_DATA_PATTERN2[7]};  

  assign group3_data = {TEST_DATA_PATTERN3[56],TEST_DATA_PATTERN3[48],TEST_DATA_PATTERN3[40],TEST_DATA_PATTERN3[32],TEST_DATA_PATTERN3[24],TEST_DATA_PATTERN3[16],TEST_DATA_PATTERN3[8] ,TEST_DATA_PATTERN3[0],
                        TEST_DATA_PATTERN3[57],TEST_DATA_PATTERN3[49],TEST_DATA_PATTERN3[41],TEST_DATA_PATTERN3[33],TEST_DATA_PATTERN3[25],TEST_DATA_PATTERN3[17],TEST_DATA_PATTERN3[9] ,TEST_DATA_PATTERN3[1],
                        TEST_DATA_PATTERN3[58],TEST_DATA_PATTERN3[50],TEST_DATA_PATTERN3[42],TEST_DATA_PATTERN3[34],TEST_DATA_PATTERN3[26],TEST_DATA_PATTERN3[18],TEST_DATA_PATTERN3[10],TEST_DATA_PATTERN3[2],
                        TEST_DATA_PATTERN3[59],TEST_DATA_PATTERN3[51],TEST_DATA_PATTERN3[43],TEST_DATA_PATTERN3[35],TEST_DATA_PATTERN3[27],TEST_DATA_PATTERN3[19],TEST_DATA_PATTERN3[11],TEST_DATA_PATTERN3[3],
                        TEST_DATA_PATTERN3[60],TEST_DATA_PATTERN3[52],TEST_DATA_PATTERN3[44],TEST_DATA_PATTERN3[36],TEST_DATA_PATTERN3[28],TEST_DATA_PATTERN3[20],TEST_DATA_PATTERN3[12],TEST_DATA_PATTERN3[4],
                        TEST_DATA_PATTERN3[61],TEST_DATA_PATTERN3[53],TEST_DATA_PATTERN3[45],TEST_DATA_PATTERN3[37],TEST_DATA_PATTERN3[29],TEST_DATA_PATTERN3[21],TEST_DATA_PATTERN3[13],TEST_DATA_PATTERN3[5],
                        TEST_DATA_PATTERN3[62],TEST_DATA_PATTERN3[54],TEST_DATA_PATTERN3[46],TEST_DATA_PATTERN3[38],TEST_DATA_PATTERN3[30],TEST_DATA_PATTERN3[22],TEST_DATA_PATTERN3[14],TEST_DATA_PATTERN3[6],
                        TEST_DATA_PATTERN3[63],TEST_DATA_PATTERN3[55],TEST_DATA_PATTERN3[47],TEST_DATA_PATTERN3[39],TEST_DATA_PATTERN3[31],TEST_DATA_PATTERN3[23],TEST_DATA_PATTERN3[15],TEST_DATA_PATTERN3[7]};
                          
  assign pattern0 = {{DFI_DQ_WIDTH/64{group0_data[63:56]}},{DFI_DQ_WIDTH/64{group0_data[55:48]}},{DFI_DQ_WIDTH/64{group0_data[47:40]}},{DFI_DQ_WIDTH/64{group0_data[39:32]}},{DFI_DQ_WIDTH/64{group0_data[31:24]}},{DFI_DQ_WIDTH/64{group0_data[23:16]}},{DFI_DQ_WIDTH/64{group0_data[15:8]}},{DFI_DQ_WIDTH/64{group0_data[7:0]}}};
  assign pattern1 = {{DFI_DQ_WIDTH/64{group1_data[63:56]}},{DFI_DQ_WIDTH/64{group1_data[55:48]}},{DFI_DQ_WIDTH/64{group1_data[47:40]}},{DFI_DQ_WIDTH/64{group1_data[39:32]}},{DFI_DQ_WIDTH/64{group1_data[31:24]}},{DFI_DQ_WIDTH/64{group1_data[23:16]}},{DFI_DQ_WIDTH/64{group1_data[15:8]}},{DFI_DQ_WIDTH/64{group1_data[7:0]}}};
  assign pattern2 = {{DFI_DQ_WIDTH/64{group2_data[63:56]}},{DFI_DQ_WIDTH/64{group2_data[55:48]}},{DFI_DQ_WIDTH/64{group2_data[47:40]}},{DFI_DQ_WIDTH/64{group2_data[39:32]}},{DFI_DQ_WIDTH/64{group2_data[31:24]}},{DFI_DQ_WIDTH/64{group2_data[23:16]}},{DFI_DQ_WIDTH/64{group2_data[15:8]}},{DFI_DQ_WIDTH/64{group2_data[7:0]}}};
  assign pattern3 = {{DFI_DQ_WIDTH/64{group3_data[63:56]}},{DFI_DQ_WIDTH/64{group3_data[55:48]}},{DFI_DQ_WIDTH/64{group3_data[47:40]}},{DFI_DQ_WIDTH/64{group3_data[39:32]}},{DFI_DQ_WIDTH/64{group3_data[31:24]}},{DFI_DQ_WIDTH/64{group3_data[23:16]}},{DFI_DQ_WIDTH/64{group3_data[15:8]}},{DFI_DQ_WIDTH/64{group3_data[7:0]}}};
  
  assign bus_wr_data   = (wr_cnt == 3'd0) ?  pattern0 :
                         (wr_cnt == 3'd1) ?  pattern1 :
                         (wr_cnt == 3'd2) ?  pattern2 : pattern3 ;

  assign bus_wr_data_d = (wr_cnt_d == 3'd0) ?  pattern0 :
                         (wr_cnt_d == 3'd1) ?  pattern1 :
                         (wr_cnt_d == 3'd2) ?  pattern2 : pattern3 ;
                         
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) begin
        wrcal_wrdata_en  <= 4'b0000;
        wrcal_wrdata     <= {DFI_DQ_WIDTH{1'b0}};
     end
     else begin
        case (mc_wl[1:0])
            2'b00:begin
                wrcal_wrdata_en  <= bus_wr_enable;
                wrcal_wrdata     <= bus_wr_data;
            end
            2'b01:begin
                wrcal_wrdata_en  <= {bus_wr_enable[2:0], bus_wr_enable_d[3]};
                wrcal_wrdata     <= {bus_wr_data[DFI_DQ_WIDTH*3/4-1 : 0], bus_wr_data_d[DFI_DQ_WIDTH-1: DFI_DQ_WIDTH*3/4]};
            end
            2'b10:begin
                wrcal_wrdata_en <= {bus_wr_enable[1:0], bus_wr_enable_d[3:2]};
                wrcal_wrdata    <= {bus_wr_data[DFI_DQ_WIDTH*2/4-1 : 0], bus_wr_data_d[DFI_DQ_WIDTH-1: DFI_DQ_WIDTH*2/4]};
            end
            2'b11:begin
                wrcal_wrdata_en <= {bus_wr_enable[0],bus_wr_enable_d[3:1]};
                wrcal_wrdata    <= {bus_wr_data[DFI_DQ_WIDTH*1/4-1 : 0], bus_wr_data_d[DFI_DQ_WIDTH-1: DFI_DQ_WIDTH*1/4]};
            end
            default:begin
                wrcal_wrdata_en <= 4'b0000;
                wrcal_wrdata     <= {DFI_DQ_WIDTH{1'b0}};
            end
        endcase
     end
  end

assign dbg_wrcal = wrcal_state;
// assign  wrcal_wrdata_mask = {(8*MEM_DM_WIDTH){1'b0}};

endmodule




////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_wdata_path_adj_v1_0 #(
    parameter DQ_WIDTH     = 8  //4 or 8
)(                                                
    input                     ddrphy_sysclk    ,
    input                     ddrphy_rst_n    , 
                                              
    input [3:0]               phy_wrdata_en   ,
    input [7:0]               phy_wrdata_mask ,
    input [DQ_WIDTH*8-1:0]    phy_wrdata      ,
    input                     wrlvl_dqs_en    ,
    input                     wrlvl_dqs       ,
                                    
    output [7:0]              adj_wrdq_en     ,
    output [DQ_WIDTH*8-1:0]   adj_wrdq        ,
    output [7:0]              adj_wrdqs_en    ,
    output [7:0]              adj_wrdqs       ,
    output [7:0]              adj_wrdata_mask 
   );

  reg [3:0]            phy_wrdata_en_r     ;
  reg [7:0]            phy_wrdata_mask_r   ;
  reg [DQ_WIDTH*8-1:0] phy_wrdata_r        ;
  wire [7:0]           phy_wrdata_en_slip1 ; 
  wire [7:0]           phy_wrdata_en_slip2 ;
  wire [7:0]           w_adj_wrdq_en       ; 
  wire [7:0]           w_adj_wrdqs_en      ;

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)    
      if(~ddrphy_rst_n) begin                                                
          phy_wrdata_en_r    <= 4'b0  ;
          phy_wrdata_mask_r  <= 8'h0  ;
          phy_wrdata_r       <= {DQ_WIDTH*8{1'b0}};
      end                                                   
      else begin      
          phy_wrdata_en_r      <= phy_wrdata_en   ;  
          phy_wrdata_mask_r    <= phy_wrdata_mask ;  
          phy_wrdata_r         <= phy_wrdata      ;                                                
      end                                                   

// oe 1 bit == dq 2 bits
  assign phy_wrdata_en_slip1 = {phy_wrdata_en[3],phy_wrdata_en[2],phy_wrdata_en[2],phy_wrdata_en[1],phy_wrdata_en[1],phy_wrdata_en[0],phy_wrdata_en[0],phy_wrdata_en_r[3]};
  assign phy_wrdata_en_slip2 = {phy_wrdata_en[2],phy_wrdata_en[2],phy_wrdata_en[1],phy_wrdata_en[1],phy_wrdata_en[0],phy_wrdata_en[0],phy_wrdata_en_r[3],phy_wrdata_en_r[3]};

//xuhao
  wire [7:0] w_phy_wrdata_en;
//  wire [7:0] w_adj_wrdq_en_270 ; 
  wire [7:0] w_adj_wrdq_en_90 ; 
//  wire [7:0] w_adj_wrdqs_en_270;
  wire [7:0] w_adj_wrdqs_en_90;
//  wire [7:0] adj_wrdq_en_270 ;
  wire [7:0] adj_wrdq_en_90 ;
// wire [7:0] adj_wrdqs_en_270;
  wire [7:0] adj_wrdqs_en_90;
//  wire [7:0] adj_wrdata_mask_270;
  wire [7:0] adj_wrdata_mask_90;
//  wire [DQ_WIDTH*8-1:0] adj_wrdq_270;
  wire [DQ_WIDTH*8-1:0] adj_wrdq_90;
//  wire [7:0]  adj_wrdqs_270;  
  wire [7:0]  adj_wrdqs_90;


  assign w_phy_wrdata_en = {phy_wrdata_en[3],phy_wrdata_en[3],phy_wrdata_en[2],phy_wrdata_en[2],phy_wrdata_en[1],phy_wrdata_en[1],phy_wrdata_en[0],phy_wrdata_en[0]};
//270wclk
//dq
//  //oe
//  assign w_adj_wrdq_en_270   = w_phy_wrdata_en;
//  assign adj_wrdq_en_270     = ~w_adj_wrdq_en_270;
//  //data
//  assign adj_wrdq_270        = phy_wrdata;                           
//  assign adj_wrdata_mask_270 = phy_wrdata_mask;
//
////dqs
//  //oe
//  assign w_adj_wrdqs_en_270 = wrlvl_dqs_en ? 8'b11111111 : (w_phy_wrdata_en | phy_wrdata_en_slip2);
//  assign adj_wrdqs_en_270 = ~w_adj_wrdqs_en_270;
//  //data
////  reg [3:0] wrdqs_tmp;    
//  assign adj_wrdqs_270 =  wrlvl_dqs_en ? {7'b0, wrlvl_dqs} : 8'b01010101;


//90wclk
//dq
  assign w_adj_wrdq_en_90   = phy_wrdata_en_slip1;
  assign adj_wrdq_en_90     = ~w_adj_wrdq_en_90;
  assign adj_wrdq_90        = dq_slip_1bit(phy_wrdata, phy_wrdata_r) ;                           
  assign adj_wrdata_mask_90 = dm_slip_1bit(phy_wrdata_mask, phy_wrdata_mask_r);
//dqs
  assign w_adj_wrdqs_en_90 = wrlvl_dqs_en ? 8'b11111111 : (w_phy_wrdata_en | phy_wrdata_en_slip2);
  assign adj_wrdqs_en_90 = ~w_adj_wrdqs_en_90;
 assign adj_wrdqs_90 =  wrlvl_dqs_en ? {7'b0, wrlvl_dqs} : 8'b01010101;  

// sel_wclk_del
//  assign adj_wrdq_en     =  WCLK_DEL_SEL ? adj_wrdq_en_90     : adj_wrdq_en_270    ;
//  assign adj_wrdq        =  WCLK_DEL_SEL ? adj_wrdq_90        : adj_wrdq_270       ;
//  assign adj_wrdata_mask =  WCLK_DEL_SEL ? adj_wrdata_mask_90 : adj_wrdata_mask_270;
//  assign adj_wrdqs_en    =  WCLK_DEL_SEL ? adj_wrdqs_en_90    : adj_wrdqs_en_270   ;
//  assign adj_wrdqs       =  WCLK_DEL_SEL ? adj_wrdqs_90       : adj_wrdqs_270      ;

  assign adj_wrdq_en     =  adj_wrdq_en_90     ;
  assign adj_wrdq        =  adj_wrdq_90        ;
  assign adj_wrdata_mask =  adj_wrdata_mask_90 ;
  assign adj_wrdqs_en    =  adj_wrdqs_en_90    ;
  assign adj_wrdqs       =  adj_wrdqs_90       ;

    function [DQ_WIDTH*8-1:0] dq_slip_1bit;
        input [DQ_WIDTH*8-1:0]    write_data;
        input [DQ_WIDTH*8-1:0]    write_data_d1;
        integer i,j;
        
        for(i=0; i<=DQ_WIDTH-1; i=i+1) begin
            dq_slip_1bit[i*8+0]=write_data_d1[i*8+7];    
            for(j=1;j<=7;j=j+1)
                dq_slip_1bit[i*8+j]=write_data[i*8+j-1];
        end
            
    endfunction
    
    function [DQ_WIDTH*8-1:0] dq_slip_3bit;
        input [DQ_WIDTH*8-1:0]    write_data;
        input [DQ_WIDTH*8-1:0]    write_data_d1;
        integer i,j;
        
        for(i=0; i<=DQ_WIDTH-1; i=i+1) begin
            dq_slip_3bit[i*8+0]=write_data_d1[i*8+5];    
            dq_slip_3bit[i*8+1]=write_data_d1[i*8+6];    
            dq_slip_3bit[i*8+2]=write_data_d1[i*8+7];    
            for(j=3;j<=7;j=j+1)
                dq_slip_3bit[i*8+j]=write_data[i*8+j-3];
        end
            
    endfunction

    function [7:0] dm_slip_1bit;
        input [7:0]    write_data_mask;
        input [7:0]    write_data_mask_d1;
        
        dm_slip_1bit = {write_data_mask[6:0], write_data_mask_d1[7]};
            
    endfunction
        
    function [7:0] dm_slip_3bit;
        input [7:0]    write_data_mask;
        input [7:0]    write_data_mask_d1;
        
        dm_slip_3bit = {write_data_mask[4:0], write_data_mask_d1[7:5]};
            
    endfunction
        

endmodule




////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_upcal_v1_0 #(
  parameter   MEM_DQS_WIDTH       = 2
)(                            
  input                            ddrphy_sysclk      ,
  input                            ddrphy_rst_n       ,
                                   
  input                            update_start       ,
  output reg                       update_done        ,
                                   
//  input                            dll_update_ack     ,
//  output reg                       dll_update_req     ,
 
  input [2*MEM_DQS_WIDTH-1:0]      update_comp_val    ,
  input [MEM_DQS_WIDTH-1:0]        update_comp_dir    ,
  output reg [2*MEM_DQS_WIDTH-1:0] comp_val           ,
  output reg [MEM_DQS_WIDTH-1:0]   comp_dir           ,
  output reg                       dqs_gate_comp_en   ,
  input                            dqs_gate_comp_done ,
  output [3:0]                     dbg_upcal  
);

localparam  UPCAL_IDLE           = 4'd0 ;
//localparam  UPCAL_DLL            = 4'd1 ;
localparam  UPCAL_READJ_DQS_STEP = 4'd1 ;
localparam  UPCAL_DONE           = 4'd2 ;

reg  [3:0]    upcal_state;
reg  [3:0]    upcal_state_next;
//reg  [1:0]    dll_update_ack_sync;  
reg  [7:0]    cnt;

//  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
//  begin
//     if(!ddrphy_rst_n)
//        dll_update_ack_sync  <= 2'b0 ;
//     else
//        dll_update_ack_sync  <= {dll_update_ack_sync[0],dll_update_ack};
//  end

// always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n) 
// begin
//     if(!ddrphy_rst_n)
//        dll_update_req     <=  1'b0 ;
//     else 
//        dll_update_req     <= (upcal_state_next == UPCAL_DLL);
// end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if(!ddrphy_rst_n)
         begin
           comp_val <= {MEM_DQS_WIDTH{2'b00}};
           comp_dir <= {MEM_DQS_WIDTH{1'b0}};
           dqs_gate_comp_en <= 1'b0;
         end      
    else if (upcal_state_next == UPCAL_READJ_DQS_STEP)
         begin
           comp_val <= update_comp_val;
           comp_dir <= update_comp_dir;
           dqs_gate_comp_en <= 1'b1;
         end
     else 
         begin
           comp_val <= {MEM_DQS_WIDTH{2'b00}};
           comp_dir <= {MEM_DQS_WIDTH{1'b0}};
           dqs_gate_comp_en <= 1'b0;
         end
end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
         upcal_state   <= UPCAL_IDLE;
     else 
         upcal_state   <= upcal_state_next;
  end

  always @(*)  
  begin
       upcal_state_next = UPCAL_IDLE;
       case (upcal_state)
               UPCAL_IDLE          : begin
                                        if(update_start)  begin
//                                           case(update_type)
//                                                2'b01: begin      
                                                           upcal_state_next = UPCAL_READJ_DQS_STEP ;
//                                                       end
//
//                                          2'b00,2'b11: begin
//                                                           upcal_state_next = UPCAL_DLL;
//                                                       end
//                                              default:   upcal_state_next = UPCAL_IDLE ;
//                                           endcase
                                        end
                                        else
                                               upcal_state_next = UPCAL_IDLE ;
                                     end

//               UPCAL_DLL           : begin
//                                       if(dll_update_ack_sync[1]) begin
//                                          case (update_type)
//                                                2'b00 :  upcal_state_next  = UPCAL_DONE ;
//                                                2'b11 :  upcal_state_next  = UPCAL_READJ_DQS_STEP;
//                                               default:  upcal_state_next  = UPCAL_DONE;
//                                          endcase
//                                       end
//                                       else
//                                           upcal_state_next  = UPCAL_DLL;
//                                     end                    

             UPCAL_READJ_DQS_STEP : begin
                                      // if(dqs_gate_adj_done)
                                       if (dqs_gate_comp_done)
                                          upcal_state_next  =  UPCAL_DONE ;
                                       else
                                          upcal_state_next  =  UPCAL_READJ_DQS_STEP ;
                                    end                                         

               UPCAL_DONE          : begin
                                        if(~|cnt)
                                           upcal_state_next = UPCAL_IDLE ;
                                        else
                                           upcal_state_next = UPCAL_DONE ;
                                     end
               default:
                       upcal_state_next = UPCAL_IDLE ;
            endcase
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
          cnt    <=  8'h0;
     else if(upcal_state_next == UPCAL_DONE)
     begin
          if(cnt[4])
             cnt   <= 8'h0 ;
          else
             cnt   <= cnt + 8'h1;
     end
     else
         cnt   <= 8'h0 ;
  end


 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n)
        update_done   <= 1'b0;
    else
        update_done    <= ((upcal_state_next == UPCAL_DONE)& cnt[4]) ;
 end

assign dbg_upcal = upcal_state_next;

endmodule
   




////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                   
// ALL RIGHTS REVERVED.                                         
////////////////////////////////////////////////////////////////
//Description:                                                  
//Author:  wxxiao                                               
//History: v1.0                                                 
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_training_ctrl_v1_0
(
    input                ddrphy_sysclk                  ,
    input                ddrphy_rst_n                   ,
    input                ddrphy_rst_req                 ,
    output               ddrphy_rst_ack                 ,
    output reg           ddrphy_dqs_training_rstn  
);

parameter SRB_DQS_RST_TRAINING_HIGH_CLK = 3;

reg ddrphy_rst_req_d1; 
reg ddrphy_rst_req_d2;
reg ddrphy_rst_req_d3;
reg ddrphy_dqs_training_rstn_d;
wire ddrphy_rst_req_p;

always @ (posedge ddrphy_sysclk) 
begin
    ddrphy_rst_req_d1 <= ddrphy_rst_req;
    ddrphy_rst_req_d2 <= ddrphy_rst_req_d1;
    ddrphy_rst_req_d3 <= ddrphy_rst_req_d2;
end

assign ddrphy_rst_req_p = ddrphy_rst_req_d2 & ~ddrphy_rst_req_d3;

reg [2:0] dqs_rst_training_high_cnt;

always @ (posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if (!ddrphy_rst_n)
        dqs_rst_training_high_cnt <= 3'h0;
    else if (ddrphy_rst_req_p)
        dqs_rst_training_high_cnt <= SRB_DQS_RST_TRAINING_HIGH_CLK;
    else if (|dqs_rst_training_high_cnt)
        dqs_rst_training_high_cnt <= dqs_rst_training_high_cnt - 3'h1;
    else
        dqs_rst_training_high_cnt <= dqs_rst_training_high_cnt;
end

//CLK_AND_RST_PLAN = 1, not to reset clk for default plan
always @ (posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if (!ddrphy_rst_n)
        ddrphy_dqs_training_rstn <= 1'b0;
    else if (|dqs_rst_training_high_cnt)
        ddrphy_dqs_training_rstn <= 1'b0;
    else
        ddrphy_dqs_training_rstn <= 1'b1;
end

always @ (posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if (!ddrphy_rst_n)
        ddrphy_dqs_training_rstn_d <= 1'b0;
    else
        ddrphy_dqs_training_rstn_d <= ddrphy_dqs_training_rstn;
end

assign ddrphy_rst_ack = ddrphy_dqs_training_rstn & (~ddrphy_dqs_training_rstn_d);

endmodule



////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                   
// ALL RIGHTS REVERVED.                                         
////////////////////////////////////////////////////////////////
//Description:                                                  
//Author:  wxxiao                                               
//History: v1.0                                                 
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module  ips2l_ddrphy_slice_rddata_align_v1_0 #(
  parameter MEM_DQ_WIDTH       = 16,
  parameter MEM_DQS_WIDTH      = 2
)(
  input                        ddrphy_sysclk    ,
  input                        ddrphy_rst_n     ,
                                   
  input [MEM_DQS_WIDTH-1:0]    dqs_read_valid   ,
  input [8*MEM_DQ_WIDTH-1:0]   dqs_read_data    ,

  output                       dqs_align_valid  ,
  output [8*MEM_DQ_WIDTH-1:0]  dqs_align_data   ,
  output reg                   align_error
  );                                      
      
  reg [8*MEM_DQ_WIDTH-1:0]  dqs_read_data_r   ;
  reg [MEM_DQS_WIDTH-1:0]   dqs_read_valid_r  ;
  integer i,j;                                 
  reg                      aligned_valid_comb; 
  reg [MEM_DQS_WIDTH-1:0]  read_valid_sel    ;
  reg [8*MEM_DQ_WIDTH-1:0] aligned_data_comb ;
  reg                      error_comb        ;
                                                  
  //***************************************************************
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)          
        dqs_read_data_r  <= {(8*MEM_DQ_WIDTH){1'b0}};
     else
        dqs_read_data_r  <= dqs_read_data ;
  end
                                         
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)                                  
        dqs_read_valid_r  <= {MEM_DQS_WIDTH{1'b0}};
     else if(|dqs_read_valid_r)  
         dqs_read_valid_r <= dqs_read_valid_r & dqs_read_valid;
     else
         dqs_read_valid_r <= dqs_read_valid;
  end
                                         
   always @(*) 
   begin                    
     if (|dqs_read_valid_r) begin //send out data
          aligned_valid_comb  = 1'b1;            
          read_valid_sel      = dqs_read_valid_r;
          error_comb          = ~(&(dqs_read_valid_r | dqs_read_valid));
     end                             
     else begin                      
          aligned_valid_comb = 1'b0; 
          read_valid_sel     = 2'b0; 
          error_comb         = 1'b0; 
     end                             
   end                               
                               
   always @(*) 
   begin                                   
   	 for (i=0;i<MEM_DQS_WIDTH;i=i+1) begin 
   	 	  if (read_valid_sel[i]) begin     
   	 	  	 for (j=0;j<64;j=j+1)          
   	 	        aligned_data_comb[i*64+j] = dqs_read_data_r[i*64+j];
   	 	  end                                                       
   	 	  else begin                                                
   	 	  	 for (j=0;j<64;j=j+1)                                   
   	 	        aligned_data_comb[i*64+j] = dqs_read_data[i*64+j];  
   	 	  end                                   
   	 end                                        
   end                                          
                
  assign dqs_align_valid =  aligned_valid_comb; 
  assign dqs_align_data  =  aligned_data_comb;  
     
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)              
          align_error <= 1'b0; 
     else                            
     	  align_error <= error_comb;
  end
     
endmodule                            




// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_reset_ctrl_v1_0
(
    input        ddr_rstn                ,
    input        ref_clk                 ,
    input        dll_lock                ,
    input        pll_lock                ,
    input        ddrphy_cpd_done         ,
    input        training_error          ,
    input        ddrphy_calib_done       ,
    output reg   ddrphy_cpd_start        ,
    output reg   dll_update_req_rst_ctrl ,
    input        dll_update_ack_rst_ctrl ,
    output reg   dll_update_req_training ,
    input        dll_update_ack_training ,
    output reg   logic_rstn              ,
    output reg   phy_pll_rst             ,
    output reg   dll_freeze              ,
    output reg   ddrphy_dll_rst          ,    //dll reset
    output reg   ddrphy_rst_n            ,
    output reg   ddrphy_iol_rst          ,
    output reg   ddrphy_dqs_rst          ,
    output reg   ddrphy_ioclk_gate       
);

//parameter SRB_DQS_RST_TRAINING_HIGH_CLK = 4;

localparam e_IDLE          = 0;
localparam e_WAIT          = 1;
localparam e_PLL_LOCKED    = 2;
localparam e_DLL_LOCKED    = 3;
localparam e_DLL_UP_HOLD   = 4;
localparam e_GATE_CLK      = 5;
localparam e_GATE_OUT      = 6;
localparam e_GATE_HOLD     = 7;
localparam e_CPD_START     = 8;
localparam e_CPD_DONE      = 9;
localparam e_NORMAL        = 10;

`ifdef SIMULATION 
localparam UPDATE_TIME = 32'd500;
`else                      
localparam UPDATE_TIME = 32'd1000;
`endif

reg [3:0] state;
reg [1:0] pll_lock_d;
reg [1:0] dll_lock_d;
reg [7:0] cnt;
reg [1:0] dll_update_ack_rst_ctrl_d;
reg [1:0] dll_update_ack_training_d;
reg [1:0] ddrphy_cpd_done_d;
reg [31:0] dll_update_cnt;
reg [1:0] training_error_d;
reg [1:0] ddrphy_calib_done_d;
wire dll_lock_pose;

assign dll_lock_pose = dll_lock_d == 2'b01;

always @(posedge ref_clk or negedge logic_rstn)
begin
   if (!logic_rstn) begin
      pll_lock_d       <= 2'd0;
      dll_lock_d       <= 2'd0;
      dll_update_ack_rst_ctrl_d <= 2'd0;
      dll_update_ack_training_d <= 2'd0;
      ddrphy_cpd_done_d <= 2'd0;
      training_error_d <= 2'd0;
      ddrphy_calib_done_d <= 2'd0;
   end
   else begin
      pll_lock_d       <= {pll_lock_d[0], pll_lock};
      dll_lock_d       <= {dll_lock_d[0], dll_lock};      
      dll_update_ack_rst_ctrl_d <= {dll_update_ack_rst_ctrl_d[0],dll_update_ack_rst_ctrl};
      dll_update_ack_training_d <= {dll_update_ack_training_d[0],dll_update_ack_training};
      ddrphy_cpd_done_d <= {ddrphy_cpd_done_d[0],ddrphy_cpd_done};
      training_error_d <= {training_error_d[0],training_error};
      ddrphy_calib_done_d <= {ddrphy_calib_done_d[0],ddrphy_calib_done};
   end
end

always @(posedge ref_clk or negedge ddr_rstn)
begin
   if (!ddr_rstn) begin
      state <= e_IDLE;
      cnt   <= 8'd0; 
   end
   else begin
         case (state)
            e_IDLE: begin
               if (cnt == 8'd200) begin
                  state <= e_WAIT;
                  cnt   <= 8'd0;
               end
               else begin
                  state <= e_IDLE;
                  cnt <= cnt + 8'd1;   
               end
            end
            e_WAIT:begin
               cnt <= 8'd0;
               if (pll_lock_d[1] == 1'b1)
               state <= e_PLL_LOCKED; 
               else  
               state <= e_WAIT;
            end
            e_PLL_LOCKED: begin //wait for DLL lock
               if (cnt == 8'd100) begin
                  if (dll_lock_d[1] == 1'b1)
                     state <= e_DLL_LOCKED;
               end
               else begin
                  state <= e_PLL_LOCKED;
                  cnt <= cnt + 8'd1;
               end
            end
            e_DLL_LOCKED: begin
               cnt <= 8'd0;
               if (dll_update_ack_rst_ctrl_d[1] == 1'b1)
               state <= e_DLL_UP_HOLD;
               else
               state <= e_DLL_LOCKED;
            end
            e_DLL_UP_HOLD: begin
               cnt <= 8'd0;               
               if (dll_update_ack_rst_ctrl_d[1] == 1'b0)
               state <= e_GATE_CLK;
               else
               state <= e_DLL_UP_HOLD;
            end
            e_GATE_CLK: begin
               if (cnt == 8'd8) begin
                  cnt   <= 8'd0;
                  state <= e_GATE_OUT;
               end
               else begin
                  cnt   <= cnt + 8'd1;
                  state <= e_GATE_CLK;
               end
            end
            e_GATE_OUT: begin
               if (cnt == 8'd8) begin
                  state <= e_GATE_HOLD;
                  cnt   <= 8'd0;
               end
               else begin
                  state <= e_GATE_OUT;
                  cnt <= cnt + 8'd1;
               end
            end
            e_GATE_HOLD: begin //switch back to clkdiv out
               if (cnt == 8'd8) begin
                  cnt   <= 8'd0;
                  state <= e_CPD_START;
               end
               else begin
                  cnt <= cnt + 8'd1;
                  state <= e_GATE_HOLD;
               end
            end
            e_CPD_START:begin
                state <= e_CPD_DONE;
            end
            e_CPD_DONE:begin
                if(ddrphy_cpd_done_d[1] == 1)
                state <= e_NORMAL;
            end
            e_NORMAL: begin
              cnt   <= 8'd0; 
              if ((pll_lock_d[1] == 1'b0) || (training_error_d[1] == 1'b1))
              state <= e_IDLE;
              else
              state <= e_NORMAL;
            end
            default: begin
                state <= e_IDLE;
            end
         endcase   
   end
end

always @(posedge ref_clk or negedge ddr_rstn)
begin
   if (!ddr_rstn) begin
        ddrphy_dll_rst     <= 1'b1;
        ddrphy_rst_n       <= 1'b0;
        ddrphy_dqs_rst     <= 1'b1;
        ddrphy_iol_rst     <= 1'b1;
        ddrphy_ioclk_gate  <= 1'b1;
        dll_update_req_rst_ctrl <= 1'b0;
        ddrphy_cpd_start   <= 1'b0;
        logic_rstn <= 1'b0;
        phy_pll_rst <= 1'b1;
   end
   else begin
      ddrphy_dll_rst <= ((state == e_IDLE) || (state == e_WAIT));    //release dll reset after pll is locked
      dll_update_req_rst_ctrl <= state == e_DLL_LOCKED;      
      ddrphy_rst_n <= state == e_NORMAL;
      ddrphy_dqs_rst <= state == e_GATE_CLK;
      ddrphy_iol_rst  <= ((state == e_GATE_CLK)&&(cnt[2] == 1));
      ddrphy_cpd_start <= state == e_CPD_START;
      ddrphy_ioclk_gate <= (state == e_GATE_CLK)||(state == e_GATE_OUT);
      logic_rstn <= (state != e_IDLE);
      phy_pll_rst <=  state == e_IDLE;
   end
end

always @(posedge ref_clk or negedge ddr_rstn)
begin
   if (!ddr_rstn)
   dll_update_cnt <= 32'd0;
   else if((state == e_NORMAL)&&(ddrphy_calib_done_d[1] == 1))
   begin
    if(dll_update_cnt == UPDATE_TIME)
    begin
       if(dll_update_ack_training_d[1])
       dll_update_cnt <= 32'd0;
       else
       dll_update_cnt <= dll_update_cnt;
    end
    else
    dll_update_cnt <= dll_update_cnt + 32'd1;
   end
   else
   dll_update_cnt <= 32'd0;
end

always @(posedge ref_clk or negedge ddr_rstn)
begin
   if (!ddr_rstn)
   dll_freeze <= 0;
   else if((state == e_NORMAL)&&(ddrphy_calib_done_d[1] == 1))
   begin
     if(dll_update_cnt == UPDATE_TIME)
     dll_freeze <= 0;
     else
     dll_freeze <= 1;
   end
   else
   dll_freeze <= 0;
end

always @(posedge ref_clk or negedge ddr_rstn)
begin
   if (!ddr_rstn)
   dll_update_req_training <= 0;
   else if((state == e_NORMAL)&&(ddrphy_calib_done_d[1] == 1))
   begin
    if((dll_update_cnt == UPDATE_TIME)&&(dll_lock_pose == 1))
    dll_update_req_training <= 1;
    else
    dll_update_req_training <= 0;
   end
   else
   dll_update_req_training <= 0;
end


endmodule 






////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_rdcal_v1_0 #(
  parameter [1:0]   DDR_TYPE       = 2'b00 ,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR
  parameter [7:0]   TRFC           = 8'd16 ,
  parameter [7:0]   TRCD           = 8'd2  ,
  parameter MEM_ADDR_WIDTH         = 16    ,
  parameter MEM_BANKADDR_WIDTH     = 3     ,
  parameter MEM_DQ_WIDTH           = 16    
)(
   input [4:0]    mc_wl              ,  
   input          ddrphy_sysclk      ,
   input          ddrphy_rst_n       ,

   input          rdcal_start        ,
   output reg     rdcal_done         ,

   output reg     ddrphy_rst_req     ,
   input          ddrphy_rst_ack     ,

   output reg     gatecal_start      ,
   input          gate_check_pass    ,
   input          gate_adj_done      ,
   input          gate_cal_error     ,
   output reg     gate_move_en       ,

   output reg     rddata_cal         , 
   input          rddata_check_pass  ,

   output reg     init_adj_rdel      ,
   input          adj_rdel_done      ,

   output reg     rdel_calibration   ,
   input          rdel_calib_done    ,
   input          rdel_calib_error   ,
   output reg     rdel_move_en       ,
   input          rdel_move_done     ,

   input          write_debug        ,
   input          dqgt_debug         ,
   input [7:0]    rdel_rd_cnt        ,
   
   output reg     bitslip_ctrl       ,
   output         rdcalib_error      ,
   output [4:0]   dbg_rdcal          ,

   output reg [MEM_BANKADDR_WIDTH-1:0]  rdcal_ba          ,
   output reg [MEM_ADDR_WIDTH-1:0]      rdcal_address     ,
   output reg rdcal_cs_n        ,
   output reg rdcal_ras_n       ,
   output reg rdcal_cas_n       ,
   output reg rdcal_we_n        ,
   output reg rdcal_cke         ,
   output reg rdcal_odt         ,
   output reg [MEM_DQ_WIDTH*8-1:0] rdcal_wrdata,
   output reg [3:0]  rdcal_wrdata_en   
  );

  //main control states
  localparam RDCAL_IDLE             = 0;
  localparam RDCAL_RDEL_INIT        = 1;  
  localparam RDCAL_REFRESH          = 2;
  localparam RDCAL_REF_WAIT         = 3;
  localparam RDCAL_WR_ACT           = 4;
  localparam RDCAL_WR               = 5;
  localparam RDCAL_GATECAL_STATRT   = 6;
  localparam RDCAL_GATECAL_RD       = 7;
  localparam RDCAL_GATE_CHECK       = 8;  
  localparam RDCAL_GATECAL_RST      = 9;
  localparam RDCAL_RDDATA_CHECK     = 10;
  localparam RDCAL_BITSLIP          = 11;
  localparam RDCAL_RDEL_MPR_PRE     = 12;
  localparam RDCAL_OPEN_MPR         = 13;
  localparam RDCAL_RDEL_CALIB       = 14;
  localparam RDCAL_RDEL_TURN        = 15;
  localparam RDCAL_CLOSE_MPR        = 16;
  localparam RDCALIB_DONE           = 17;
  localparam RDCAL_ERROR            = 18;
  localparam RDCAL_GATECAL_ERROR    = 19; 
  localparam RDCAL_RDEL_PRE         = 20;

  localparam DFI_DQ_WIDTH = MEM_DQ_WIDTH * 8;
//  wire [63:0] pattern0 ;

  reg [7:0]     cnt;
  reg [4:0]     rdcal_state;
  reg [1:0]     ddrphy_rst_ack_r;
  reg [1:0]     ref_cnt;
  reg           cnt_trfc_pass;
  reg           ref_cnt_done  ;
  reg           rdcal_success ;
  reg [1:0]     wr_cnt;
  reg [1:0]     wr_cnt_d;
  reg           wr_enable;
  reg           wr_enable_d;
  reg  [3:0]    bslip_cnt;
  reg           bslip_start;
  wire [3:0]    bus_wr_enable   ;
  wire [3:0]    bus_wr_enable_d ;
  wire [DFI_DQ_WIDTH-1:0]    bus_wr_data    ;
  wire [DFI_DQ_WIDTH-1:0]    bus_wr_data_d  ;

///********************************main code************************
//refresh
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
          cnt_trfc_pass  <= 1'b0;
     else
         cnt_trfc_pass   <= (TRFC == cnt[7:0]);
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)  begin
          ref_cnt_done  <= 1'b0;
          ref_cnt       <= 2'b0;
     end
     else if(rdcal_state == RDCAL_REFRESH) begin
         ref_cnt       <= ref_cnt + 2'b1;
         ref_cnt_done  <= (&ref_cnt);                   //refresh 4
     end
  end

generate
if (DDR_TYPE == 2'b00) begin    //DDR3
////state
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if (!ddrphy_rst_n) begin
         rdcal_state        <= RDCAL_IDLE;
         cnt               <= 0;
      end
      else begin
         case (rdcal_state)
            RDCAL_IDLE: begin
                           cnt <= 0;
                           if (rdcal_start)
                                rdcal_state <= RDCAL_RDEL_INIT;
                         end

        RDCAL_RDEL_INIT: begin                                   //init_adj_rdel = 1
                              if (adj_rdel_done)                 //init adj rdel done
                                  rdcal_state <= RDCAL_REFRESH;
                         end

          RDCAL_REFRESH: begin                                   //refresh
                                cnt         <= 0;
                                rdcal_state <= RDCAL_REF_WAIT;
                         end

         RDCAL_REF_WAIT: begin
                              if(cnt_trfc_pass) begin            //delay trfc
                                 if(ref_cnt_done)  begin         //refresh 4
                                     rdcal_state   <= RDCAL_WR_ACT ;
                                       cnt         <= 0;
                                 end
                                 else
                                     rdcal_state   <= RDCAL_REFRESH;
                              end
                              else
                                      cnt          <= cnt + 1'b1;
                            end

            RDCAL_WR_ACT : begin                                 //active bank 0 row 0
                              if(cnt == TRCD) begin
                                   rdcal_state   <= RDCAL_WR;
                                   cnt           <= 'b0;
                               end
                               else
                                   cnt           <= cnt + 1'b1;
                            end

                RDCAL_WR : begin                                //write row 0 burst 4
                               if(cnt[2]) begin
                                      cnt      <=   'b0;
                                  begin
                                      if(write_debug)
                                         rdcal_state   <=  RDCAL_WR;
                                      else
                                         rdcal_state   <= RDCAL_GATECAL_STATRT;
                                  end
                               end
                               else
                                    cnt           <= cnt + 1'b1;
                           end
                           
     RDCAL_GATECAL_STATRT: begin                                //gatecal_start = 1
                              rdcal_state  <= RDCAL_GATECAL_RD;
                           end

        RDCAL_GATECAL_RD: begin                                 //read once
                             cnt   <= cnt + 1'b1; 
                             if(cnt[1]) begin
                                 cnt            <= 'b0;
                                 rdcal_state    <= RDCAL_GATE_CHECK ;
                             end
                         end
                         
        RDCAL_GATE_CHECK: begin
                             if (gate_adj_done)                 //single adjust complete  
                                  rdcal_state  <=  RDCAL_GATECAL_RST;
                             else if (gate_cal_error)           //gate fail
                                  rdcal_state  <=  RDCAL_GATECAL_ERROR ;
                             else
                                     rdcal_state  <=  RDCAL_GATE_CHECK ;
                          end

       RDCAL_GATECAL_RST: begin                                 //ddrphy_rst_req  = 1 
                            if(ddrphy_rst_ack_r[1]) begin       //gate_move_en = 1
                                if (dqgt_debug)
                                    rdcal_state <= RDCAL_GATECAL_RD;
                                else if(gate_check_pass) begin //gate process done
                                    if(rdcal_success)    //rdcal rdel calibration done
//                                        rdcal_state  <=  RDCALIB_DONE;
                                          rdcal_state  <= RDCAL_RDDATA_CHECK;
                                    else                
//                                        rdcal_state   <=  RDCAL_RDDATA_CHECK;
                                        rdcal_state   <= RDCAL_RDEL_MPR_PRE;
                                end
                                else if(bslip_start)
                                      rdcal_state  <= RDCAL_RDDATA_CHECK; 
                                else
                                      rdcal_state   <=  RDCAL_GATECAL_RD;
                            end
                            else
                                 rdcal_state  <= RDCAL_GATECAL_RST;
                         end
  //need add dqs_cal_error,when rdel adjust to boundary ,the calibration is fail.
      RDCAL_RDDATA_CHECK: begin
                             if(rddata_check_pass) begin       //read data check pass
                                 cnt   <= 'h0;
//                                 rdcal_state    <= RDCAL_RDEL_MPR_PRE; //ddr3
                                 rdcal_state    <= RDCALIB_DONE;
                             end
                             else if (cnt[5]) begin    /// key point,delay
                                 if(bslip_cnt[3] == 1)
                                 rdcal_state    <= RDCAL_ERROR;
                                 else 
                                 rdcal_state    <= RDCAL_BITSLIP;
//                                 rdcal_state    <= RDCAL_ERROR;
//                                    rdcal_state     <= RDCAL_RDEL_BASE_ADJ;
                                    cnt             <= 'h0;
                             end
                             else   begin
                                  rdcal_state   <= RDCAL_RDDATA_CHECK ;
                                  cnt           <= cnt + 1'b1; 
                             end
                         end

         RDCAL_BITSLIP: begin
            if(cnt[5]) begin
                rdcal_state    <= RDCAL_GATECAL_RST;
                cnt   <= 'h0;
            end
            else begin
                rdcal_state   <= RDCAL_BITSLIP ;
                cnt           <= cnt + 1'b1;
            end
        end
//     RDCAL_RDEL_BASE_ADJ: begin                                //reinit_adj_rdel = 1
//                            if (stop_with_error)               //manual stop
//                                  rdcal_state <= RDCAL_ERROR;
//                            else if (adj_rdel_done) begin      //adj_rdel_done
//                                    cnt        <= 0;
//                                    rdcal_state  <= RDCAL_GATECAL_STATRT;
//                            end
//                            else
//                               cnt <= cnt + 1;
//                         end

    RDCAL_RDEL_MPR_PRE: begin                                  //prechage all banks
                            if(cnt[2]) begin
                               cnt            <= 'h0 ;
                               rdcal_state    <= RDCAL_OPEN_MPR;
                            end
                            else  begin
                               rdcal_state    <= RDCAL_RDEL_MPR_PRE;
                               cnt            <= cnt + 1'b1;
                            end
                        end

            RDCAL_OPEN_MPR: begin                              //open MPR
                               if (cnt[4]) begin
                                  rdcal_state <= RDCAL_RDEL_CALIB;
                                  cnt         <= 'b0;
                               end
                               else begin
                                  cnt         <= cnt + 1'b1;
                               end
                            end  
                                                                                                                                    
            RDCAL_RDEL_CALIB: begin
                                if (rdel_rd_cnt==8'b0)         // for read data eye measure
                                   begin
                                     rdcal_state  <= RDCAL_RDEL_CALIB;
                                     cnt     <= cnt + 1'b1;
                                   end
                                else begin
                                  if(cnt==rdel_rd_cnt)
                                    rdcal_state  <= RDCAL_RDEL_TURN;
                                  else
                                    cnt          <= cnt +1'b1;
                                end
                              end

            RDCAL_RDEL_TURN: begin
                               if (rdel_calib_done) begin
                                  cnt         <= 'b0;
                                  rdcal_state  <= RDCAL_CLOSE_MPR;
                               end
                               else if (rdel_move_done) begin
                                  cnt         <= 0;
                                  rdcal_state <= RDCAL_RDEL_CALIB;
                               end
                               else if (~cnt[5]) //wait for remain data is finished
                                   cnt <= cnt + 1;
                            end

            RDCAL_CLOSE_MPR: begin
                                if (cnt[5]) begin
                                   cnt  <= 'b0;
                                   begin
                                     if (rdel_calib_error)
                                        rdcal_state <= RDCAL_ERROR;
                                     else
                                        rdcal_state <= RDCAL_REFRESH;
                                   end
                                end
                                else
                                   cnt <= cnt + 1;
                             end                       

            RDCAL_ERROR:  rdcal_state  <= RDCAL_ERROR;

    RDCAL_GATECAL_ERROR:  rdcal_state  <= RDCAL_GATECAL_ERROR ;
          

           RDCALIB_DONE: begin
                             cnt  <=  cnt + 1'b1;
                             if(cnt[3]) begin
                                rdcal_state <= RDCAL_IDLE;
                                cnt         <= 'h0;
                             end
                         end

            default:             rdcal_state <= RDCAL_IDLE;

          endcase
      end
    end
end

else  begin    //DDR2 LPDDR
////state
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if (!ddrphy_rst_n) begin
         rdcal_state        <= RDCAL_IDLE;
         cnt               <= 0;
      end
      else begin
         case (rdcal_state)
            RDCAL_IDLE: begin
                           cnt <= 0;
                           if (rdcal_start)
                                rdcal_state <= RDCAL_RDEL_INIT;
                         end

        RDCAL_RDEL_INIT: begin                                   //init_adj_rdel = 1
                              if (adj_rdel_done)                 //init adj rdel done
                                  rdcal_state <= RDCAL_REFRESH;
                         end

          RDCAL_REFRESH: begin                                   //refresh
                                cnt         <= 0;
                                rdcal_state <= RDCAL_REF_WAIT;
                         end

         RDCAL_REF_WAIT: begin
                              if(cnt_trfc_pass) begin            //delay trfc
                                 if(ref_cnt_done)  begin         //refresh 4
                                     rdcal_state   <= RDCAL_WR_ACT ;
                                       cnt         <= 0;
                                 end
                                 else
                                     rdcal_state   <= RDCAL_REFRESH;
                              end
                              else
                                      cnt          <= cnt + 1'b1;
                            end

            RDCAL_WR_ACT : begin                                 //active bank 0 row 0
                              if(cnt == TRCD) begin
                                   rdcal_state   <= RDCAL_WR;
                                   cnt           <= 'b0;
                               end
                               else
                                   cnt           <= cnt + 1'b1;
                            end

                RDCAL_WR : begin                                //write row 0 burst 4
                               if(cnt[2]) begin
                                      cnt      <=   'b0;
                                  begin
                                      if(write_debug)
                                         rdcal_state   <=  RDCAL_WR;
                                      else
                                         rdcal_state   <= RDCAL_GATECAL_STATRT;
                                  end
                               end
                               else
                                    cnt           <= cnt + 1'b1;
                           end
                           
     RDCAL_GATECAL_STATRT: begin                                //gatecal_start = 1
                              rdcal_state  <= RDCAL_GATECAL_RD;
                           end

        RDCAL_GATECAL_RD: begin                                 //read once
                             cnt   <= cnt + 1'b1; 
                             if(cnt[1]) begin
                                 cnt            <= 'b0;
                                 rdcal_state    <= RDCAL_GATE_CHECK ;
                             end
                         end
                         
        RDCAL_GATE_CHECK: begin
                             if (gate_adj_done)                 //single adjust complete  
                                  rdcal_state  <=  RDCAL_GATECAL_RST;
                             else if (gate_cal_error)           //gate fail
                                  rdcal_state  <=  RDCAL_GATECAL_ERROR ;
                             else
                                     rdcal_state  <=  RDCAL_GATE_CHECK ;
                          end

       RDCAL_GATECAL_RST: begin                                 //ddrphy_rst_req  = 1 
                            if(ddrphy_rst_ack_r[1]) begin       //gate_move_en = 1
                                if (dqgt_debug)
                                    rdcal_state <= RDCAL_GATECAL_RD;
                                else if(gate_check_pass) begin //gate process done
                                    if(rdcal_success)    //rdcal rdel calibration done
                                        rdcal_state  <=  RDCAL_RDDATA_CHECK;
                                    else                
                                        rdcal_state   <=  RDCAL_RDEL_CALIB;
                                end
                                else if(bslip_start)
                                      rdcal_state  <= RDCAL_RDDATA_CHECK;
                                else
                                      rdcal_state   <=  RDCAL_GATECAL_RD;
                            end
                            else
                                 rdcal_state  <= RDCAL_GATECAL_RST;
                         end          
                         
  //need add dqs_cal_error,when rdel adjust to boundary ,the calibration is fail.
      RDCAL_RDDATA_CHECK: begin
                             if(rddata_check_pass) begin   
                                 cnt   <= 'h0;
                                 rdcal_state    <= RDCALIB_DONE ;
                             end
                             else if (cnt[5]) begin    /// key point,delay
                                 if(bslip_cnt[3] == 1)
                                 rdcal_state    <= RDCAL_ERROR;
                                 else 
                                 rdcal_state    <= RDCAL_BITSLIP;
                                 cnt             <= 'h0;
                             end
                             else   begin
                                  rdcal_state   <= RDCAL_RDDATA_CHECK ;
                                  cnt           <= cnt + 1'b1; 
                             end
                         end

         RDCAL_BITSLIP: begin
            if(cnt[5]) begin
                rdcal_state    <= RDCAL_GATECAL_RST;
                cnt   <= 'h0;
            end
            else begin
                rdcal_state   <= RDCAL_BITSLIP ;
                cnt           <= cnt + 1'b1;
            end
        end
                                                                                                                                    
            RDCAL_RDEL_CALIB: begin
                                if(cnt==rdel_rd_cnt)
                                  rdcal_state  <= RDCAL_RDEL_TURN;
                                else
                                  cnt          <= cnt +1'b1;
                              end

            RDCAL_RDEL_TURN: begin
                               if (rdel_calib_done) begin
                                  cnt         <= 'b0;
                                  rdcal_state  <= RDCAL_RDEL_PRE ;
                               end
                               else if (rdel_move_done) begin
                                  cnt         <= 0;
                                  rdcal_state <= RDCAL_RDEL_CALIB;
                               end
                               else if (~cnt[5]) //wait for remain data is finished
                                   cnt <= cnt + 1;
                            end

           RDCAL_RDEL_PRE : begin
                               if (cnt[5]) begin    
                                  cnt    <= 'b0;
                                  begin                      
                                    if (rdel_calib_error)                   
                                      rdcal_state <= RDCAL_ERROR;  
                                    else                                    
                                     rdcal_state <= RDCAL_REFRESH;  
                                  end      
                               end                                        
                               else                                       
                                  cnt <= cnt + 1; 
                            end                        

            RDCAL_ERROR:  rdcal_state  <= RDCAL_ERROR;

    RDCAL_GATECAL_ERROR:  rdcal_state  <= RDCAL_GATECAL_ERROR ;

           RDCALIB_DONE: begin
                             cnt  <=  cnt + 1'b1;
                             if(cnt[3]) begin
                                rdcal_state <= RDCAL_IDLE;
                                cnt         <= 'h0;
                             end
                         end

            default:             rdcal_state <= RDCAL_IDLE;

          endcase
      end    
    end
end
endgenerate

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if (!ddrphy_rst_n)
    bslip_cnt <= 4'd0;
    else if(rdcal_state == RDCAL_IDLE)
    bslip_cnt <= 4'd0;
    else if((rdcal_state == RDCAL_RDDATA_CHECK) && cnt[5])
    bslip_cnt <= bslip_cnt + 4'd1;
  end
  
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if (!ddrphy_rst_n)
    bitslip_ctrl <= 0;
    else if((rdcal_state == RDCAL_BITSLIP)&& ((cnt[5:0] < 6'd2) || (cnt[5:0] == 6'd5) || (cnt[5:0] == 6'd6) ))
    bitslip_ctrl <= 1;
    else
    bitslip_ctrl <= 0;
  end

///output
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if (!ddrphy_rst_n)
       rdcal_success   <= 1'b0 ;
    else if(rdcal_state == RDCAL_IDLE)
       rdcal_success   <= 1'b0; 
//    else if (rddata_check_pass)
    else if (rdcal_state == RDCAL_RDEL_CALIB)
       rdcal_success   <= 1'b1;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if (!ddrphy_rst_n)
       bslip_start   <= 1'b0 ;
    else if(rdcal_state == RDCALIB_DONE)
       bslip_start   <= 1'b0; 
    else if (rdcal_state == RDCAL_BITSLIP)
       bslip_start   <= 1'b1;
  end
   
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
          gatecal_start   <=  1'b0 ;
     else if((~dqgt_debug) & (ddrphy_rst_ack_r[1] & gate_check_pass))
          gatecal_start   <= 1'b0;
     else if(rdcal_state == RDCAL_GATECAL_STATRT)
          gatecal_start   <=  1'b1;
  end
     
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
          gate_move_en    <= 1'b0 ;
     else if (ddrphy_rst_ack_r[1] & (rdcal_state == RDCAL_GATECAL_RST))
          gate_move_en    <= 1'b1;
     else 
          gate_move_en    <= 1'b0 ;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
            rddata_cal   <=  1'b0;
     else if (rdcal_state == RDCAL_RDDATA_CHECK) begin
            if(~|cnt)
               rddata_cal   <= 1'b1 ;
            else if (cnt[5])
               rddata_cal   <= 1'b0 ;
     end
     else
         rddata_cal  <= 1'b0;
  end

///----------------rdel relate logic----------------------//////////
//adjust RDEL base setting
always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n) 
      init_adj_rdel     <= 1'b0;
   else 
      init_adj_rdel     <= (rdcal_state == RDCAL_RDEL_INIT) & (~adj_rdel_done);
end              

//*************************************************************************************
//adjust RDEL calibration
always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n) begin
      rdel_calibration <= 1'b0;
      rdel_move_en     <= 1'b0;
   end
   else begin
      rdel_calibration <= (rdcal_state == RDCAL_RDEL_CALIB) || (rdcal_state == RDCAL_RDEL_TURN);
      rdel_move_en     <= (rdcal_state == RDCAL_RDEL_TURN) && cnt[5];
   end
end   

/////------------------read calibration error----------------//////////
  assign rdcalib_error = ((rdcal_state == RDCAL_ERROR)||(rdcal_state ==RDCAL_GATECAL_ERROR));
///--------------------read calibration done--------------//////////
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
   if (!ddrphy_rst_n)
       rdcal_done   <=  1'b0;
   else if(rdcal_state == RDCALIB_DONE)
   begin
       if(cnt[2:0]==3'b111)
       rdcal_done   <=  1'b1;    
   end
   else
       rdcal_done   <=  1'b0;
 end         
    
 // assign rdcal_done    = (rdcal_state == RDCALIB_DONE);
////******************************************************************///
///rset state
///*******************************************************************///
///input
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if (!ddrphy_rst_n)
        ddrphy_rst_ack_r   <= 2'd0;
    else
        ddrphy_rst_ack_r   <= {ddrphy_rst_ack_r[0],ddrphy_rst_ack};
 end

///output
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if (!ddrphy_rst_n)
       ddrphy_rst_req     <= 1'b0;
    else
       ddrphy_rst_req     <= rdcal_state == RDCAL_GATECAL_RST;
 end      

//*******************DDR Command*************************************///
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
        rdcal_odt   <= 1'b0;
     else if(rdcal_state == RDCAL_WR)
        rdcal_odt   <= 1'b1;
     else
        rdcal_odt   <= 1'b0;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
        rdcal_cke   <= 1'b0;
     else
        rdcal_cke   <= 1'b1;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n) begin
        rdcal_cs_n       <= 1'b1;
        rdcal_ras_n      <= 1'b0;
        rdcal_cas_n      <= 1'b0;
        rdcal_we_n       <= 1'b0;
        rdcal_ba         <= {MEM_BANKADDR_WIDTH{1'b0}};
        rdcal_address    <= {MEM_ADDR_WIDTH{1'b0}};
     end
     else  begin
        rdcal_cs_n       <= 1'b1;
        rdcal_ras_n      <= 1'b1;
        rdcal_cas_n      <= 1'b1;
        rdcal_we_n       <= 1'b1;
        rdcal_ba         <= {MEM_BANKADDR_WIDTH{1'b0}};
        rdcal_address    <= {MEM_ADDR_WIDTH{1'b0}};
        case(rdcal_state)
           RDCAL_REFRESH : begin //ref
                             rdcal_cs_n       <= 1'b0;
                             rdcal_ras_n      <= 1'b0;
                             rdcal_cas_n      <= 1'b0;
                             rdcal_we_n       <= 1'b1;
                           end

          RDCAL_WR_ACT : begin //act
                           if(~|cnt)begin     //cnt = 0
                             rdcal_cs_n       <= 1'b0;
                             rdcal_ras_n      <= 1'b0;
                             rdcal_cas_n      <= 1'b1;
                             rdcal_we_n       <= 1'b1;
                           end
                         end

             RDCAL_WR : begin   //wr
                          //if(bl && (cnt[4:0] < 5'd4)) begin  
                          if(cnt[4:0] < 5'd2) begin
                               rdcal_cs_n            <= 1'b0;
                               rdcal_ras_n           <= 1'b1;
                               rdcal_cas_n           <= 1'b0;
                               rdcal_we_n            <= 1'b0;
                               rdcal_address         <= {{(MEM_ADDR_WIDTH-5){1'b0}},cnt[1:0],3'b000};
                            end
                        end

     RDCAL_GATECAL_RD: begin
                             if(cnt == 8'h0)
                               begin
                                  rdcal_cs_n            <= 1'b0;
                                  rdcal_ras_n           <= 1'b1;
                                  rdcal_cas_n           <= 1'b0;
                                  rdcal_we_n            <= 1'b1;
                               end
                         end
  
     RDCAL_RDDATA_CHECK: begin
                             if(cnt < 8'h2)
                               begin
                                  rdcal_cs_n            <= 1'b0;
                                  rdcal_ras_n           <= 1'b1;
                                  rdcal_cas_n           <= 1'b0;
                                  rdcal_we_n            <= 1'b1;
                               end
                          end

   RDCAL_RDEL_MPR_PRE: begin
                         if(~|cnt) begin
                             rdcal_cs_n            <= 1'b0;
                             rdcal_ras_n           <= 1'b0;
                             rdcal_cas_n           <= 1'b1;
                             rdcal_we_n            <= 1'b0;
                             rdcal_address         <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0};
                         end
                       end
                                                                                                                                                     
        RDCAL_OPEN_MPR : begin
                            if (~|cnt) begin
                                 rdcal_cs_n          <= 1'b0;
                                 rdcal_ras_n         <= 1'b0;
                                 rdcal_cas_n         <= 1'b0;
                                 rdcal_we_n          <= 1'b0;
                                 rdcal_address       <= {{(MEM_ADDR_WIDTH-3){1'b0}},1'b1,2'h0};
                                 rdcal_ba            <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'h3};
                            end
                         end

            RDCAL_RDEL_CALIB: begin  //rd
                                rdcal_cs_n          <= 1'b0;
                                rdcal_ras_n         <= 1'b1;
                                rdcal_cas_n         <= 1'b0;
                                rdcal_we_n          <= 1'b1;
                                rdcal_address       <= {{(MEM_ADDR_WIDTH-13){1'b0}},13'h8};
                             end 
                                                                     
             RDCAL_RDEL_PRE: begin                                                   
                                 if(cnt== 8'd4) begin                     
                                     rdcal_cs_n          <= 1'b0 ;           
                                     rdcal_ras_n         <= 1'b0 ;           
                                     rdcal_cas_n         <= 1'b1 ;           
                                     rdcal_we_n          <= 1'b0 ;         
                                     rdcal_address       <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0};           
                                  end                                        
                              end 
                              
               RDCALIB_DONE:begin
                              if(~|cnt)begin
                                 rdcal_cs_n          <= 1'b0; 
                                 rdcal_ras_n         <= 1'b0; 
                                 rdcal_cas_n         <= 1'b1; 
                                 rdcal_we_n          <= 1'b0; 
                                 rdcal_address       <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0}; 
                              end
                            end

            RDCAL_CLOSE_MPR: begin
                               if (cnt[5:0]==6'd12) begin
                                  rdcal_cs_n          <= 1'b0;
                                  rdcal_ras_n         <= 1'b0;
                                  rdcal_cas_n         <= 1'b0;
                                  rdcal_we_n          <= 1'b0;
                                  rdcal_ba            <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'h3};
                               end
                            end
            endcase
     end
  end

////--------------------DDR data write---------------------------------///

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n) begin
   	  wr_enable  <= 1'b0;
   end
   else begin
   	  if (rdcal_state == RDCAL_WR) begin
   	     case (mc_wl[4:2])
            3'b000 : begin
                        if((cnt[4:0] == 5'd0)||(cnt[4:0] == 5'd1))
                           wr_enable  <= 1'b1;
                        else
                           wr_enable  <= 1'b0;
                      end
            3'b001 : begin
                       if((cnt[4:0] == 5'd1)||(cnt[4:0] == 5'd2))
   	                       wr_enable <= 1'b1;
   	                   else    	                        
                           wr_enable <= 1'b0;
                      end

            3'b010 : begin
                        if((cnt[4:0] == 5'd2)||(cnt[4:0] == 5'd3))
                           wr_enable   <= 1'b1;
                        else
                           wr_enable   <= 1'b0;
                      end

   	        3'b011 : begin
   	                    if((cnt[4:0] == 5'd3)||(cnt[4:0] == 5'd4))
   	                        wr_enable <= 1'b1;
   	                    else
   	                        wr_enable <= 1'b0;
   	                  end
   	        default:
   	                wr_enable <= 1'b0;
   	      endcase
   	   end
   	else
   	     wr_enable <= 1'b0;
  end
end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if (!ddrphy_rst_n) begin
       	  wr_enable_d <= 1'b0;
       	  wr_cnt      <= 2'h0;
       	  wr_cnt_d    <= 2'h0;
     end
    else begin
    	 wr_enable_d <= wr_enable;
    	 wr_cnt_d    <= wr_cnt;
    	 if (wr_enable)
    	    wr_cnt  <= wr_cnt + 2'h1;
    	 else
    	    wr_cnt  <= 2'h0;
    end
 end

  assign bus_wr_enable   = {4{wr_enable}};
  assign bus_wr_enable_d = {4{wr_enable_d}};

  assign bus_wr_data   = (wr_cnt == 2'd0) ? {{DFI_DQ_WIDTH/2{1'b0}}, {DFI_DQ_WIDTH/4{1'b1}}, {DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}}} :
                         (wr_cnt == 2'd1) ? {{DFI_DQ_WIDTH/8{1'b1}},{DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}},{DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}}, {DFI_DQ_WIDTH/8{1'b0}}, {DFI_DQ_WIDTH/8{1'b1}},{DFI_DQ_WIDTH/8{1'b0}}} :
                         {{DFI_DQ_WIDTH/2{1'b0}}, {DFI_DQ_WIDTH/4{1'b1}}, {DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}}};
                         
  assign bus_wr_data_d = (wr_cnt_d == 2'd0) ? {{DFI_DQ_WIDTH/2{1'b0}}, {DFI_DQ_WIDTH/4{1'b1}}, {DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}}} :
                         (wr_cnt_d == 2'd1) ? {{DFI_DQ_WIDTH/8{1'b1}},{DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}},{DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}}, {DFI_DQ_WIDTH/8{1'b0}}, {DFI_DQ_WIDTH/8{1'b1}},{DFI_DQ_WIDTH/8{1'b0}}} :
                         {{DFI_DQ_WIDTH/2{1'b0}}, {DFI_DQ_WIDTH/4{1'b1}}, {DFI_DQ_WIDTH/8{1'b0}},{DFI_DQ_WIDTH/8{1'b1}}};

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) begin
        rdcal_wrdata_en  <= 4'b0000;
        rdcal_wrdata     <= {DFI_DQ_WIDTH{1'b0}};
     end
     else begin
        case (mc_wl[1:0])
            2'b00:begin
                rdcal_wrdata_en  <= bus_wr_enable;
                rdcal_wrdata     <= bus_wr_data;
            end
            2'b01:begin
                rdcal_wrdata_en  <= {bus_wr_enable[2:0], bus_wr_enable_d[3]};
                rdcal_wrdata     <= {bus_wr_data[DFI_DQ_WIDTH*3/4-1 : 0], bus_wr_data_d[DFI_DQ_WIDTH-1: DFI_DQ_WIDTH*3/4]};
            end
            2'b10:begin
                rdcal_wrdata_en <= {bus_wr_enable[1:0], bus_wr_enable_d[3:2]};
                rdcal_wrdata    <= {bus_wr_data[DFI_DQ_WIDTH*2/4-1 : 0], bus_wr_data_d[DFI_DQ_WIDTH-1: DFI_DQ_WIDTH*2/4]};
            end
            2'b11:begin
                rdcal_wrdata_en <= {bus_wr_enable[0],bus_wr_enable_d[3:1]};
                rdcal_wrdata    <= {bus_wr_data[DFI_DQ_WIDTH*1/4-1 : 0], bus_wr_data_d[DFI_DQ_WIDTH-1: DFI_DQ_WIDTH*1/4]};
            end
            default:begin
                rdcal_wrdata_en <= 4'b0000;
                rdcal_wrdata     <= {DFI_DQ_WIDTH{1'b0}};
            end
        endcase
     end
  end

 assign  dbg_rdcal = rdcal_state;   

endmodule





////////////////////////////////////////////////////////////////    
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                       
// ALL RIGHTS REVERVED.                                             
////////////////////////////////////////////////////////////////    
//Description:                                                      
//Author:  wxxiao                                                   
//History: v1.0                                                     
////////////////////////////////////////////////////////////////    
`timescale 1ns/1ps   
module ips2l_ddrphy_main_ctrl_v1_0 #(
   //parameter
   parameter [1:0] DDR_TYPE     = 2'b00 ,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR
   parameter       EYECAL_EN    = 1     
)(
   //port             
   input      ddrphy_sysclk ,
   input      ddrphy_rst_n ,
                         
   input      update_cal_req,
                    
   output reg init_start   ,
   input      init_done    ,
   
   input      wrlvl_en     ,
   output reg wrlvl_start  ,
   input      wrlvl_done   ,

   output reg rdcal_start  ,
   input      rdcal_done   ,

   output reg wrcal_start  ,
   input      wrcal_done   ,
   
   output reg eyecal_start ,
   input      eyecal_done  ,
                      
   output reg update_start ,
   input      update_done  ,
                      
   output [3:0] dbg_main  ,

//   input      enter_dpd   ,
//   input      exit_dpd    ,                      
   output reg calib_done  

  );
  
  localparam  IDLE_PHASE   =4'h0;
  localparam  INIT_PHASE   =4'h1;
  localparam  WRLVL_PHASE  =4'h2;
  localparam  RDCAL_PHASE  =4'h3;
  localparam  WRCAL_PHASE  =4'h4;
  localparam  EYECAL_PHASE =4'h5;
  localparam  UPDATE_PHASE =4'h6;
  localparam  DDRC_PHASE   =4'h7;
  
  reg [3:0] main_state;   
  reg [3:0] main_next_state;
  
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)
        main_state  <= IDLE_PHASE;
    else 
        main_state  <= main_next_state;
  end
  
  always @(*) 
  begin
        main_next_state = main_state;  
    case(main_state)      
          IDLE_PHASE   : main_next_state = INIT_PHASE ; 
          
          INIT_PHASE   : if(init_done)
                           begin
                            if((wrlvl_en == 1)&&(DDR_TYPE == 2'b00))          //WL enable & DDR3
                                main_next_state = WRLVL_PHASE;
//                            else  if (exit_dpd)
//                                main_next_state = DDRC_PHASE;
                            else 
                                main_next_state = RDCAL_PHASE;   
                           end                       
                          else 
                                main_next_state = INIT_PHASE ;
          
          WRLVL_PHASE  : if(wrlvl_done)                      //write levling done
                            main_next_state = RDCAL_PHASE ;
                         else 
                            main_next_state = WRLVL_PHASE ;
          
          RDCAL_PHASE  : if(rdcal_done) begin                      //read calibration done
//                            if(WRCAL_EN == 1)
                            main_next_state = WRCAL_PHASE;
//                            else
//                            main_next_state = DDRC_PHASE;
                         end
                         else 
                            main_next_state = RDCAL_PHASE; 
                            
          WRCAL_PHASE : if(wrcal_done) begin                     //write calibration done
                           if(EYECAL_EN == 1)
                           main_next_state = EYECAL_PHASE;
                           else
                           main_next_state = DDRC_PHASE;
                         end
                         else 
                            main_next_state = WRCAL_PHASE;
                            
          EYECAL_PHASE : if(eyecal_done)                   //sample calibration done
                            main_next_state = DDRC_PHASE;
                         else 
                            main_next_state = EYECAL_PHASE;
                            
          DDRC_PHASE   : if(update_cal_req)                  //update calibration request
                            main_next_state = UPDATE_PHASE;
                         else begin
//                            if(exit_dpd & enter_dpd)
//                              main_next_state =  INIT_PHASE;
//                            else
                            main_next_state = DDRC_PHASE ;
                        end
                          
          UPDATE_PHASE : if(update_done)                     //update calibration done
                            main_next_state = DDRC_PHASE;
                         else
                            main_next_state = UPDATE_PHASE;
            
      endcase
  end
  
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)  
       init_start  <= 1'b0;
    else if(main_next_state == INIT_PHASE)
       init_start  <= 1'b1;
    else 
       init_start  <= 1'b0;
  end
              
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                             
       wrlvl_start  <= 1'b0;                       
    else if(main_next_state == WRLVL_PHASE)        
       wrlvl_start  <= 1'b1;                       
    else                                          
       wrlvl_start  <= 1'b0;                    
  end
       
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                           
       rdcal_start  <= 1'b0;                    
    else if(main_next_state == RDCAL_PHASE)     
       rdcal_start  <= 1'b1;                    
    else                                        
       rdcal_start  <= 1'b0;   
  end
       
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                                     
       wrcal_start  <= 1'b0;                              
    else if(main_next_state == WRCAL_PHASE)               
       wrcal_start  <= 1'b1;                              
    else                                                  
       wrcal_start  <= 1'b0;                           
  end
   
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                                     
       eyecal_start  <= 1'b0;                              
    else if(main_next_state == EYECAL_PHASE)               
       eyecal_start  <= 1'b1;                              
    else                                                  
       eyecal_start  <= 1'b0;                           
  end
   
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                             
       update_start  <= 1'b0;                      
    else if(main_next_state == UPDATE_PHASE)       
       update_start  <= 1'b1;                      
    else                                          
       update_start  <= 1'b0;  
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                                   
        calib_done  <= 1'b0;
    else if(main_next_state == DDRC_PHASE) 
        calib_done  <= 1'b1;   
    else
        calib_done  <= 1'b0;   
  end

assign dbg_main =  main_state;   
       
endmodule           
    
    
                                         
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module  ips2l_ddrphy_init_v1_0 #(
  parameter [1:0]   DDR_TYPE      = 2'b00    ,    //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR
  parameter [19:0]  T200US        = 20'd20000,
  parameter [19:0]  T500US        = 20'd50000,
  parameter [7:0]   T400NS        = 8'd40    ,
  parameter [7:0]   TMRD          = 8'd1     ,
  parameter [7:0]   TMOD          = 8'd3     ,
  parameter [7:0]   TXPR          = 8'd17    , 
  parameter [7:0]   TRP           = 8'd2     ,
  parameter [7:0]   TRFC          = 8'd16    ,
  parameter [9:0]   TZQINIT       = 10'd128  ,
  parameter [3:0]   REF_CNT       = 4'd9     ,
  parameter MEM_ADDR_WIDTH        = 16       ,
  parameter MEM_BANKADDR_WIDTH    = 3    
)(
  input             ddrphy_sysclk,
  input             ddrphy_rst_n ,

  input             init_start   ,
  output reg        init_done    ,

  input [15:0]      mr0          ,
  input [15:0]      mr1          ,
  input [15:0]      mr2          ,
  input [15:0]      mr3          ,
  output [3:0]      dbg_init     ,
  
  output reg        init_rst     ,
  output reg [MEM_BANKADDR_WIDTH-1:0]  init_ba      ,
  output reg [MEM_ADDR_WIDTH-1:0]      init_address ,
  output reg        init_cs_n    ,
  output reg        init_ras_n   ,
  output reg        init_cas_n   ,
  output reg        init_we_n    ,
  output reg        init_cke     ,
  output            init_odt
 );

  localparam  INIT_IDLE         = 4'h0;
  localparam  INIT_WAIT_RESET   = 4'h1;
  localparam  INIT_WAIT_CKE     = 4'h2;
  localparam  INIT_WAIT_TXPR    = 4'h3;
  localparam  INIT_LOAD_MR      = 4'h4;
  localparam  INIT_WAIT_TMRD    = 4'h5;
  localparam  INIT_WAIT_TMOD    = 4'h6;
  localparam  INIT_ZQCL         = 4'h7;
  localparam  INIT_WAIT_TZQINIT = 4'h8;
  localparam  INIT_DONE         = 4'h9;
  localparam  INIT_PREA         = 4'ha; 
  localparam  INIT_PREA_WAIT    = 4'hb;
  localparam  INIT_ARF          = 4'hc;
  localparam  INIT_WAIT_ARF     = 4'hd;
  localparam  INIT_LOAD_MR_DDR2 = 4'he;
  localparam  INIT_MR_DDR2_WAIT = 4'hf;
  
  localparam  LOAD_MR2     = 2'b00;
  localparam  LOAD_MR3     = 2'b01;
  localparam  LOAD_MR1     = 2'b10;
  localparam  LOAD_MR0     = 2'b11;
  localparam  LOAD_DONE    = 2'b11;
  localparam  LOAD_LP_DONE = 2'b01;
 

  reg [3:0]  init_state      ;
  reg [3:0]  init_next_state ;

  reg [19:0] cnt_t200us;
  reg [19:0] cnt_t500us;
  reg [7:0]  cnt_cmd   ;
  reg        cnt_cke_pass;
  reg        cnt_pwron_pass;
  reg        cnt_txpr_pass;
  reg        cnt_prea_pass;
  reg        cnt_arf_pass;
  reg [3:0]  arf_cnt     ;
  reg        arf_done    ;  
  reg        ocd_cal_done;
  reg [1:0]  ocd_cal_cnt ;  
  reg        cnt_tmrd_pass;
  reg        cnt_tmod_pass;
  reg        mr_load_done;
  reg [1:0]  mr_load_cnt;
  reg        cnt_tzqinit_pass;
  reg [9:0]  cnt_tzqinit ;
  wire [7:0] txpr;

  assign  txpr = (DDR_TYPE==2'b00) ? TXPR : T400NS;

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
         cnt_t200us      <= 20'h0 ;
      else if(init_start)
         cnt_t200us      <= cnt_t200us + 20'h1;
      else
        cnt_t200us      <= 20'h0 ;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
         cnt_pwron_pass  <= 1'b0 ;
      else if((init_state == INIT_IDLE) & init_start)
         cnt_pwron_pass  <= 1'b0 ;
      else if(!cnt_pwron_pass)
         cnt_pwron_pass  <= (cnt_t200us == T200US);
  end


  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n) 
  begin
    if(!ddrphy_rst_n)                             
       cnt_t500us <= 20'h0;
    else if(init_state == INIT_IDLE) 
       cnt_t500us <= 20'h0;
    else if(init_next_state == INIT_WAIT_CKE)
       cnt_t500us      <= cnt_t500us + 20'h1 ;
  end
  
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                                 
        cnt_cke_pass  <= 1'b0;
    else if((init_state == INIT_IDLE) & init_start)
        cnt_cke_pass  <= 1'b0; 
    else if(!cnt_cke_pass)
    begin
        if(|DDR_TYPE)
        cnt_cke_pass <= (cnt_t500us == T200US);
        else
        cnt_cke_pass <= (cnt_t500us == T500US);
    end
  end
    
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
         cnt_cmd       <= 8'h0;
      else
        case(init_next_state)                      
           INIT_PREA_WAIT,                 
           INIT_WAIT_ARF ,       
           INIT_WAIT_TXPR,
           INIT_WAIT_TMRD,
        INIT_MR_DDR2_WAIT,
           INIT_WAIT_TMOD:
                           cnt_cmd <= cnt_cmd +8'h1;

                 default:  cnt_cmd <= 8'h0;
        endcase
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
         cnt_txpr_pass  <= 1'b0;
      else
         cnt_txpr_pass  <= (cnt_cmd == txpr);
  end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
      if(!ddrphy_rst_n)                                 
         cnt_prea_pass  <= 1'b0;                        
      else                                              
         cnt_prea_pass  <= (cnt_cmd == TRP);
 end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)                                 
         cnt_arf_pass  <= 1'b0;                         
      else                                              
         cnt_arf_pass  <= (cnt_cmd == TRFC);
  end
         
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
      if(!ddrphy_rst_n) begin                           
         arf_cnt    <= 4'b0;                            
         arf_done   <= 1'b0;                            
      end                                               
      else if(init_state == INIT_ARF )begin             
         arf_cnt    <= arf_cnt + 4'b1;                  
         arf_done   <= (arf_cnt == REF_CNT - 4'b1);
      end 
 end        

                                                                                                                               
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)                                   
         cnt_tmrd_pass  <= 1'b0;                          
      else                                                
         cnt_tmrd_pass  <= (cnt_cmd == TMRD);
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
         cnt_tmod_pass  <= 1'b0;
      else
         cnt_tmod_pass  <= (cnt_cmd == TMOD);
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) begin
         mr_load_done   <= 1'b0;
         mr_load_cnt    <= 2'b0;
      end
      else if(init_next_state == INIT_IDLE) begin
         mr_load_done   <= 1'b0;
         mr_load_cnt    <= 2'b0;
      end
      else if(init_next_state == INIT_LOAD_MR)begin
        mr_load_cnt     <= mr_load_cnt + 2'b1;
        if(~DDR_TYPE[1])  
           mr_load_done    <= (mr_load_cnt == LOAD_DONE);
        else
           mr_load_done    <= (mr_load_cnt == LOAD_LP_DONE);
      end
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) begin
         ocd_cal_cnt   <= 2'b0;
         ocd_cal_done  <= 1'b0;
      end
      else if(init_state == INIT_IDLE)begin
         ocd_cal_cnt   <= 2'b0;
         ocd_cal_done  <= 1'b0;
     end
     else if(init_next_state == INIT_LOAD_MR_DDR2)begin
         ocd_cal_cnt   <= ocd_cal_cnt + 2'b01;
         ocd_cal_done  <= (ocd_cal_cnt[1]);
     end
  end

   always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
   begin
       if(!ddrphy_rst_n)  begin
          cnt_tzqinit        <= 10'h0;
          cnt_tzqinit_pass   <= 1'b0;
       end
       else if (init_next_state == INIT_WAIT_TZQINIT) begin
          cnt_tzqinit       <= cnt_tzqinit + 10'h1;
          cnt_tzqinit_pass  <= (cnt_tzqinit == TZQINIT);
      end
      else  begin
          cnt_tzqinit        <= 10'h0;
          cnt_tzqinit_pass   <= 1'b0;
      end
   end


  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
        init_state  <= INIT_IDLE ;
      else
        init_state  <= init_next_state ;
  end

generate
if (DDR_TYPE == 2'b00) begin    //DDR3
  always @(*) begin
      init_next_state = INIT_IDLE ;
    case(init_state)
         INIT_IDLE  :     if(init_start) 
                              init_next_state = INIT_WAIT_RESET;
                          else
                              init_next_state = INIT_IDLE;

         INIT_WAIT_RESET : if(cnt_pwron_pass)                    //ddr3 delay 200us    
                              init_next_state = INIT_WAIT_CKE;
                           else
                              init_next_state = INIT_WAIT_RESET;

         INIT_WAIT_CKE : begin
                           if(cnt_cke_pass)               //ddr3 delay 500us
                              init_next_state = INIT_WAIT_TXPR;
                           else
                              init_next_state = INIT_WAIT_CKE;
                         end

         INIT_WAIT_TXPR: begin                                   //ddr3
                           if(cnt_txpr_pass)                 //delay txpr        
                              init_next_state = INIT_LOAD_MR;
                           else
                              init_next_state = INIT_WAIT_TXPR;
                         end
                         
         INIT_LOAD_MR :  init_next_state  =  INIT_WAIT_TMRD;     //mr_load_cnt + 1

         INIT_WAIT_TMRD : if(mr_load_done)                       //mr_load_done = 1
                             init_next_state = INIT_WAIT_TMOD;
                          else if(cnt_tmrd_pass)                 //delay tmrd
                             init_next_state = INIT_LOAD_MR;
                          else
                             init_next_state = INIT_WAIT_TMRD;

         INIT_WAIT_TMOD: begin      
                           if(cnt_tmod_pass)              //delay tmod                                                                                                                                  
                             init_next_state = INIT_ZQCL ;
                           else
                             init_next_state = INIT_WAIT_TMOD;
                         end

         INIT_ZQCL :      init_next_state = INIT_WAIT_TZQINIT ;  //ddr3

         INIT_WAIT_TZQINIT : if(cnt_tzqinit_pass)                //delay tzqinit
                                init_next_state = INIT_DONE;
                             else
                                init_next_state = INIT_WAIT_TZQINIT;   
                                                                                                                                                                                                    
         INIT_DONE         :  init_next_state = INIT_IDLE ;
         
         default: init_next_state = INIT_IDLE ;

     endcase
  end
end

else if(DDR_TYPE == 2'b01) begin    //DDR2
  always @(*) begin
      init_next_state = INIT_IDLE ;
    case(init_state)
         INIT_IDLE  :     if(init_start)
                             init_next_state = INIT_WAIT_CKE;
                          else
                             init_next_state = INIT_IDLE;

         INIT_WAIT_CKE : begin
                           if(cnt_cke_pass)
                              init_next_state = INIT_WAIT_TXPR;
                           else
                              init_next_state = INIT_WAIT_CKE;
                         end

         INIT_WAIT_TXPR: begin
                           if(cnt_txpr_pass) 
                              init_next_state = INIT_PREA ;
                           else
                              init_next_state = INIT_WAIT_TXPR;
                         end
                         
             INIT_PREA:   init_next_state = INIT_PREA_WAIT;           
                         
         INIT_PREA_WAIT : begin
                            if(cnt_prea_pass)begin    
                               if(mr_load_done) 
                                  init_next_state = INIT_ARF;                 
                               else        
                                  init_next_state = INIT_LOAD_MR; 
                            end
                          else
                            init_next_state = INIT_PREA_WAIT ;
                          end
                       
        INIT_ARF     :  init_next_state = INIT_WAIT_ARF;  
        
        INIT_WAIT_ARF: begin 
                          if(cnt_arf_pass)begin
                             if(arf_done)
                               init_next_state = INIT_LOAD_MR_DDR2;
                             else
                               init_next_state = INIT_ARF;
                          end
                          else
                            init_next_state = INIT_WAIT_ARF;
                       end
                        
         INIT_LOAD_MR :  init_next_state  =  INIT_WAIT_TMRD;

         INIT_WAIT_TMRD : if(mr_load_done)
                             init_next_state = INIT_WAIT_TMOD;
                          else if(cnt_tmrd_pass)
                             init_next_state = INIT_LOAD_MR;
                          else
                             init_next_state = INIT_WAIT_TMRD;

         INIT_WAIT_TMOD: begin      
                           if(cnt_tmod_pass)
                             init_next_state = INIT_PREA;
                           else
                             init_next_state = INIT_WAIT_TMOD;
                         end
                                
         INIT_LOAD_MR_DDR2 :  init_next_state = INIT_MR_DDR2_WAIT ;

         INIT_MR_DDR2_WAIT : if(cnt_tmrd_pass) 
                                if(ocd_cal_done)
                                   init_next_state = INIT_DONE ;
                                else
                                   init_next_state = INIT_LOAD_MR_DDR2;
                             else
                                init_next_state = INIT_MR_DDR2_WAIT;
                                                                                                                                                                        
         INIT_DONE         :  init_next_state = INIT_IDLE ;
         
         default: init_next_state = INIT_IDLE ;

    endcase
  end    
end

else if(DDR_TYPE == 2'b10) begin    //LPDDR
  always @(*) begin
      init_next_state = INIT_IDLE ;
    case(init_state)
         INIT_IDLE  :     if(init_start)
                              init_next_state = INIT_WAIT_CKE;
                          else
                              init_next_state = INIT_IDLE;
         INIT_WAIT_CKE : begin
                           if(cnt_cke_pass)
                              init_next_state = INIT_PREA; 
                           else
                              init_next_state = INIT_WAIT_CKE;
                         end
                         
             INIT_PREA:   init_next_state = INIT_PREA_WAIT;           
                         
         INIT_PREA_WAIT : begin
                            if(cnt_prea_pass)begin    
//                               if(mr_load_done) 
                                  init_next_state = INIT_ARF;                  
//                               else
//                                  init_next_state = INIT_ARF;
                            end
                          else
                            init_next_state = INIT_PREA_WAIT ;
                          end
                       
        INIT_ARF     :  init_next_state = INIT_WAIT_ARF;  
        
        INIT_WAIT_ARF: begin 
                          if(cnt_arf_pass)begin
                             if(arf_done)
                               init_next_state = INIT_LOAD_MR;
                             else
                               init_next_state = INIT_ARF;
                          end
                          else
                            init_next_state = INIT_WAIT_ARF;
                        end
                        
         INIT_LOAD_MR :  init_next_state  =  INIT_WAIT_TMRD;

         INIT_WAIT_TMRD : if(mr_load_done)
                             init_next_state = INIT_WAIT_TMOD;
                          else if(cnt_tmrd_pass)
                             init_next_state = INIT_LOAD_MR;
                          else
                             init_next_state = INIT_WAIT_TMRD;

         INIT_WAIT_TMOD: begin      
                           if(cnt_tmod_pass)
                              init_next_state = INIT_DONE;
                           else
                             init_next_state = INIT_WAIT_TMOD;
                         end
                                                                                                                                                                        
         INIT_DONE         :  init_next_state = INIT_IDLE ;

     endcase
  end
end
endgenerate


  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
        init_done  <= 1'b0;
      else
        init_done  <= (init_next_state == INIT_DONE);
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
          init_rst  <= 1'b0;
      else
          init_rst  <= cnt_pwron_pass ;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
      begin
        if(DDR_TYPE == 2'b10)
        init_cke  <= 1'b1;
        else
        init_cke  <= 1'b0;
      end
      else if(DDR_TYPE == 2'b10)   //LPDDR
           init_cke  <= 1'b1;
      else
           init_cke  <=  cnt_cke_pass;
  end

  assign init_odt = 1'b0;

generate
if (DDR_TYPE == 2'b00) begin    //DDR3
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) begin
          init_ba       <= {MEM_BANKADDR_WIDTH{1'b0}};
          init_address  <= {MEM_ADDR_WIDTH{1'b0}};
          init_cs_n     <= 1'b1;
          init_ras_n    <= 1'b0;
          init_cas_n    <= 1'b0;
          init_we_n     <= 1'b0;
      end
      else  begin
        case(init_next_state)    
                                 
              INIT_LOAD_MR: begin                                                       //write MR
                                init_cs_n     <= 1'b0;
                                init_ras_n    <= 1'b0;
                                init_cas_n    <= 1'b0;
                                init_we_n     <= 1'b0;
                              case(mr_load_cnt)
                                  LOAD_MR2: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b10};
                                              init_address    <= mr2[MEM_ADDR_WIDTH-1:0];
                                            end

                                  LOAD_MR3: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b11};
                                              init_address    <= mr3[MEM_ADDR_WIDTH-1:0];
                                           end

                                  LOAD_MR1: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b01};
                                              init_address    <= mr1[MEM_ADDR_WIDTH-1:0];
                                            end

                                  LOAD_MR0: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b00};
                                              init_address    <= mr0[MEM_ADDR_WIDTH-1:0];
                                            end
                              endcase
                         end

                INIT_ZQCL :  begin                                                  //ZQ Calibration Long
                                init_cs_n        <= 1'b0;
                                init_ras_n       <= 1'b1;
                                init_cas_n       <= 1'b1;
                                init_we_n        <= 1'b0;
                                init_ba          <= {MEM_BANKADDR_WIDTH{1'b0}};
                                init_address     <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0};
                             end
                                                                                                                                                                                             
                default  :   begin
                                init_ba       <= {MEM_BANKADDR_WIDTH{1'b0}};
                                init_address  <= {MEM_ADDR_WIDTH{1'b0}};
                                init_cs_n     <= 1'b1;
                                init_ras_n    <= 1'b1;
                                init_cas_n    <= 1'b1;
                                init_we_n     <= 1'b1;
                             end
           endcase
        end
  end
end

else if(DDR_TYPE == 2'b01) begin    //DDR2
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) begin
          init_ba       <= {MEM_BANKADDR_WIDTH{1'b0}};
          init_address  <= {MEM_ADDR_WIDTH{1'b0}};
          init_cs_n     <= 1'b1;
          init_ras_n    <= 1'b0;
          init_cas_n    <= 1'b0;
          init_we_n     <= 1'b0;
      end
      else  begin
        case(init_next_state)    
                INIT_PREA : begin
                              init_cs_n        <= 1'b0;   
                              init_ras_n       <= 1'b0;  
                              init_cas_n       <= 1'b1;  
                              init_we_n        <= 1'b0; 
                              init_ba          <= {MEM_BANKADDR_WIDTH{1'b0}};
                              init_address     <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0};
                            end   
                INIT_ARF  : begin
                               init_cs_n        <= 1'b0;                
                               init_ras_n       <= 1'b0;    
                               init_cas_n       <= 1'b0;    
                               init_we_n        <= 1'b1; 
                               init_ba          <= {MEM_BANKADDR_WIDTH{1'b0}};
                               init_address     <= {MEM_ADDR_WIDTH{1'b0}};
                            end                                                          
              INIT_LOAD_MR: begin                                                       //write MR
                                init_cs_n     <= 1'b0;
                                init_ras_n    <= 1'b0;
                                init_cas_n    <= 1'b0;
                                init_we_n     <= 1'b0;
                              case(mr_load_cnt)
                                  LOAD_MR2: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b10};
                                              init_address    <= mr2[MEM_ADDR_WIDTH-1:0];
                                            end

                                  LOAD_MR3: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b11};
                                              init_address    <= mr3[MEM_ADDR_WIDTH-1:0];
                                           end

                                  LOAD_MR1: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b01};
                                              init_address    <= mr1[MEM_ADDR_WIDTH-1:0];
                                            end

                                  LOAD_MR0: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b00};
                                              init_address    <= mr0[MEM_ADDR_WIDTH-1:0];
                                            end
                              endcase
                         end
         INIT_LOAD_MR_DDR2 : begin
                               init_cs_n       <= 1'b0; 
                               init_ras_n      <= 1'b0; 
                               init_cas_n      <= 1'b0; 
                               init_we_n       <= 1'b0;
                               case(ocd_cal_cnt)
                                    2'b00 :  begin
                                               init_ba[1:0]    <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b00};   
                                               init_address    <= {mr0[MEM_ADDR_WIDTH-1:9],1'b0,mr0[7:0]};   
                                             end
                                     
                                    2'b01 : begin
                                               init_ba[1:0]    <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b01}; 
                                               init_address    <= {mr1[MEM_ADDR_WIDTH-1:10],3'b111,mr1[6:0]}; 
                                            end
                                     
                                    2'b10 : begin
                                               init_ba[1:0]    <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b01}; 
                                               init_address    <= {mr1[MEM_ADDR_WIDTH-1:10],3'b000,mr1[6:0]};
                                            end 
                               endcase
                             end                         
                                                                                                                                                                                             
                default  :   begin
                                init_ba       <= {MEM_BANKADDR_WIDTH{1'b0}};
                                init_address  <= {MEM_ADDR_WIDTH{1'b0}};
                                init_cs_n     <= 1'b1;
                                init_ras_n    <= 1'b1;
                                init_cas_n    <= 1'b1;
                                init_we_n     <= 1'b1;
                             end
           endcase
        end
  end    
end

else if(DDR_TYPE == 2'b10) begin    //LPDDR
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) begin
          init_ba       <= {MEM_BANKADDR_WIDTH{1'b0}};
          init_address  <= {MEM_ADDR_WIDTH{1'b0}};
          init_cs_n     <= 1'b1;
          init_ras_n    <= 1'b0;
          init_cas_n    <= 1'b0;
          init_we_n     <= 1'b0;
      end
      else  begin
        case(init_next_state)    
                INIT_PREA : begin
                              init_cs_n        <= 1'b0;   
                              init_ras_n       <= 1'b0;  
                              init_cas_n       <= 1'b1;  
                              init_we_n        <= 1'b0; 
                              init_ba          <= {MEM_BANKADDR_WIDTH{1'b0}};
                              init_address     <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0};
                            end   
                INIT_ARF  : begin
                               init_cs_n        <= 1'b0;                
                               init_ras_n       <= 1'b0;    
                               init_cas_n       <= 1'b0;    
                               init_we_n        <= 1'b1; 
                               init_ba          <= {MEM_BANKADDR_WIDTH{1'b0}};
                               init_address     <= {MEM_ADDR_WIDTH{1'b0}};
                            end                                                          
              INIT_LOAD_MR: begin                                                       //write MR
                                init_cs_n     <= 1'b0;
                                init_ras_n    <= 1'b0;
                                init_cas_n    <= 1'b0;
                                init_we_n     <= 1'b0;
                              case(mr_load_cnt)
                                  LOAD_MR2: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b00};
                                              init_address    <= mr0[MEM_ADDR_WIDTH-1:0];
                                            end

                                  LOAD_MR3: begin
                                              init_ba         <= {{(MEM_BANKADDR_WIDTH-2){1'b0}},2'b10};
                                              init_address    <= mr2[MEM_ADDR_WIDTH-1:0];
                                           end
                              endcase
                         end
                                                                                                                                                                                             
                default  :   begin
                                init_ba       <= {MEM_BANKADDR_WIDTH{1'b0}};
                                init_address  <= {MEM_ADDR_WIDTH{1'b0}};
                                init_cs_n     <= 1'b1;
                                init_ras_n    <= 1'b1;
                                init_cas_n    <= 1'b1;
                                init_we_n     <= 1'b1;
                             end
           endcase
        end
  end    
end
endgenerate
        
 assign  dbg_init = init_state;

endmodule






////////////////////////////////////////////////////////////////       
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                          
// ALL RIGHTS REVERVED.                                                
////////////////////////////////////////////////////////////////       
//Description:                                                         
//Author: wxxiao                                                      
//History: v1.0                                                        
//////////////////////////////////////////////////////////////// 
`timescale 1ns/10ps  
module   ips2l_ddrphy_info_v1_0 #(
  parameter [1:0]   DDR_TYPE     = 2'b00    ,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR
  parameter MEM_ADDR_WIDTH       = 16       ,
  parameter MEM_BANKADDR_WIDTH   = 3        ,
  parameter [15:0]  MR0_DDR3     = 16'd0    ,
  parameter [15:0]  MR1_DDR3     = 16'd0    ,
  parameter [15:0]  MR2_DDR3     = 16'd0    ,
  parameter [15:0]  MR3_DDR3     = 16'd0    ,
  parameter [15:0]  MR_DDR2      = 16'd0    ,
  parameter [15:0]  EMR1_DDR2    = 16'd0    ,
  parameter [15:0]  EMR2_DDR2    = 16'd0    ,
  parameter [15:0]  EMR3_DDR2    = 16'd0    ,
  parameter [15:0]  MR_LPDDR     = 16'd0    ,
  parameter [15:0]  EMR_LPDDR    = 16'd0    
)(
   input               ddrphy_sysclk,
   input               ddrphy_rst_n ,
   input               calib_done   ,
   input [4*MEM_ADDR_WIDTH-1:0]     phy_addr    ,
   input [4*MEM_BANKADDR_WIDTH-1:0] phy_ba      ,
   input [3:0]         phy_cs_n    ,
   input [3:0]         phy_cas_n   ,
   input [3:0]         phy_ras_n   ,
   input [3:0]         phy_we_n    ,
   input [3:0]         phy_cke     ,
   output [4:0]        mc_rl       ,
   output [4:0]        mc_wl       ,
   output reg [15:0]   mr0         ,
   output reg [15:0]   mr1         ,
   output reg [15:0]   mr2         ,
   output reg [15:0]   mr3        
  );
  
  wire [3:0] phy_mrs_0 ;
  wire [3:0] phy_mrs_1 ;
  wire [3:0] phy_mrs_2 ;
  wire [3:0] phy_mrs_3 ;
  wire [1:0] ddr3_mr_al;
  wire [2:0] ddr3_mr_cwl;
  wire [3:0] ddr3_mr_cl;
  reg  [3:0] ddr3_mc_cl;
  reg  [3:0] ddr3_mc_al;
  reg  [3:0] ddr3_mc_cwl;
  wire [2:0] ddr2_mc_al ;
  wire [2:0] ddr2_mc_cl ;
  wire [2:0] lpddr_mc_cl;

  assign  phy_mrs_0  = {phy_cs_n[0],phy_cas_n[0],phy_ras_n[0],phy_we_n[0]} ;
  assign  phy_mrs_1  = {phy_cs_n[1],phy_cas_n[1],phy_ras_n[1],phy_we_n[1]} ;
  assign  phy_mrs_2  = {phy_cs_n[2],phy_cas_n[2],phy_ras_n[2],phy_we_n[2]} ;
  assign  phy_mrs_3  = {phy_cs_n[3],phy_cas_n[3],phy_ras_n[3],phy_we_n[3]} ;
    
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n) 
 begin    
    if(!ddrphy_rst_n) begin
        if(DDR_TYPE == 2'b00)    //DDR3
        begin
            mr0  <= MR0_DDR3;
            mr1  <= MR1_DDR3;
            mr2  <= MR2_DDR3;
            mr3  <= MR3_DDR3;
        end
        else if(DDR_TYPE == 2'b01)    //DDR2
        begin
            mr0  <= MR_DDR2;
            mr1  <= EMR1_DDR2;
            mr2  <= EMR2_DDR2;
            mr3  <= EMR3_DDR2;
        end
        else if(DDR_TYPE == 2'b10)    //LPDDR
        begin
            mr0  <= MR_LPDDR;
            mr1  <= 16'd0;
            mr2  <= EMR_LPDDR;
            mr3  <= 16'd0;
        end
    end
    else if((phy_cke == 4'b1111)&&(calib_done == 1)) begin
            if(~|phy_mrs_0) begin 
                 case(phy_ba[1:0])
                      2'b00: mr0 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[MEM_ADDR_WIDTH-1:0]};
    
                      2'b01: mr1 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[MEM_ADDR_WIDTH-1:0]};

                      2'b10: mr2 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[MEM_ADDR_WIDTH-1:0]};

                      2'b11: mr3 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[MEM_ADDR_WIDTH-1:0]};
                 endcase
               end
             else if(~|phy_mrs_1) begin
                   case(phy_ba[MEM_BANKADDR_WIDTH+1:MEM_BANKADDR_WIDTH])
                        2'b00: mr0 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[2*MEM_ADDR_WIDTH-1:MEM_ADDR_WIDTH]};
    
                        2'b01: mr1 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[2*MEM_ADDR_WIDTH-1:MEM_ADDR_WIDTH]};

                        2'b10: mr2 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[2*MEM_ADDR_WIDTH-1:MEM_ADDR_WIDTH]};

                        2'b11: mr3 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[2*MEM_ADDR_WIDTH-1:MEM_ADDR_WIDTH]};
                    endcase
            end
            else if(~|phy_mrs_2) begin
                   case(phy_ba[2*MEM_BANKADDR_WIDTH+1:2*MEM_BANKADDR_WIDTH])
                        2'b00: mr0 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[3*MEM_ADDR_WIDTH-1:2*MEM_ADDR_WIDTH]};
    
                        2'b01: mr1 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[3*MEM_ADDR_WIDTH-1:2*MEM_ADDR_WIDTH]};

                        2'b10: mr2 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[3*MEM_ADDR_WIDTH-1:2*MEM_ADDR_WIDTH]};

                        2'b11: mr3 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[3*MEM_ADDR_WIDTH-1:2*MEM_ADDR_WIDTH]};
                    endcase                
            end
            else if(~|phy_mrs_3) begin
                   case(phy_ba[3*MEM_BANKADDR_WIDTH+1:3*MEM_BANKADDR_WIDTH])
                        2'b00: mr0 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[4*MEM_ADDR_WIDTH-1:3*MEM_ADDR_WIDTH]};
    
                        2'b01: mr1 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[4*MEM_ADDR_WIDTH-1:3*MEM_ADDR_WIDTH]};

                        2'b10: mr2 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[4*MEM_ADDR_WIDTH-1:3*MEM_ADDR_WIDTH]};

                        2'b11: mr3 <= {{(16-MEM_ADDR_WIDTH){1'b0}},phy_addr[4*MEM_ADDR_WIDTH-1:3*MEM_ADDR_WIDTH]};
                    endcase                
            end
    end
 end

  assign  ddr3_mr_al   = mr1[4:3];
  assign  ddr3_mr_cwl  = mr2[5:3];
  assign  ddr3_mr_cl   = {mr0[6:4],mr0[2]};
  
  assign  ddr2_mc_al = mr1[5:3];
  assign  ddr2_mc_cl = mr0[6:4];
  
  assign  lpddr_mc_cl = mr0[6:4];

  always @(*) 
  begin    
     case(ddr3_mr_cl)  
         4'b0010 :  ddr3_mc_cl = 4'b0101;
         4'b0100 :  ddr3_mc_cl = 4'b0110;
         4'b0110 :  ddr3_mc_cl = 4'b0111;
         4'b1000 :  ddr3_mc_cl = 4'b1000;
         4'b1010 :  ddr3_mc_cl = 4'b1001;
         4'b1100 :  ddr3_mc_cl = 4'b1010;
        default  :  ddr3_mc_cl = 4'b0000;
     endcase                             
  end                                    

  always @(*) 
  begin                       
     case(ddr3_mr_al)                     
         2'b00 :  ddr3_mc_al = 4'b0000;   
         2'b01 :  ddr3_mc_al = ddr3_mc_cl - 4'b01;
         2'b10 :  ddr3_mc_al = ddr3_mc_cl - 4'b10;
      default  :  ddr3_mc_al  = 4'b0000; 
     endcase                               
  end  
   
  always @(*)
  begin
         case(ddr3_mr_cwl)
              3'b000: ddr3_mc_cwl = 4'd5;
              3'b001: ddr3_mc_cwl = 4'd6;
              3'b010: ddr3_mc_cwl = 4'd7;
              3'b011: ddr3_mc_cwl = 4'd8;
             default: ddr3_mc_cwl = 4'd5;
         endcase
     end
              
  assign  mc_rl  = (DDR_TYPE == 2'b00) ? ({1'b0,ddr3_mc_al} + {1'b0,ddr3_mc_cl}) :
                   (DDR_TYPE == 2'b01) ? ({2'b00,ddr2_mc_al} + {2'b00,ddr2_mc_cl}) :
                   (DDR_TYPE == 2'b10) ? {2'b00,lpddr_mc_cl} : 5'h0;
                    
  assign  mc_wl  = (DDR_TYPE == 2'b00) ? ({1'b0,ddr3_mc_al} + {1'b0,ddr3_mc_cwl}) :
                   (DDR_TYPE == 2'b01) ? ({2'b00,ddr2_mc_al} + {2'b00,ddr2_mc_cl} - 5'h1) :
                   (DDR_TYPE == 2'b10) ? 5'h1 : 5'h0;

endmodule   




////////////////////////////////////////////////////////////////          
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                             
// ALL RIGHTS REVERVED.                                                   
////////////////////////////////////////////////////////////////          
//Description:                                                            
//Author:  wxxiao                                                         
//History: v1.0                                                           
////////////////////////////////////////////////////////////////          
`timescale 1ns/1ps                                                        
module ips2l_ddrphy_gatecal_v1_0 #(
    parameter  GATE_MODE       =  0
)(
    input [2:0]      init_read_clk_ctrl   ,
    input [3:0]      init_slip_step       ,
    input            force_read_clk_ctrl  ,

    input            ddrphy_sysclk        ,
    input            ddrphy_rst_n         ,
    input [1:0]      comp_val             ,
    input            comp_dir             ,
    input            dqs_gate_comp_en     ,
    output reg       dqs_gate_comp_done   ,

    input            gatecal_start        ,
    output reg       gate_check_pass      ,
    output reg       gate_adj_done        ,
    output reg       gate_cal_error       ,
    input            dqs_gate_vld         ,
    input            gate_move_en         ,

    output [3:0]     coarse_slip_step     ,
    output [2:0]     read_clk_ctrl        ,
    output reg [3:0] gate_win_size        ,
    input            ddrphy_dgts          ,
    input            dqs_gate_sample  
   );  

  localparam GATECAL_IDLE       = 0;
  localparam GATECAL_LOAD_INIT  = 1;
  localparam GATECAL_JUDGE      = 2;
  localparam GATECAL_WAIT       = 3;
  localparam GATECAL_DONE       = 4;
  localparam GATECAL_ERROR      = 5;

  reg [2:0]  gate_state        ;
  reg [2:0]  gate_state_next   ;
  reg [6:0]  gate_value        ;
  reg [6:0]  golden_value      ;
  reg [3:0]  dgts_cnt          ;
  reg [2:0]  ddrphy_dgts_r     ;
  reg        dqs_gate_vld_r    ;
  reg        dgts_vld          ;
  reg [2:0]  dgts_vld_cnt      ;
  wire       dqs_gate_vld_n    ;
  wire       sync_dgts         ;
  wire       ddrphy_dgts_p     ;
  reg        dgts_latch        ; 
//  reg [3:0]  valid_cnt         ;
  reg [2:0]  dqs_gate_sample_r ;
  reg        sample_done       ;
  reg [8:0]  sample_reg        ;
  reg        dqs_gate_comp_en_r;
  wire       dqs_gate_comp_en_p;
  wire       sync_gate_sample  ;
  wire       gate_sample_p     ;

  assign  coarse_slip_step = gate_value[6:3];
  assign  read_clk_ctrl    = {gate_value[2:0]};

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n)
           gate_state    <=  GATECAL_IDLE ;
      else
           gate_state    <=  gate_state_next ;
  end

   always @ (*) 
   begin
          gate_state_next  = GATECAL_IDLE;
        case(gate_state) 
            GATECAL_IDLE :  begin
                               if(gatecal_start)
                                  gate_state_next = GATECAL_LOAD_INIT;
                               else
                                 gate_state_next = GATECAL_IDLE;
                            end

        GATECAL_LOAD_INIT : begin
                                 gate_state_next = GATECAL_JUDGE ;
                           end
          
          GATECAL_JUDGE  : begin
                              if(dqs_gate_vld_n) begin
                                if(GATE_MODE == 0) begin
                                    if(dgts_cnt == 4'd6)
                                         gate_state_next = GATECAL_DONE ;
                                    else if(gate_value[6]) begin
                                         if(dgts_cnt > 4'd4) 
                                            gate_state_next = GATECAL_DONE;
                                         else 
                                            gate_state_next = GATECAL_ERROR;
                                    end
                                    else
                                     gate_state_next = GATECAL_WAIT;
                                end
                                else if(GATE_MODE == 1) begin
                                    if(sample_done)
                                    gate_state_next = GATECAL_DONE ;
                                    else if(gate_value[6])
                                    gate_state_next = GATECAL_ERROR;
                                    else
                                    gate_state_next = GATECAL_WAIT;
                                end
                              end
                              else
                                 gate_state_next = GATECAL_JUDGE ;
                          end

          GATECAL_WAIT  :  begin
                              if(gate_move_en)
                                  gate_state_next = GATECAL_JUDGE;
                              else 
                                  gate_state_next = GATECAL_WAIT;
                            end

          GATECAL_DONE  :  begin
                              if(~gatecal_start)
                                 gate_state_next = GATECAL_IDLE ;
                              else
                                 gate_state_next = GATECAL_DONE ;
                           end

          GATECAL_ERROR : gate_state_next =  GATECAL_ERROR ;

          endcase
   end
   
//
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                                  
        dqs_gate_vld_r  <= 1'b0; 
     else
        dqs_gate_vld_r  <= dqs_gate_vld;
  end

  assign dqs_gate_vld_n  = ~dqs_gate_vld & dqs_gate_vld_r;

   always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
   begin
      if(!ddrphy_rst_n)
          gate_adj_done    <=  1'b0 ;
      else if (gate_move_en | (gate_state_next == GATECAL_IDLE))
          gate_adj_done    <=  1'b0;
      else if (dqs_gate_vld_n) 
          gate_adj_done    <=  1'b1;
  end

   always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
   begin
      if(!ddrphy_rst_n)
         gate_cal_error  <=  1'b0 ;
      else if (gate_state_next == GATECAL_ERROR)
        gate_cal_error   <= 1'b1;
   end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n) 
        gate_value   <=  7'h0 ;
    else  if(force_read_clk_ctrl)
            gate_value   <= {init_slip_step,init_read_clk_ctrl};
          else if(gate_state_next == GATECAL_LOAD_INIT)
            gate_value   <= {init_slip_step,init_read_clk_ctrl};
          else if(gate_state_next == GATECAL_IDLE)
          begin
            if(golden_value[2:0] == 3'b111)
            gate_value  <= golden_value + 7'h1;
            else
            gate_value  <= golden_value;
          end
          else if(gate_move_en) 
            gate_value   <= gate_value + 7'h1;
  end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n)   
        ddrphy_dgts_r  <=  3'b000;
    else 
        ddrphy_dgts_r  <= {ddrphy_dgts_r[1:0],ddrphy_dgts};
 end

  assign  sync_dgts     = ddrphy_dgts_r[2];
  assign  ddrphy_dgts_p = (ddrphy_dgts_r[2:1] == 2'b01);

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n) 
        dgts_latch   <= 1'b0;
    else if(gate_state_next == GATECAL_JUDGE) begin
            if(ddrphy_dgts_p)
               dgts_latch   <= 1'b1;
    end
    else
        dgts_latch   <= 1'b0;
 end


 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n) 
     dqs_gate_comp_en_r <= 1'b0;
    else
     dqs_gate_comp_en_r <= dqs_gate_comp_en;
 end
 
 assign dqs_gate_comp_en_p = ((~dqs_gate_comp_en_r) & dqs_gate_comp_en);

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n) 
     dqs_gate_comp_done <= 1'b0;
    else
      if (dqs_gate_comp_en)
        dqs_gate_comp_done <= 1'b1;
      else if(dqs_gate_comp_en==0)
        dqs_gate_comp_done <= 1'b0;
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n) 
       golden_value    <= 7'h0 ;
    else if ((gate_state_next == GATECAL_IDLE) & gatecal_start)
        golden_value    <= 7'h0 ;
    else if ((dgts_cnt > 4'h3) & (dgts_vld) & (~GATE_MODE))
        golden_value    <= gate_value - {4'd0,dgts_cnt[3:1]};
    else if (sample_done & dqs_gate_vld_n & GATE_MODE)
        golden_value    <= gate_value - 7'd8;
    else if(dqs_gate_comp_en_p)
        begin
          if(comp_dir)
           golden_value <= golden_value + comp_val;
          else
           golden_value <= golden_value - comp_val;
        end
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n) 
         dgts_vld_cnt   <= 3'b0;
    else if ((gate_state_next == GATECAL_JUDGE) & ddrphy_dgts_r[1] & dgts_latch )
    begin
       if(dgts_vld_cnt < 3'b111)
       dgts_vld_cnt   <= dgts_vld_cnt + 3'b1;
    end 
    else
         dgts_vld_cnt   <= 3'b0;
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n) 
         dgts_vld    <= 1'b0;
    else if(dgts_vld_cnt == 3'b101)
         dgts_vld    <= 1'b1;
    else
         dgts_vld    <= 1'b0;
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n)
       dgts_cnt   <=  4'h0 ;
    else if (gate_state_next == GATECAL_IDLE)
       dgts_cnt   <= 4'h0;
    else if (dgts_vld & (~sync_gate_sample)) 
       dgts_cnt    <= dgts_cnt + 4'h1;
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n)
       gate_check_pass   <= 1'b0;
    else if(gate_state_next == GATECAL_IDLE)
       gate_check_pass   <= 1'b0;
    else if(gate_state_next == GATECAL_DONE)
       gate_check_pass   <= 1'b1;
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
      if(!ddrphy_rst_n)
         gate_win_size   <= 4'b0;
      else
        begin
          if (gatecal_start)
              if (gate_check_pass)
               gate_win_size <= dgts_cnt; 
              else
                gate_win_size <= 4'b000;
        end
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n)   
        dqs_gate_sample_r  <=  3'b000;
    else 
        dqs_gate_sample_r  <= {dqs_gate_sample_r[1:0],dqs_gate_sample};
 end
 
 assign  sync_gate_sample = dqs_gate_sample_r[2];
 assign  gate_sample_p = (dqs_gate_sample_r[2:1] == 2'b01);


 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin       
    if(!ddrphy_rst_n) 
    sample_reg <= 9'b101010101;
    else if (gate_state_next == GATECAL_IDLE)
    sample_reg <= 9'b101010101;
    else if(dqs_gate_vld_n)
    sample_reg  <= {sample_reg[7:0],sync_gate_sample};
 end
 
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin       
    if(!ddrphy_rst_n) 
    sample_done <= 0;
    else if (gate_state_next == GATECAL_IDLE)
    sample_done <= 0;
    else if(sample_reg == 9'b000000111)
    sample_done <= 1;
 end

endmodule




////////////////////////////////////////////////////////////////       
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                          
// ALL RIGHTS REVERVED.                                                
////////////////////////////////////////////////////////////////       
//Description:                                                         
//Author: wxxiao                                                      
//History: v1.0                                                        
//////////////////////////////////////////////////////////////// 
`timescale 1ns/10ps  
module ips2l_ddrphy_gate_update_ctrl_v1_0 #(
  parameter        UPDATE_EN           = 1,
  parameter        MEM_DQS_WIDTH       = 2
)(
  input                        ddrphy_sysclk          ,
  input                        ddrphy_rst_n           ,
  input                        calib_done             ,
  input [2*MEM_DQS_WIDTH-1:0]  dqs_drift              ,
  input                        ddrphy_update_done     ,
  output reg                   update_start           ,
  output [2*MEM_DQS_WIDTH-1:0] ddrphy_update_comp_val ,
  output [MEM_DQS_WIDTH-1:0]   ddrphy_update_comp_dir 
);


`ifdef SIMULATION 
localparam TIME_1S = 32'd1000;
`else                      
localparam TIME_1S = 32'd100000000;
`endif

reg [31:0] gate_update_cnt;
reg ddrphy_update_req;
wire update_flag;

assign update_flag = |ddrphy_update_comp_val;

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n)
   gate_update_cnt <= 32'd0;
   else if(calib_done)
   begin
    if(gate_update_cnt == TIME_1S)
    begin
       if((update_flag == 0)||(ddrphy_update_done))
       gate_update_cnt <= 32'd0;
       else
       gate_update_cnt <= gate_update_cnt;
    end
    else
    gate_update_cnt <= gate_update_cnt + 32'd1;
   end
   else
   gate_update_cnt <= 32'd0;
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n)
   update_start <= 0;
   else if((calib_done)&(UPDATE_EN))
   begin
      if((gate_update_cnt == TIME_1S)&&(update_flag == 1))
      update_start <= 1;
      else
      update_start <= 0;
   end
   else
   update_start <= 0;
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n)
   ddrphy_update_req <= 0;
   else if((calib_done)&(UPDATE_EN))
   begin
      if(gate_update_cnt == TIME_1S - 32'd10)
      ddrphy_update_req <= 1;
      else
      ddrphy_update_req <= 0;
   end
   else
   ddrphy_update_req <= 0;
end


genvar gen_i;                                                             
generate                                                                  
   for(gen_i=0; gen_i<MEM_DQS_WIDTH; gen_i=gen_i+1) begin   : dqift_dqs_group 

   ips2l_ddrphy_drift_ctrl_v1_0 ddrphy_drift_ctrl
   (
     .ddrphy_sysclk           (ddrphy_sysclk           ),
     .ddrphy_rst_n            (ddrphy_rst_n            ),
     .calib_done              (calib_done              ),
     .dqs_drift               (dqs_drift[2*gen_i+1:2*gen_i]),
     .ddrphy_update_req       (ddrphy_update_req       ),
     .ddrphy_update_done      (ddrphy_update_done      ),
     .ddrphy_update_comp_val  (ddrphy_update_comp_val[2*gen_i+1:2*gen_i]),
     .ddrphy_update_comp_dir  (ddrphy_update_comp_dir[gen_i]  )
   );
  end     
endgenerate

endmodule




////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_eyecal_v1_0 #(
  parameter [7:0]   TRFC           = 8'd16,
  parameter [7:0]   TRCD           = 8'd2 ,
  parameter MEM_ADDR_WIDTH         = 16   ,
  parameter MEM_BANKADDR_WIDTH     = 3    ,
  parameter MEM_DQ_WIDTH           = 16   
)(
   input          ddrphy_sysclk      ,
   input          ddrphy_rst_n       ,

   input          eyecal_start       ,
   output reg     eyecal_done        ,
   output reg     eye_calibration    ,
   input          eyecal_check_pass  ,
   input          eyecal_move_done   ,
   output reg     eyecal_move_en     ,

   output reg [MEM_BANKADDR_WIDTH-1:0]  eyecal_ba          ,
   output reg [MEM_ADDR_WIDTH-1:0]      eyecal_address     ,
   output reg eyecal_cs_n        ,
   output reg eyecal_ras_n       ,
   output reg eyecal_cas_n       ,
   output reg eyecal_we_n        ,
   output reg eyecal_cke         ,
   output     eyecal_odt         ,
   output [3:0]  dbg_eyecal        
);

  localparam EYECAL_IDLE       = 0;
  localparam EYECAL_REFRESH    = 1;
  localparam EYECAL_REF_WAIT   = 2;
  localparam EYECAL_ACT        = 3;
  localparam EYECAL_RD         = 4;
  localparam EYECAL_RD_WAIT    = 5;
  localparam EYECAL_RD_CHECK   = 6;
  localparam EYECAL_PRE        = 7;
  localparam EYECAL_DONE       = 8;

  reg [7:0]     cnt;
  reg [3:0]     eyecal_state;
  reg           cnt_trfc_pass;
  reg           ref_cnt_done;
  reg [1:0]     ref_cnt;


//refresh
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
          cnt_trfc_pass  <= 1'b0;
     else
         cnt_trfc_pass   <= (TRFC == cnt[7:0]);
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)  begin
          ref_cnt_done  <= 1'b0;
          ref_cnt       <= 2'b0;
     end
     else if(eyecal_state == EYECAL_REFRESH) begin
         ref_cnt       <= ref_cnt + 2'b1;
         ref_cnt_done  <= (&ref_cnt);                   //refresh 4
     end
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if (!ddrphy_rst_n) begin
         eyecal_state       <= EYECAL_IDLE;
         cnt                <= 0;
      end
      else 
      begin
         case (eyecal_state)
            EYECAL_IDLE: begin
                           cnt <= 0;
                           if (eyecal_start)
                           eyecal_state <= EYECAL_REFRESH;
                         end

          EYECAL_REFRESH: begin                                   //refresh
                                cnt          <= 0;
                                eyecal_state <= EYECAL_REF_WAIT;
                         end

         EYECAL_REF_WAIT: begin
                              if(cnt_trfc_pass) begin            //delay trfc
                                 if(ref_cnt_done)  begin         //refresh 4
                                     eyecal_state   <= EYECAL_ACT ;
                                     cnt            <= 0;
                                 end
                                 else
                                     eyecal_state   <= EYECAL_REFRESH;
                              end
                              else
                                      cnt          <= cnt + 1'b1;
                            end
                            
               EYECAL_ACT : begin                                 //active bank 0 row 0
                              if(cnt == TRCD) begin
                                   eyecal_state   <= EYECAL_RD;
                                   cnt            <= 'b0;
                               end
                               else
                                   cnt           <= cnt + 1'b1;
                            end
                            
                 EYECAL_RD : begin
                              if(cnt[2]) begin
                                cnt <= 'b0;
                                eyecal_state <= EYECAL_RD_WAIT;
                              end
                              else
                                cnt  <= cnt + 1'b1;
                            end
                            
             EYECAL_RD_WAIT : begin
                               if(cnt[4]) begin
                                 cnt <= 'b0;
                                 eyecal_state <= EYECAL_RD_CHECK;
                               end
                               else
                                 cnt  <= cnt + 1'b1;
                             end
                             
              EYECAL_RD_CHECK : begin
                                 if(eyecal_check_pass) begin
                                    eyecal_state <= EYECAL_PRE;
                                    cnt <= 'b0;
                                 end
                                 else if(eyecal_move_done) begin
                                    eyecal_state <= EYECAL_RD;
                                    cnt <= 'b0;
                                 end
                                 else if (~cnt[5]) 
                                   cnt <= cnt + 1;
                               end
                               
                   EYECAL_PRE : begin
                                 if(cnt[4]) begin
                                   cnt <= 'b0;
                                   eyecal_state <= EYECAL_DONE;
                                   end
                                else
                                   cnt  <= cnt + 1'b1;
                               end                 
                               
                  EYECAL_DONE : begin
                                 cnt  <=  cnt + 1'b1;
                                 if(cnt[3]) begin
                                    eyecal_state <= EYECAL_IDLE;
                                    cnt         <= 'h0;
                                 end
                               end
                               
                       default: begin  
                                eyecal_state <= EYECAL_IDLE;
                       end
                       
                    endcase
      end
  end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
   if (!ddrphy_rst_n)
       eyecal_done   <=  1'b0;
   else if(eyecal_state == EYECAL_DONE)
   begin
       if(cnt[2:0]==3'b111)
       eyecal_done   <=  1'b1;    
   end
   else
       eyecal_done   <=  1'b0;
 end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if (!ddrphy_rst_n) begin
       eye_calibration  <= 1'b0;
       eyecal_move_en   <= 1'b0;
    end
    else begin
       eye_calibration <= (eyecal_state != EYECAL_IDLE);
       eyecal_move_en  <= (eyecal_state == EYECAL_RD_CHECK) && cnt[5];
    end
 end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n) begin
        eyecal_cs_n       <= 1'b1;
        eyecal_ras_n      <= 1'b0;
        eyecal_cas_n      <= 1'b0;
        eyecal_we_n       <= 1'b0;
        eyecal_ba         <= {MEM_BANKADDR_WIDTH{1'b0}};
        eyecal_address    <= {MEM_ADDR_WIDTH{1'b0}};
     end
     else  begin
        eyecal_cs_n       <= 1'b1;
        eyecal_ras_n      <= 1'b1;
        eyecal_cas_n      <= 1'b1;
        eyecal_we_n       <= 1'b1;
        eyecal_ba         <= {MEM_BANKADDR_WIDTH{1'b0}};
        eyecal_address    <= {MEM_ADDR_WIDTH{1'b0}};
        case(eyecal_state)
           EYECAL_REFRESH : begin //ref
                             eyecal_cs_n       <= 1'b0;
                             eyecal_ras_n      <= 1'b0;
                             eyecal_cas_n      <= 1'b0;
                             eyecal_we_n       <= 1'b1;
                           end

             EYECAL_ACT : begin //act
                           if(~|cnt)begin     //cnt = 0
                             eyecal_cs_n       <= 1'b0;
                             eyecal_ras_n      <= 1'b0;
                             eyecal_cas_n      <= 1'b1;
                             eyecal_we_n       <= 1'b1;
                           end
                         end

              EYECAL_RD : begin
                          if(cnt[4:0] < 5'd4) begin
                               eyecal_cs_n            <= 1'b0;
                               eyecal_ras_n           <= 1'b1;
                               eyecal_cas_n           <= 1'b0;
                               eyecal_we_n            <= 1'b1;
                               eyecal_address         <= {{(MEM_ADDR_WIDTH-5){1'b0}},cnt[1:0],3'b000};
                           end
                         end
                                                                     
              EYECAL_PRE: begin                                                   
                            if(cnt== 8'd4) begin                     
                                eyecal_cs_n          <= 1'b0 ;           
                                eyecal_ras_n         <= 1'b0 ;           
                                eyecal_cas_n         <= 1'b1 ;           
                                eyecal_we_n          <= 1'b0 ;         
                                eyecal_address       <= {{(MEM_ADDR_WIDTH-11){1'b0}},1'b1,10'h0};           
                             end                                        
                         end 
                            
          endcase
     end
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n)
        eyecal_cke   <= 1'b0;
     else
        eyecal_cke   <= 1'b1;
  end

 assign eyecal_odt = 1'b0;     

 assign dbg_eyecal = eyecal_state;       

endmodule




////////////////////////////////////////////////////////////////       
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                          
// ALL RIGHTS REVERVED.                                                
////////////////////////////////////////////////////////////////       
//Description:                                                         
//Author: wxxiao                                                      
//History: v1.0                                                        
//////////////////////////////////////////////////////////////// 
`timescale 1ns/10ps  
module ips2l_ddrphy_drift_ctrl_v1_0
(
  input            ddrphy_sysclk          ,
  input            ddrphy_rst_n           ,
  input            calib_done             ,
  input      [1:0] dqs_drift              ,
  input            ddrphy_update_req      ,
  input            ddrphy_update_done     ,
  output reg [1:0] ddrphy_update_comp_val ,
  output reg       ddrphy_update_comp_dir 
);

reg [1:0] dqs_drift_d1;
reg [1:0] dqs_drift_d2;
reg [1:0] dqs_drift_now;
reg [1:0] dqs_drift_last;

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if (!ddrphy_rst_n) begin
    dqs_drift_d1  <= 2'b00;
    dqs_drift_d2  <= 2'b00;
    dqs_drift_now <= 2'b00;
//    dqs_drift_last<= 2'b00;
    end
    else if((!calib_done)||(ddrphy_update_req))
    begin
        dqs_drift_d1  <= dqs_drift;
        dqs_drift_d2  <= dqs_drift_d1;
        dqs_drift_now <= dqs_drift_d2;
//        dqs_drift_last<= dqs_drift_now;
    end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if (!ddrphy_rst_n) 
    dqs_drift_last<= 2'b00;
    else if((!calib_done)||(ddrphy_update_done))
    dqs_drift_last<= dqs_drift_now;
end

always @(dqs_drift_last or dqs_drift_now)
begin
    case (dqs_drift_last)
        2'b00:begin
            if (dqs_drift_now == 2'b01) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b1; 
            end
            else if (dqs_drift_now == 2'b10) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b0;                 
            end
            else begin
               ddrphy_update_comp_val <= 2'b0;
               ddrphy_update_comp_dir <= 1'b0;  
            end
        end
        2'b01:begin
             if (dqs_drift_now == 2'b11) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b1; 
            end
            else if (dqs_drift_now == 2'b00) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b0;                 
            end
            else begin
               ddrphy_update_comp_val <= 2'b0;
               ddrphy_update_comp_dir <= 1'b0;  
            end
        end
        2'b10:begin
             if (dqs_drift_now == 2'b00) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b1; 
            end
            else if (dqs_drift_now == 2'b11) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b0;                 
            end
            else begin
               ddrphy_update_comp_val <= 2'b0;
               ddrphy_update_comp_dir <= 1'b0;  
            end            
        end
        2'b11:begin
             if (dqs_drift_now == 2'b10) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b1; 
            end
            else if (dqs_drift_now == 2'b01) begin
               ddrphy_update_comp_val <= 2'b1;
               ddrphy_update_comp_dir <= 1'b0;                 
            end
            else begin
               ddrphy_update_comp_val <= 2'b0;
               ddrphy_update_comp_dir <= 1'b0;  
            end            
        end
        default: begin
               ddrphy_update_comp_val <= 2'b0;
               ddrphy_update_comp_dir <= 1'b0;             
        end
    endcase        
end
   
endmodule



////////////////////////////////////////////////////////////////        
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                           
// ALL RIGHTS REVERVED.                                                  
////////////////////////////////////////////////////////////////        
//Description:                                                          
//Author:  wxxiao                                                       
//History: v1.0                                                         
////////////////////////////////////////////////////////////////    
`timescale 1ns/1ns
module ips2l_ddrphy_dqsi_rdel_cal_v1_0  #(
    parameter MIN_DQSI_WIN      = 9'd10
)(
    input            force_samp_position  ,
    input [7:0]      init_samp_position_even, 
    input [7:0]      init_samp_position_odd,

    input            ddrphy_sysclk        ,
    input            ddrphy_rst_n         ,
    input [7:0]      dll_90_bin           ,
    
    input            rdel_rvalid0         ,
    input            rdel_rvalid1         ,
    input            init_adj_rdel        ,
    output  reg      adj_rdel_done        ,
    
    input            rdel_calibration     ,
    output reg       rdel_calib_done      ,
    output reg       rdel_calib_error     ,
    
    input            rdel_move_en         ,
    output reg       rdel_move_done       ,
    
    input            eye_calibration      ,
    output reg       eyecal_check_pass    ,
    output           eyecal_move_done     ,
    input            eyecal_move_en       ,
    
    output reg       rdel_cal_vld         ,
    output [7:0]     dqs_even_gray        ,
    output [7:0]     dqs_odd_gray         ,
    output wire [7:0] dqs_even_bin         ,
    output wire [7:0] dqs_odd_bin          ,
    output reg [8:0] total_margin_even    ,
    output reg [8:0] total_margin_odd     ,
    
    output reg [7:0] idly_set             
              
);

`ifdef SIMULATION 
localparam ADJ_STEP = 8'd5;
`else                      
localparam ADJ_STEP = 8'd1;
`endif

localparam IDLE            = 0;
localparam INIT_RST        = 1;
localparam INIT_ADJ        = 2;
localparam ADJ_WAIT        = 3;
localparam CHECK_LEFT      = 4;
localparam MOVE_LEFT       = 5;
localparam JUMP_RST        = 6;
localparam JUMP            = 7;
localparam CHECK_RIGHT     = 8;
localparam MOVE_RIGHT      = 9;
localparam CENTER          = 10;
localparam CALIB_WAIT      = 11;

reg [7:0]    dqs_delay_even;
reg [7:0]    dqs_delay_odd;
reg [7:0]    idly_set_even;
reg [7:0]    idly_set_odd;
reg [8:0]    total_delay_even;
reg [8:0]    total_delay_odd;
reg move_stop_even;
reg move_stop_odd;
reg rdel_ov_even;
reg rdel_ov_odd;
reg [3:0]    state;
reg [7:0]    cnt;
wire  [7:0]  init_dqsi_value_even;  
wire  [7:0]  init_dqsi_value_odd;
wire rdel_rvalid;
reg rdel_calibration_d;
wire rdel_calibration_rising;  
reg eye_calibration_d    ;
wire eye_calibration_rising ;
 
 assign rdel_rvalid = rdel_rvalid0|rdel_rvalid1;
 assign dqsi_move_en = rdel_move_en | eyecal_move_en;
 assign eyecal_move_done = rdel_move_done;
 
 wire  [7:0]  dqsi_step_minus_even;
 wire  [7:0]  dqsi_step_plus_even;   
 wire  [7:0]  dqsi_step_minus_odd;
 wire  [7:0]  dqsi_step_plus_odd; 
 
 assign   dqsi_step_plus_even  = dll_90_bin + {1'b0,init_samp_position_even[6:0]};
 assign   dqsi_step_minus_even = dll_90_bin - {1'b0,init_samp_position_even[6:0]};
 
 assign   dqsi_step_plus_odd  = dll_90_bin + {1'b0,init_samp_position_odd[6:0]};
 assign   dqsi_step_minus_odd = dll_90_bin - {1'b0,init_samp_position_odd[6:0]}; 

assign init_dqsi_value_even = init_samp_position_even[7] ? (dqsi_step_minus_even[7] ? 8'h0 : dqsi_step_minus_even ) :(dqsi_step_plus_even[7]? 8'h7f :dqsi_step_plus_even ) ;  
assign init_dqsi_value_odd = init_samp_position_odd[7] ? (dqsi_step_minus_odd[7] ? 8'h0 : dqsi_step_minus_odd ) :(dqsi_step_plus_odd[7]? 8'h7f :dqsi_step_plus_odd ) ; 

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if(!ddrphy_rst_n) begin
      state <= IDLE;
      cnt   <= 8'd0;
   end
   else begin
      case (state)
         IDLE: begin
            cnt   <= 0;
            if (init_adj_rdel)
               state <= INIT_RST;
            else if ((rdel_calibration | eye_calibration) & (~force_samp_position))
               state <= CHECK_LEFT;
         end
         INIT_RST: begin
            if (cnt[3]) begin
               cnt   <= 0;
               state <= INIT_ADJ;               
            end
            else
               cnt   <= cnt + 1;
         end
         INIT_ADJ: begin
            if (cnt[2])
               state <= ADJ_WAIT;
            else
               cnt <= cnt + 1;
         end
         ADJ_WAIT: begin
            state <= IDLE;
         end         
         CHECK_LEFT: begin
            cnt   <= 0;
            if (dqsi_move_en) begin
               if ((move_stop_even|rdel_ov_even) && (move_stop_odd|rdel_ov_odd ))
                  state <= JUMP_RST;
               else
                  state <= MOVE_LEFT;               
            end   
         end
         MOVE_LEFT: begin
            if (cnt[3]) begin
               if (~dqsi_move_en)
                  state <= CHECK_LEFT;
            end
            else
               cnt <= cnt + 1;
         end
         JUMP_RST: begin
            if (cnt[3]) begin
               cnt   <= 0;
               state <= JUMP;               
            end
            else
               cnt   <= cnt + 1;            
         end
         JUMP: begin
            if (cnt[2]) begin
               if (~dqsi_move_en)
                  state <= CHECK_RIGHT;
            end
            else
               cnt <= cnt + 1;
         end
         CHECK_RIGHT: begin
            cnt   <= 0;
            if (dqsi_move_en) begin
               if ((move_stop_even|rdel_ov_even) && (move_stop_odd|rdel_ov_odd ))
                  state <= CENTER;
               else 
                  state <= MOVE_RIGHT;            
            end
         end
         MOVE_RIGHT: begin
            if (cnt[3]) begin
               if (~dqsi_move_en)
                  state <= CHECK_RIGHT;
            end
            else
               cnt <= cnt + 1;
         end
         CENTER: begin
            if (cnt[3]) begin
               if (~dqsi_move_en)
                  state <= CALIB_WAIT;
            end
            else
               cnt <= cnt + 1;
         end
         CALIB_WAIT: begin
            if ((~rdel_calibration)&&(~eye_calibration))
               state <= IDLE;
         end
         default: begin
            state <= IDLE;
         end
      endcase
   end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if(!ddrphy_rst_n)
    move_stop_even <= 0;
    else if((state == CHECK_LEFT)&&(dqsi_move_en)&&(!rdel_rvalid0))
    move_stop_even <= 1;
    else if((state == CHECK_RIGHT)&&(dqsi_move_en)&&(!rdel_rvalid0))
    move_stop_even <= 1;
    else if((state == IDLE)||(state == JUMP_RST))
    move_stop_even <= 0;
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if(!ddrphy_rst_n)
    move_stop_odd <= 0;
    else if((state == CHECK_LEFT)&&(dqsi_move_en)&&(!rdel_rvalid1))
    move_stop_odd <= 1;
    else if((state == CHECK_RIGHT)&&(dqsi_move_en)&&(!rdel_rvalid1))
    move_stop_odd <= 1;
    else if((state == IDLE)||(state == JUMP_RST))
    move_stop_odd <= 0;
end


always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
  if(!ddrphy_rst_n) begin
      dqs_delay_even <= 8'd0;
      idly_set_even <= 8'd0;
      rdel_ov_even <= 0;
  end
  else begin
        case (state)
           INIT_RST: begin
              dqs_delay_even <= init_dqsi_value_even;
              idly_set_even <= 8'd0;
              rdel_ov_even <= 0;
           end
           MOVE_LEFT: begin
              if((cnt == 'h0)&&(move_stop_even == 0)) begin
                  if(dqs_delay_even > (ADJ_STEP - 8'd1)) begin
                      dqs_delay_even <= dqs_delay_even - ADJ_STEP;
                      idly_set_even <= 8'd0;
                      rdel_ov_even <= 0;
                  end
                  else if (dqs_delay_even == 8'd0)                 
                  begin
                      if(idly_set_even < (8'd255 - ADJ_STEP))
                      begin
                         rdel_ov_even <= 0;
                         idly_set_even <= idly_set_even + ADJ_STEP;
                      end
                      else begin
                         rdel_ov_even <= 1;
                         idly_set_even <= 8'd255;
                      end
                  end
                  else 
                  begin
                      dqs_delay_even <= 8'd0;
                      idly_set_even <= idly_set_even;
                      rdel_ov_even <= rdel_ov_even; 
                  end
             end
           end
           JUMP_RST: begin //same as INIT_RST
              dqs_delay_even <= init_dqsi_value_even;
              rdel_ov_even <= 0;
           end         
           MOVE_RIGHT: begin
              if((cnt == 'h0)&&(move_stop_even == 0)) begin
                  if(dqs_delay_even < (8'd255 - ADJ_STEP)) begin
                      dqs_delay_even <= dqs_delay_even + ADJ_STEP;
                      rdel_ov_even <= 0;
                  end
                  else begin
                      dqs_delay_even <= 8'd255;
                      rdel_ov_even <= 1;
                  end
              end
           end
           CENTER: begin
              dqs_delay_even <= total_delay_even[8:1] - {1'b0,idly_set_even[7:1]};
              rdel_ov_even <= 0;
           end         
           default: begin
              dqs_delay_even <= dqs_delay_even;
              idly_set_even <= idly_set_even;
              rdel_ov_even <= rdel_ov_even;
           end
        endcase
  end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
  if(!ddrphy_rst_n) begin
      total_delay_even <= 9'd0;
  end
  else begin
      if(state == IDLE)
      total_delay_even <= 9'd0;
      else if((state == CHECK_LEFT)&&(dqsi_move_en)&&(move_stop_even|rdel_ov_even)&&(move_stop_odd|rdel_ov_odd ))
      total_delay_even <= total_delay_even + dqs_delay_even;
      else if((state == CHECK_RIGHT)&&(dqsi_move_en)&&(move_stop_even|rdel_ov_even)&&(move_stop_odd|rdel_ov_odd ))
      total_delay_even <= total_delay_even + dqs_delay_even;
  end      
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if(!ddrphy_rst_n) begin
       dqs_delay_odd <= 8'd0;
       idly_set_odd <= 8'd0;
       rdel_ov_odd <= 0;
   end
   else begin
         case (state)
            INIT_RST: begin
               dqs_delay_odd <= init_dqsi_value_odd;
               idly_set_odd <= 8'd0;
               rdel_ov_odd <= 0;
            end
            MOVE_LEFT: begin
               if((cnt == 'h0)&&(move_stop_odd == 0)) begin
                   if(dqs_delay_odd > (ADJ_STEP - 8'd1)) begin
                       dqs_delay_odd <= dqs_delay_odd - ADJ_STEP;
                       idly_set_odd <= 8'd0;
                       rdel_ov_odd <= 0;
                   end
                   else if (dqs_delay_odd == 8'd0)                 
                   begin
                       if(idly_set_odd < (8'd255 - ADJ_STEP))
                       begin
                          rdel_ov_odd <= 0;
                          idly_set_odd <= idly_set_odd + ADJ_STEP;
                       end
                       else begin
                          rdel_ov_odd <= 1;
                          idly_set_odd <= 8'd255;
                       end
                   end
                   else 
                   begin
                       dqs_delay_odd <= 8'd0;
                       idly_set_odd <= idly_set_odd;
                       rdel_ov_odd <= rdel_ov_odd; 
                   end
              end
            end
            JUMP_RST: begin //same as INIT_RST
               dqs_delay_odd <= init_dqsi_value_odd;
               rdel_ov_odd <= 0;
            end         
            MOVE_RIGHT: begin
               if((cnt == 'h0)&&(move_stop_odd == 0)) begin
                   if(dqs_delay_odd < (8'd255 - ADJ_STEP)) begin
                       dqs_delay_odd <= dqs_delay_odd + ADJ_STEP;
                       rdel_ov_odd <= 0;
                   end
                   else begin
                       dqs_delay_odd <= 8'd255;
                       rdel_ov_odd <= 1;
                   end
               end
            end
            CENTER: begin
               dqs_delay_odd <= total_delay_odd[8:1] - {1'b0,idly_set_odd[7:1]};
               rdel_ov_odd <= 0;
            end         
            default: begin
               dqs_delay_odd <= dqs_delay_odd;
               idly_set_odd <= idly_set_odd;
               rdel_ov_odd <= rdel_ov_odd;
            end
         endcase
   end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n) 
begin
   if(!ddrphy_rst_n) begin
       total_delay_odd <= 9'd0;
   end
   else begin
       if(state == IDLE)
       total_delay_odd <= 9'd0;
       else if((state == CHECK_LEFT)&&(dqsi_move_en)&&(move_stop_even|rdel_ov_even)&&(move_stop_odd|rdel_ov_odd ))
       total_delay_odd <= total_delay_odd + dqs_delay_odd;
       else if((state == CHECK_RIGHT)&&(dqsi_move_en)&&(move_stop_even|rdel_ov_even)&&(move_stop_odd|rdel_ov_odd ))
       total_delay_odd <= total_delay_odd + dqs_delay_odd;
   end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if(!ddrphy_rst_n) 
   begin
       idly_set <= 8'd0;
   end
   else if((state == MOVE_LEFT)||(state == CHECK_LEFT))
   begin
       if(idly_set_even >= idly_set_odd)
       idly_set <= idly_set_even[7:0];
       else 
       idly_set <= idly_set_odd[7:0];
   end
   else
      idly_set <= 8'd0;
end

//****************************************************************************************
assign rdel_calibration_rising = rdel_calibration & (~rdel_calibration_d);
assign eye_calibration_rising = eye_calibration & (~eye_calibration_d) ;
always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if(!ddrphy_rst_n) begin
      rdel_calibration_d <= 0;
      total_margin_even  <= 9'd0;
      eye_calibration_d  <= 0 ;
   end
   else begin
      rdel_calibration_d <= rdel_calibration;
      eye_calibration_d <= eye_calibration ;
      if (rdel_calibration_rising)
         total_margin_even <= 0;
      else if (eye_calibration_rising)
         total_margin_even <= 0 ;
      else if (((state == MOVE_LEFT)|(state == MOVE_RIGHT)) && (cnt == 'h0) && (move_stop_even == 0)) //check is valid
         total_margin_even <= total_margin_even + ADJ_STEP; 
   end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if(!ddrphy_rst_n) begin
      total_margin_odd  <= 9'd0;
   end
   else begin
      if (rdel_calibration_rising)
         total_margin_odd <= 0;  
      else if (eye_calibration_rising)
         total_margin_odd <= 0;
      else if (((state == MOVE_LEFT)|(state == MOVE_RIGHT)) && (cnt == 'h0) && (move_stop_odd == 0)) //check is valid
         total_margin_odd <= total_margin_odd + ADJ_STEP; 
   end
end


  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) 
        adj_rdel_done  <= 1'b0; 
     else if((state == INIT_ADJ) & (cnt[2]))
        adj_rdel_done  <= 1'b1;
     else if(~init_adj_rdel)
        adj_rdel_done  <= 1'b0;
  end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
    if(!ddrphy_rst_n) 
       rdel_move_done <= 1'b0;
    else if((rdel_calib_done)|(eyecal_check_pass))
       rdel_move_done <= 1'b1;
    else if(((state == MOVE_LEFT) & cnt[3])|((state == MOVE_RIGHT) & cnt[3]) |
            ((state == JUMP) & (cnt[2]))| ((state == CENTER) & (cnt [3])))
       rdel_move_done <= 1'b1;
    else
       rdel_move_done <= 1'b0;   
 end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n) 
       rdel_calib_done <= 1'b0;
    else 
       rdel_calib_done <= ((state == CALIB_WAIT) & rdel_calibration) | force_samp_position ;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n) 
       eyecal_check_pass <= 1'b0;
    else 
       eyecal_check_pass <= ((state == CALIB_WAIT) & eye_calibration) | force_samp_position ;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
        rdel_cal_vld <= 1'b0;
     else
        rdel_cal_vld <= rdel_calibration & (~rdel_move_en);
  end
  
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
    if(!ddrphy_rst_n)
       rdel_calib_error  <= 1'b0;
    else if((state ==IDLE)&(rdel_calibration | eye_calibration))
       rdel_calib_error  <= 1'b0;
    else if(state == CALIB_WAIT)
       rdel_calib_error  <=  ((total_margin_even < MIN_DQSI_WIN)||(total_margin_odd < MIN_DQSI_WIN)) & (~force_samp_position);

assign dqs_even_bin =  dqs_delay_even[7:0];
assign dqs_odd_bin  = dqs_delay_odd[7:0];

assign dqs_even_gray[7] = dqs_even_bin[7];
assign dqs_even_gray[6] = dqs_even_bin[7] ^ dqs_even_bin[6];
assign dqs_even_gray[5] = dqs_even_bin[6] ^ dqs_even_bin[5];
assign dqs_even_gray[4] = dqs_even_bin[5] ^ dqs_even_bin[4];
assign dqs_even_gray[3] = dqs_even_bin[4] ^ dqs_even_bin[3];
assign dqs_even_gray[2] = dqs_even_bin[3] ^ dqs_even_bin[2];
assign dqs_even_gray[1] = dqs_even_bin[2] ^ dqs_even_bin[1];
assign dqs_even_gray[0] = dqs_even_bin[1] ^ dqs_even_bin[0];

//assign dqs_odd_gray = dqs_even_gray;

assign dqs_odd_gray[7] = dqs_odd_bin[7];
assign dqs_odd_gray[6] = dqs_odd_bin[7] ^ dqs_odd_bin[6];
assign dqs_odd_gray[5] = dqs_odd_bin[6] ^ dqs_odd_bin[5];
assign dqs_odd_gray[4] = dqs_odd_bin[5] ^ dqs_odd_bin[4];
assign dqs_odd_gray[3] = dqs_odd_bin[4] ^ dqs_odd_bin[3];
assign dqs_odd_gray[2] = dqs_odd_bin[3] ^ dqs_odd_bin[2];
assign dqs_odd_gray[1] = dqs_odd_bin[2] ^ dqs_odd_bin[1];
assign dqs_odd_gray[0] = dqs_odd_bin[1] ^ dqs_odd_bin[0];

endmodule




////////////////////////////////////////////////////////////////   
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                      
// ALL RIGHTS REVERVED.                                            
////////////////////////////////////////////////////////////////   
//Description:                                                     
//Author:  wxxiao                                                  
//History: v1.0                                                    
////////////////////////////////////////////////////////////////   
`timescale 1ns/1ps                                                 
module ips2l_ddrphy_dqs_rddata_align_v1_0 #(
    parameter TEST_DATA_PATTERN0 = 64'h55_aa_55_aa_08_f7_08_f7,
    parameter TEST_DATA_PATTERN1 = 64'h7f_9f_7f_9f_80_fe_80_fe,
    parameter TEST_DATA_PATTERN2 = 64'hf0_0f_f0_0f_01_ff_01_ff,
    parameter TEST_DATA_PATTERN3 = 64'hdf_aa_df_aa_55_aa_55_aa
)(
    input           ddrphy_sysclk      ,
    input           ddrphy_rst_n       ,

    input           ddrphy_read_valid  ,
    input  [63:0]   ddrphy_rdata       ,
    output    	    read_valid         ,
    output [63:0]   read_data          ,
    input           gate_adj_done      ,
    output reg      rddata_check_pass  ,
    input           dqs_gate_vld       ,
    input           bitslip_ctrl       ,
    output reg      bitslip_dq         ,
    
    input           write_calibration  ,
    input           wrcal_move_done    ,
    output reg      wrdata_check_pass  ,
    
    input           eye_calibration    ,
    input           eyecal_move_done   ,
    
    input           rdel_cal_vld       ,
    output reg      rdel_rvalid0       ,
    output reg      rdel_rvalid1        
   );

  localparam GDETECT_IDLE   = 3'd0;
  localparam GDETECT_DATA1  = 3'd1;
  localparam GDETECT_DATA2  = 3'd2;
  localparam GDETECT_JUDGE  = 3'd3;
  localparam GDETECT_WAIT   = 3'd4;
  
  localparam RDCHECK_IDLE  = 4'd0;
  localparam RDCHECK_DATA0 = 4'd1;
  localparam RDCHECK_DATA1 = 4'd2;
  localparam RDCHECK_DATA2 = 4'd3;
  localparam RDCHECK_DATA3 = 4'd4;
  localparam RDCHECK_JUDGE = 4'd5;
  localparam RDCHECK_WAIT  = 4'd6;

  localparam DATA_PATTERN0_EVEN = {TEST_DATA_PATTERN0[63],TEST_DATA_PATTERN0[61],TEST_DATA_PATTERN0[59],TEST_DATA_PATTERN0[57],TEST_DATA_PATTERN0[55],TEST_DATA_PATTERN0[53],TEST_DATA_PATTERN0[51],TEST_DATA_PATTERN0[49],
                                   TEST_DATA_PATTERN0[47],TEST_DATA_PATTERN0[45],TEST_DATA_PATTERN0[43],TEST_DATA_PATTERN0[41],TEST_DATA_PATTERN0[39],TEST_DATA_PATTERN0[37],TEST_DATA_PATTERN0[35],TEST_DATA_PATTERN0[33],
                                   TEST_DATA_PATTERN0[31],TEST_DATA_PATTERN0[29],TEST_DATA_PATTERN0[27],TEST_DATA_PATTERN0[25],TEST_DATA_PATTERN0[23],TEST_DATA_PATTERN0[21],TEST_DATA_PATTERN0[19],TEST_DATA_PATTERN0[17],
                                   TEST_DATA_PATTERN0[15],TEST_DATA_PATTERN0[13],TEST_DATA_PATTERN0[11],TEST_DATA_PATTERN0[9] ,TEST_DATA_PATTERN0[7] ,TEST_DATA_PATTERN0[5] ,TEST_DATA_PATTERN0[3] ,TEST_DATA_PATTERN0[1]};

  localparam DATA_PATTERN0_ODD = {TEST_DATA_PATTERN0[62],TEST_DATA_PATTERN0[60],TEST_DATA_PATTERN0[58],TEST_DATA_PATTERN0[56],TEST_DATA_PATTERN0[54],TEST_DATA_PATTERN0[52],TEST_DATA_PATTERN0[50],TEST_DATA_PATTERN0[48],
                                  TEST_DATA_PATTERN0[46],TEST_DATA_PATTERN0[44],TEST_DATA_PATTERN0[42],TEST_DATA_PATTERN0[40],TEST_DATA_PATTERN0[38],TEST_DATA_PATTERN0[36],TEST_DATA_PATTERN0[34],TEST_DATA_PATTERN0[32],
                                  TEST_DATA_PATTERN0[30],TEST_DATA_PATTERN0[28],TEST_DATA_PATTERN0[26],TEST_DATA_PATTERN0[24],TEST_DATA_PATTERN0[22],TEST_DATA_PATTERN0[20],TEST_DATA_PATTERN0[18],TEST_DATA_PATTERN0[16],
                                  TEST_DATA_PATTERN0[14],TEST_DATA_PATTERN0[12],TEST_DATA_PATTERN0[10],TEST_DATA_PATTERN0[8] ,TEST_DATA_PATTERN0[6] ,TEST_DATA_PATTERN0[4] ,TEST_DATA_PATTERN0[2] ,TEST_DATA_PATTERN0[0]};

  localparam DATA_PATTERN1_EVEN = {TEST_DATA_PATTERN1[63],TEST_DATA_PATTERN1[61],TEST_DATA_PATTERN1[59],TEST_DATA_PATTERN1[57],TEST_DATA_PATTERN1[55],TEST_DATA_PATTERN1[53],TEST_DATA_PATTERN1[51],TEST_DATA_PATTERN1[49],
                                   TEST_DATA_PATTERN1[47],TEST_DATA_PATTERN1[45],TEST_DATA_PATTERN1[43],TEST_DATA_PATTERN1[41],TEST_DATA_PATTERN1[39],TEST_DATA_PATTERN1[37],TEST_DATA_PATTERN1[35],TEST_DATA_PATTERN1[33],
                                   TEST_DATA_PATTERN1[31],TEST_DATA_PATTERN1[29],TEST_DATA_PATTERN1[27],TEST_DATA_PATTERN1[25],TEST_DATA_PATTERN1[23],TEST_DATA_PATTERN1[21],TEST_DATA_PATTERN1[19],TEST_DATA_PATTERN1[17],
                                   TEST_DATA_PATTERN1[15],TEST_DATA_PATTERN1[13],TEST_DATA_PATTERN1[11],TEST_DATA_PATTERN1[9] ,TEST_DATA_PATTERN1[7] ,TEST_DATA_PATTERN1[5] ,TEST_DATA_PATTERN1[3] ,TEST_DATA_PATTERN1[1]};

  localparam DATA_PATTERN1_ODD = {TEST_DATA_PATTERN1[62],TEST_DATA_PATTERN1[60],TEST_DATA_PATTERN1[58],TEST_DATA_PATTERN1[56],TEST_DATA_PATTERN1[54],TEST_DATA_PATTERN1[52],TEST_DATA_PATTERN1[50],TEST_DATA_PATTERN1[48],
                                  TEST_DATA_PATTERN1[46],TEST_DATA_PATTERN1[44],TEST_DATA_PATTERN1[42],TEST_DATA_PATTERN1[40],TEST_DATA_PATTERN1[38],TEST_DATA_PATTERN1[36],TEST_DATA_PATTERN1[34],TEST_DATA_PATTERN1[32],
                                  TEST_DATA_PATTERN1[30],TEST_DATA_PATTERN1[28],TEST_DATA_PATTERN1[26],TEST_DATA_PATTERN1[24],TEST_DATA_PATTERN1[22],TEST_DATA_PATTERN1[20],TEST_DATA_PATTERN1[18],TEST_DATA_PATTERN1[16],
                                  TEST_DATA_PATTERN1[14],TEST_DATA_PATTERN1[12],TEST_DATA_PATTERN1[10],TEST_DATA_PATTERN1[8] ,TEST_DATA_PATTERN1[6] ,TEST_DATA_PATTERN1[4] ,TEST_DATA_PATTERN1[2] ,TEST_DATA_PATTERN1[0]};

  localparam DATA_PATTERN2_EVEN = {TEST_DATA_PATTERN2[63],TEST_DATA_PATTERN2[61],TEST_DATA_PATTERN2[59],TEST_DATA_PATTERN2[57],TEST_DATA_PATTERN2[55],TEST_DATA_PATTERN2[53],TEST_DATA_PATTERN2[51],TEST_DATA_PATTERN2[49],
                                   TEST_DATA_PATTERN2[47],TEST_DATA_PATTERN2[45],TEST_DATA_PATTERN2[43],TEST_DATA_PATTERN2[41],TEST_DATA_PATTERN2[39],TEST_DATA_PATTERN2[37],TEST_DATA_PATTERN2[35],TEST_DATA_PATTERN2[33],
                                   TEST_DATA_PATTERN2[31],TEST_DATA_PATTERN2[29],TEST_DATA_PATTERN2[27],TEST_DATA_PATTERN2[25],TEST_DATA_PATTERN2[23],TEST_DATA_PATTERN2[21],TEST_DATA_PATTERN2[19],TEST_DATA_PATTERN2[17],
                                   TEST_DATA_PATTERN2[15],TEST_DATA_PATTERN2[13],TEST_DATA_PATTERN2[11],TEST_DATA_PATTERN2[9] ,TEST_DATA_PATTERN2[7] ,TEST_DATA_PATTERN2[5] ,TEST_DATA_PATTERN2[3] ,TEST_DATA_PATTERN2[1]};

  localparam DATA_PATTERN2_ODD = {TEST_DATA_PATTERN2[62],TEST_DATA_PATTERN2[60],TEST_DATA_PATTERN2[58],TEST_DATA_PATTERN2[56],TEST_DATA_PATTERN2[54],TEST_DATA_PATTERN2[52],TEST_DATA_PATTERN2[50],TEST_DATA_PATTERN2[48],
                                  TEST_DATA_PATTERN2[46],TEST_DATA_PATTERN2[44],TEST_DATA_PATTERN2[42],TEST_DATA_PATTERN2[40],TEST_DATA_PATTERN2[38],TEST_DATA_PATTERN2[36],TEST_DATA_PATTERN2[34],TEST_DATA_PATTERN2[32],
                                  TEST_DATA_PATTERN2[30],TEST_DATA_PATTERN2[28],TEST_DATA_PATTERN2[26],TEST_DATA_PATTERN2[24],TEST_DATA_PATTERN2[22],TEST_DATA_PATTERN2[20],TEST_DATA_PATTERN2[18],TEST_DATA_PATTERN2[16],
                                  TEST_DATA_PATTERN2[14],TEST_DATA_PATTERN2[12],TEST_DATA_PATTERN2[10],TEST_DATA_PATTERN2[8] ,TEST_DATA_PATTERN2[6] ,TEST_DATA_PATTERN2[4] ,TEST_DATA_PATTERN2[2] ,TEST_DATA_PATTERN2[0]};

  localparam DATA_PATTERN3_EVEN = {TEST_DATA_PATTERN3[63],TEST_DATA_PATTERN3[61],TEST_DATA_PATTERN3[59],TEST_DATA_PATTERN3[57],TEST_DATA_PATTERN3[55],TEST_DATA_PATTERN3[53],TEST_DATA_PATTERN3[51],TEST_DATA_PATTERN3[49],
                                   TEST_DATA_PATTERN3[47],TEST_DATA_PATTERN3[45],TEST_DATA_PATTERN3[43],TEST_DATA_PATTERN3[41],TEST_DATA_PATTERN3[39],TEST_DATA_PATTERN3[37],TEST_DATA_PATTERN3[35],TEST_DATA_PATTERN3[33],
                                   TEST_DATA_PATTERN3[31],TEST_DATA_PATTERN3[29],TEST_DATA_PATTERN3[27],TEST_DATA_PATTERN3[25],TEST_DATA_PATTERN3[23],TEST_DATA_PATTERN3[21],TEST_DATA_PATTERN3[19],TEST_DATA_PATTERN3[17],
                                   TEST_DATA_PATTERN3[15],TEST_DATA_PATTERN3[13],TEST_DATA_PATTERN3[11],TEST_DATA_PATTERN3[9] ,TEST_DATA_PATTERN3[7] ,TEST_DATA_PATTERN3[5] ,TEST_DATA_PATTERN3[3] ,TEST_DATA_PATTERN3[1]};

  localparam DATA_PATTERN3_ODD = {TEST_DATA_PATTERN3[62],TEST_DATA_PATTERN3[60],TEST_DATA_PATTERN3[58],TEST_DATA_PATTERN3[56],TEST_DATA_PATTERN3[54],TEST_DATA_PATTERN3[52],TEST_DATA_PATTERN3[50],TEST_DATA_PATTERN3[48],
                                  TEST_DATA_PATTERN3[46],TEST_DATA_PATTERN3[44],TEST_DATA_PATTERN3[42],TEST_DATA_PATTERN3[40],TEST_DATA_PATTERN3[38],TEST_DATA_PATTERN3[36],TEST_DATA_PATTERN3[34],TEST_DATA_PATTERN3[32],
                                  TEST_DATA_PATTERN3[30],TEST_DATA_PATTERN3[28],TEST_DATA_PATTERN3[26],TEST_DATA_PATTERN3[24],TEST_DATA_PATTERN3[22],TEST_DATA_PATTERN3[20],TEST_DATA_PATTERN3[18],TEST_DATA_PATTERN3[16],
                                  TEST_DATA_PATTERN3[14],TEST_DATA_PATTERN3[12],TEST_DATA_PATTERN3[10],TEST_DATA_PATTERN3[8] ,TEST_DATA_PATTERN3[6] ,TEST_DATA_PATTERN3[4] ,TEST_DATA_PATTERN3[2] ,TEST_DATA_PATTERN3[0]};

  reg          rdvalid_r1  ;
  reg [63:0]   rddata_r1   ;
  wire [63:0]  align_rdata ;
  wire [31:0]  align_rdata0;
  wire [31:0]  align_rdata1;  
  
  reg [2:0]   gdet_state;
  reg [2:0]   gdet_next_state;
  
  reg [3:0] rdchk_state0;
  reg [3:0] rdchk_next_state0; 
  reg [3:0] rdchk_state1;     
  reg [3:0] rdchk_next_state1;
    
  reg       dqs_gate_vld_r ; 
  wire      rdel_data_vld0 ;   //posedge clk data
  wire      rdel_data_vld1 ;   //negedge clk data
  reg       slip_en;
 
//*******************************************************************
// align read_valid and read_data 
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if (!ddrphy_rst_n) begin
        rddata_r1   <= 64'h0 ;
        rdvalid_r1  <= 1'b0  ;
     end
     else begin
        rddata_r1   <= ddrphy_rdata;
        rdvalid_r1  <= ddrphy_read_valid;
     end
  end
             
  assign  align_rdata   = rddata_r1 ;
  assign  align_rdata0  = {rddata_r1[63],rddata_r1[61],rddata_r1[59],rddata_r1[57],rddata_r1[55],rddata_r1[53],rddata_r1[51],rddata_r1[49],rddata_r1[47],rddata_r1[45],rddata_r1[43],rddata_r1[41],rddata_r1[39],rddata_r1[37],rddata_r1[35],rddata_r1[33],
                           rddata_r1[31],rddata_r1[29],rddata_r1[27],rddata_r1[25],rddata_r1[23],rddata_r1[21],rddata_r1[19],rddata_r1[17],rddata_r1[15],rddata_r1[13],rddata_r1[11],rddata_r1[9] ,rddata_r1[7] ,rddata_r1[5] ,rddata_r1[3] ,rddata_r1[1]};
  assign  align_rdata1  = {rddata_r1[62],rddata_r1[60],rddata_r1[58],rddata_r1[56],rddata_r1[54],rddata_r1[52],rddata_r1[50],rddata_r1[48],rddata_r1[46],rddata_r1[44],rddata_r1[42],rddata_r1[40],rddata_r1[38],rddata_r1[36],rddata_r1[34],rddata_r1[32],
                           rddata_r1[30],rddata_r1[28],rddata_r1[26],rddata_r1[24],rddata_r1[22],rddata_r1[20],rddata_r1[18],rddata_r1[16],rddata_r1[14],rddata_r1[12],rddata_r1[10],rddata_r1[8] ,rddata_r1[6] ,rddata_r1[4] ,rddata_r1[2] ,rddata_r1[0]};                                                            

  assign rdel_data_vld0 = (align_rdata0 == {8{4'h0}}) ? 1'b1 : 1'b0;   //posedge
  assign rdel_data_vld1 = (align_rdata1 == {8{4'hf}}) ? 1'b1 : 1'b0;   //negedge
  
//  assign align_dq =  align_rdata[3:0];
//*******************************************************************//                                                
//check data in dqs gate training procedure                                                                            
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) 
        gdet_state   <=  3'h0;
     else
        gdet_state   <= gdet_next_state;
  end

  always @(*) 
  begin
       gdet_next_state  = GDETECT_IDLE ;
       case(gdet_state)
          GDETECT_IDLE : begin
                            if(dqs_gate_vld)
                               gdet_next_state  = GDETECT_DATA1;
                         end
           
         GDETECT_DATA1 : begin
                            if(gate_adj_done | bitslip_ctrl)
                               gdet_next_state = GDETECT_IDLE; 
                            else if(rdvalid_r1 &&(align_rdata== 64'hb0b0_b0b0_b0b0_b0b0))
                               gdet_next_state = GDETECT_DATA2;
                            else 
                               gdet_next_state = GDETECT_DATA1;
                          end

        GDETECT_DATA2 :  begin
                            if(gate_adj_done | bitslip_ctrl)
                               gdet_next_state = GDETECT_IDLE;
                            else if(rdvalid_r1 &&(align_rdata== 64'hb0b0_b0b0_b0b0_b0b0)) 
                            begin
                               gdet_next_state  = GDETECT_JUDGE;
                            end
                            else 
                               gdet_next_state =  GDETECT_DATA2;
                         end
          
        GDETECT_JUDGE :  begin
                                gdet_next_state = GDETECT_WAIT;
                         end
              
        GDETECT_WAIT:  begin
                           if(gate_adj_done | bitslip_ctrl)
                               gdet_next_state = GDETECT_IDLE;
                           else
                               gdet_next_state = GDETECT_WAIT;
                        end
         endcase
   end

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
     if(!ddrphy_rst_n)
        rddata_check_pass   <= 1'b0;
     else if(gdet_next_state == GDETECT_IDLE)
        rddata_check_pass   <= 1'b0;
     else if((gdet_state ==GDETECT_JUDGE)&&(align_rdata == 64'haaaa_aaaa_aaaa_aaaa))
        rddata_check_pass   <= 1'b1;
 end
 
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
     if(!ddrphy_rst_n)
     slip_en <= 1;
     else if(rddata_check_pass == 1)
     slip_en <= 0;
 end
 
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
     if(!ddrphy_rst_n)
     bitslip_dq <= 0;
     else if(slip_en == 1)
     bitslip_dq <= bitslip_ctrl;
     else
     bitslip_dq <= 0;
 end
 
//*******************************************************************//                                                
//check data in rdel training procedure
always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n) begin
      rdel_rvalid0  <= 1'b1;
   end
   else if(eye_calibration | write_calibration)
   begin
      if(rdchk_state0 == RDCHECK_JUDGE)
      rdel_rvalid0  <= 1'b1;
      else if(wrcal_move_done | eyecal_move_done)
      rdel_rvalid0  <= 1'b0;
   end   
   else begin
      if (rdel_cal_vld) begin   
         if (rdvalid_r1 & (~rdel_data_vld0))
            rdel_rvalid0 <= 1'b0;        
         end
         else begin
         rdel_rvalid0 <= 1'b1;
      end
   end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n) begin
      rdel_rvalid1  <= 1'b1;
   end
   else if(eye_calibration | write_calibration)
   begin
      if(rdchk_state1 == RDCHECK_JUDGE)
      rdel_rvalid1  <= 1'b1;
      else if(wrcal_move_done | eyecal_move_done)
      rdel_rvalid1  <= 1'b0;
   end   
   else begin
         if( rdel_cal_vld ) begin
         if (rdvalid_r1 & (~rdel_data_vld1))
            rdel_rvalid1 <= 1'b0;
         end
         else begin
         rdel_rvalid1 <= 1'b1;
      end
   end
end
   
//*******************************************************************//
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) 
        rdchk_state0   <=  4'h0;
     else
        rdchk_state0   <= rdchk_next_state0;
  end

  always @(*) 
  begin
       rdchk_next_state0  = RDCHECK_IDLE ;
       case(rdchk_state0)
        RDCHECK_IDLE : begin 
            if(eye_calibration | write_calibration)
            rdchk_next_state0 = RDCHECK_DATA0;
        end
        RDCHECK_DATA0: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state0  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata0 == DATA_PATTERN0_EVEN))
            rdchk_next_state0  = RDCHECK_DATA1;
            else
            rdchk_next_state0  = RDCHECK_DATA0;
        end
        RDCHECK_DATA1: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state0  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata0 == DATA_PATTERN1_EVEN))
            rdchk_next_state0  = RDCHECK_DATA2;
            else
            rdchk_next_state0  = RDCHECK_DATA1;            
        end
        RDCHECK_DATA2: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state0  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata0 == DATA_PATTERN2_EVEN))
            rdchk_next_state0  = RDCHECK_DATA3;
            else
            rdchk_next_state0  = RDCHECK_DATA2;            
        end
        RDCHECK_DATA3: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state0  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata0 == DATA_PATTERN3_EVEN))
            rdchk_next_state0  = RDCHECK_JUDGE;
            else
            rdchk_next_state0  = RDCHECK_DATA3;            
        end
        RDCHECK_JUDGE: begin
            rdchk_next_state0  = RDCHECK_WAIT;
        end
        RDCHECK_WAIT : begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state0  = RDCHECK_IDLE;
        end
    endcase
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) 
        rdchk_state1   <=  4'h0;
     else
        rdchk_state1   <= rdchk_next_state1;
  end

  always @(*) 
  begin
       rdchk_next_state1  = RDCHECK_IDLE ;
       case(rdchk_state1)
        RDCHECK_IDLE : begin 
            if(eye_calibration | write_calibration)
            rdchk_next_state1 = RDCHECK_DATA0;
        end
        RDCHECK_DATA0: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state1  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata1 == DATA_PATTERN0_ODD))
            rdchk_next_state1  = RDCHECK_DATA1;
            else
            rdchk_next_state1  = RDCHECK_DATA0;
        end
        RDCHECK_DATA1: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state1  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata1 == DATA_PATTERN1_ODD))
            rdchk_next_state1  = RDCHECK_DATA2;
            else
            rdchk_next_state1  = RDCHECK_DATA1;            
        end
        RDCHECK_DATA2: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state1  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata1 == DATA_PATTERN2_ODD))
            rdchk_next_state1  = RDCHECK_DATA3;
            else
            rdchk_next_state1  = RDCHECK_DATA2;            
        end
        RDCHECK_DATA3: begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state1  = RDCHECK_IDLE;
            else if(rdvalid_r1 && (align_rdata1 == DATA_PATTERN3_ODD))
            rdchk_next_state1  = RDCHECK_JUDGE;
            else
            rdchk_next_state1  = RDCHECK_DATA3;            
        end
        RDCHECK_JUDGE: begin
            rdchk_next_state1  = RDCHECK_WAIT;
        end
        RDCHECK_WAIT : begin
            if(wrcal_move_done | eyecal_move_done)
            rdchk_next_state1  = RDCHECK_IDLE;
        end
    endcase
  end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if (!ddrphy_rst_n) begin
      wrdata_check_pass  <= 1'b1;
   end
   else if(write_calibration)
   begin
      if((rdchk_state0 == RDCHECK_JUDGE)&&(rdchk_state1 == RDCHECK_JUDGE))
      wrdata_check_pass  <= 1'b1;
      else if(wrcal_move_done)
      wrdata_check_pass  <= 1'b0;
   end
   else 
     wrdata_check_pass  <= 1'b0;
end

//*******************************************************************//
//using combinational output to save registers
assign read_valid  = rdvalid_r1 ;
assign read_data   = align_rdata;

endmodule




////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module  ips2l_ddrphy_dqs_gate_coarse_cal_v1_0(   
   input            ddrphy_sysclk    ,
   input            ddrphy_rst_n     ,
   input            gatecal_start    ,
   input            rddata_cal       ,
   
   input  [3:0]     read_cmd         ,
   input  [4:0]     mc_rl            ,

   input  [3:0]     coarse_slip_step ,
   output [3:0]     dqs_gate_ctrl    ,
   output reg       dqs_gate_vld
  );
  
  wire read_cmd_comb;
  reg [1:0] read_cmd_comb_r;
  reg [3:0] dqs_gate_pulse_src;
  reg [3:0] dqs_gate_pulse_src_nxt;
  reg [3:0] dqs_gate_pulse_src_nxt_r;

  reg [3:0] dqs_gate_pulse_r1;
  reg [3:0] dqs_gate_pulse_r2;
  reg [3:0] dqs_gate_pulse_r3;
  reg [3:0] dqs_gate_pulse_r4;
  reg [3:0] dqs_gate_ctrl_adj;
  reg [3:0] dqs_gate_ctrl_pos;


  reg [4:0] cnt;
  reg [3:0] read_en_slipped;
  reg [3:0] read_cmd_mux;
  reg [3:0] read_cmd_mux_r1 ;
  reg [3:0] read_cmd_mux_r2 ;
  reg [3:0] read_cmd_mux_r3 ;

assign read_cmd_comb = |read_cmd;

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
        read_cmd_comb_r   <= 2'b00;
     else
        read_cmd_comb_r   <= {read_cmd_comb_r[0],read_cmd_comb};
  end

    always @(*)
    begin
        if(gatecal_start & read_cmd_comb & (~read_cmd_comb_r[1]))
            read_cmd_mux = read_cmd;
        else if(~gatecal_start)
            read_cmd_mux = read_cmd;
        else
            read_cmd_mux = 4'b0000;
    end
            
////
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n) begin
        read_cmd_mux_r1 <= 4'b0;
        read_cmd_mux_r2 <= 4'b0;
        read_cmd_mux_r3 <= 4'b0;
    end
    else begin
       read_cmd_mux_r1 <= read_cmd_mux  ;
       read_cmd_mux_r2 <= read_cmd_mux_r1 ;
       read_cmd_mux_r3 <= read_cmd_mux_r2 ;
    end
  end

     always @(*)
         case (coarse_slip_step)
             4'd0:       read_en_slipped = read_cmd_mux;
             4'd1:       read_en_slipped = {read_cmd_mux[2:0],read_cmd_mux_r1[3]};
             4'd2:       read_en_slipped = {read_cmd_mux[1:0],read_cmd_mux_r1[3:2]};
             4'd3:       read_en_slipped = {read_cmd_mux[0],  read_cmd_mux_r1[3:1]};
             4'd4:       read_en_slipped = read_cmd_mux_r1;
             4'd5:       read_en_slipped = {read_cmd_mux_r1[2:0],read_cmd_mux_r2[3]};
             4'd6:       read_en_slipped = {read_cmd_mux_r1[1:0],read_cmd_mux_r2[3:2]};
             4'd7:       read_en_slipped = {read_cmd_mux_r1[0],  read_cmd_mux_r2[3:1]};
             4'd8:       read_en_slipped = read_cmd_mux_r2;
             4'd9:       read_en_slipped = {read_cmd_mux_r2[2:0],read_cmd_mux_r3[3]};
             4'd10:      read_en_slipped = {read_cmd_mux_r2[1:0],read_cmd_mux_r3[3:2]};
             4'd11:      read_en_slipped = {read_cmd_mux_r2[0],  read_cmd_mux_r3[3:1]};
             4'd12:      read_en_slipped = read_cmd_mux_r3;
             default:    read_en_slipped = read_cmd_mux;
         endcase

    // generate the dqs_gate_pulse
    always @(*) 
    begin
        if(read_en_slipped[0]==1'b1) begin
            dqs_gate_pulse_src      = 4'b1111;
            dqs_gate_pulse_src_nxt  = 4'b0000;
        end 
        else if(read_en_slipped[1]==1'b1) begin
            dqs_gate_pulse_src      = {3'b111, dqs_gate_pulse_src_nxt_r[0]};
            dqs_gate_pulse_src_nxt  = 4'b0001;
        end
        else if(read_en_slipped[2]==1'b1) begin
            dqs_gate_pulse_src      = {2'b11, dqs_gate_pulse_src_nxt_r[1:0]};
            dqs_gate_pulse_src_nxt  = 4'b0011;
        end
        else if(read_en_slipped[3]==1'b1) begin
            dqs_gate_pulse_src      = {1'b1, dqs_gate_pulse_src_nxt_r[2:0]};
            dqs_gate_pulse_src_nxt  = 4'b0111;
        end
        else begin
            dqs_gate_pulse_src      = dqs_gate_pulse_src_nxt_r;   
            dqs_gate_pulse_src_nxt  = 4'b0000;
        end 
    end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) begin
     	 dqs_gate_pulse_src_nxt_r <= 4'b0000;
     end
     else begin
     	 dqs_gate_pulse_src_nxt_r <= dqs_gate_pulse_src_nxt;
     end
  end

///
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) begin
         dqs_gate_pulse_r1   <= 4'b00;
         dqs_gate_pulse_r2   <= 4'b00;
         dqs_gate_pulse_r3   <= 4'b00;
         dqs_gate_pulse_r4   <= 4'b00;
     end
     else  begin
         dqs_gate_pulse_r1   <= dqs_gate_pulse_src ;
         dqs_gate_pulse_r2   <= dqs_gate_pulse_r1  ;
         dqs_gate_pulse_r3   <= dqs_gate_pulse_r2  ;
         dqs_gate_pulse_r4   <= dqs_gate_pulse_r3  ;
     end
  end

     always @(*)
         case (mc_rl)
            
             5'd5:   dqs_gate_ctrl_adj = dqs_gate_pulse_src;
            
             5'd6:   dqs_gate_ctrl_adj = {dqs_gate_pulse_src[2:0],dqs_gate_pulse_r1[3]};
             
             5'd7:   dqs_gate_ctrl_adj = {dqs_gate_pulse_src[1:0],dqs_gate_pulse_r1[3:2]};
             
             5'd8:   dqs_gate_ctrl_adj = {dqs_gate_pulse_src[0],dqs_gate_pulse_r1[3:1]};

             5'd9:   dqs_gate_ctrl_adj = dqs_gate_pulse_r1;

             5'd10:  dqs_gate_ctrl_adj = {dqs_gate_pulse_r1[2:0],dqs_gate_pulse_r2[3]};
       
             5'd11:  dqs_gate_ctrl_adj = {dqs_gate_pulse_r1[1:0],dqs_gate_pulse_r2[3:2]};

             5'd12:  dqs_gate_ctrl_adj = {dqs_gate_pulse_r1[0],dqs_gate_pulse_r2[3:1]};
 
             5'd13:  dqs_gate_ctrl_adj = dqs_gate_pulse_r2;

             5'd14:  dqs_gate_ctrl_adj = {dqs_gate_pulse_r2[2:0],dqs_gate_pulse_r3[3]};
      
             5'd15:  dqs_gate_ctrl_adj = {dqs_gate_pulse_r2[1:0],dqs_gate_pulse_r3[3:2]};

             5'd16:  dqs_gate_ctrl_adj = {dqs_gate_pulse_r2[0],dqs_gate_pulse_r3[3:1]};
    
             5'd17:  dqs_gate_ctrl_adj = dqs_gate_pulse_r3;

             5'd18:  dqs_gate_ctrl_adj = {dqs_gate_pulse_r3[2:0],dqs_gate_pulse_r4[3]};

          default:   dqs_gate_ctrl_adj =  dqs_gate_pulse_src;
        endcase

     always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n) // register output
     begin
         if(!ddrphy_rst_n)
             dqs_gate_ctrl_pos  <= 4'b0000;
         else
             dqs_gate_ctrl_pos  <= dqs_gate_ctrl_adj;
     end

 assign  dqs_gate_ctrl =  dqs_gate_ctrl_pos;

 //*************************************************************************************************************
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n) // register output
 begin
     if(!ddrphy_rst_n) begin
        dqs_gate_vld  <= 1'b0;
        cnt           <= 5'b0;
     end
     else begin
        if (gatecal_start | rddata_cal) begin
           if (dqs_gate_ctrl_pos != 4'd0) begin
               dqs_gate_vld  <= 1'b1;
               cnt           <= 4'b0;
           end
           else if (cnt==5'd10) begin
              dqs_gate_vld <= 1'b0;
              cnt          <= 4'b0;
           end
           else
              cnt <= cnt + 4'b1;
        end
        else begin
           dqs_gate_vld  <= 1'b0;
           cnt           <= 4'b0;
        end
     end
 end

endmodule




////////////////////////////////////////////////////////////////      
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                         
// ALL RIGHTS REVERVED.                                               
////////////////////////////////////////////////////////////////      
//Description:                                                        
//Author:  wxxiao                                                     
//History: v1.0                                                       
////////////////////////////////////////////////////////////////      
`timescale 1ns/1ps                                                    
module ips2l_ddrphy_dll_update_ctrl_v1_0(
input      ddrphy_sysclk          ,
input      ddr_rstn               ,
input      dll_update_req_rst_ctrl,
output reg dll_update_ack_rst_ctrl,
input      dll_update_req_training,
output reg dll_update_ack_training,
output reg dll_update_n
);

localparam IDLE     = 2'd0;
localparam DLL_UP   = 2'd1;
localparam WAIT     = 2'd2;
localparam ACK      = 2'd3;

reg [1:0] dll_update_req_rst_ctrl_d;
reg [1:0] state;
reg update_from_training;
reg [0:0] cnt;

//*****************************************************
//update from rst_ctrl is async while update req from training is sync
always @(posedge ddrphy_sysclk or negedge ddr_rstn)
begin
   if (!ddr_rstn) begin
      dll_update_req_rst_ctrl_d <= 2'd0;
   end
   else begin
      dll_update_req_rst_ctrl_d <= {dll_update_req_rst_ctrl_d[0], dll_update_req_rst_ctrl};
   end
end

wire update_req = dll_update_req_rst_ctrl_d[1] | dll_update_req_training;

always @(posedge ddrphy_sysclk or negedge ddr_rstn)
begin
   if (!ddr_rstn) begin
      state                <= IDLE;
      update_from_training <= 1'b0;
      cnt                  <= 0;
   end
   else begin
      case (state)
         IDLE: begin
            cnt   <= 0;
            if (update_req) begin
               state <= DLL_UP;
               update_from_training <= dll_update_req_training;
            end
         end
         DLL_UP: begin //assert dll_update_n; capture DLL step
            if (cnt[0]) begin
               state <= WAIT;
               cnt   <= 0;
            end
            else
               cnt <= cnt + 1;
         end
         WAIT: begin
            if (cnt[0]) begin
               cnt   <= 0;
               state <= ACK;
            end
            else
               cnt <= cnt + 1;
         end
         ACK: begin
            cnt   <= 0;
            if (~update_req)
               state <= IDLE;
         end
         default:
            state <= IDLE;
      endcase
   end
end
   
always @(posedge ddrphy_sysclk or negedge ddr_rstn)
begin
   if (!ddr_rstn) begin
      dll_update_ack_rst_ctrl <= 1'b0;
      dll_update_ack_training <= 1'b0;
      dll_update_n            <= 1'b0;
   end
   else begin
      if (state == ACK) begin
         if (update_from_training)
            dll_update_ack_training <= 1'b1;
         else
            dll_update_ack_rst_ctrl <= 1'b1;
      end
      else begin
         dll_update_ack_training <= 1'b0;
         dll_update_ack_rst_ctrl <= 1'b0;
      end
      
      if (state == DLL_UP)
         dll_update_n <= 1'b0; //when cnt = 0/1
      else
         dll_update_n <= 1'b1;
   end
end
   
endmodule



////////////////////////////////////////////////////////////////          
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                             
// ALL RIGHTS REVERVED.                                                   
////////////////////////////////////////////////////////////////          
//Description:                                                            
//Author:  wxxiao                                                         
//History: v1.0                                                           
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_dfi_v1_0 #(
    parameter [1:0] DDR_TYPE      = 2'b00 ,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR 
    parameter MEM_ADDR_WIDTH      = 16    ,
    parameter MEM_BANKADDR_WIDTH  = 3     ,
    parameter MEM_DQ_WIDTH        = 16,
    parameter MEM_DQS_WIDTH       = 2,  
    parameter MEM_DM_WIDTH        = 2           
)(
   input                             ddrphy_sysclk        ,
   input                             ddrphy_rst_n         ,
   input                             calib_done           ,
   input                             calib_rst            ,
   input [MEM_BANKADDR_WIDTH-1:0]    calib_ba             ,
   input [MEM_ADDR_WIDTH-1:0]        calib_address        ,
   input                             calib_cs_n           ,
   input                             calib_ras_n          ,
   input                             calib_cas_n          ,
   input                             calib_we_n           ,
   input                             calib_cke            ,
   input                             calib_odt            ,
   input [3:0]                       calib_wrdata_en      ,
   input [8*MEM_DQ_WIDTH-1:0]        calib_wrdata         ,
   input [8*MEM_DM_WIDTH-1:0]        calib_wrdata_mask    ,
   input                             read_valid           ,
   input [8*MEM_DQ_WIDTH-1:0]        o_read_data          ,
   
   input                             ddrphy_update        ,
//   input [1:0]                       update_type          ,
   output reg                        update_cal_req       ,
   input                             update_done          ,
   output reg                        ddrphy_update_done   ,
   input [4*MEM_ADDR_WIDTH-1:0]      dfi_address          ,
   input [4*MEM_BANKADDR_WIDTH-1:0]  dfi_bank             ,
   input [3:0]                       dfi_cs_n             ,
   input [3:0]                       dfi_cas_n            ,
   input [3:0]                       dfi_ras_n            ,
   input [3:0]                       dfi_we_n             ,
   input [3:0]                       dfi_cke              ,
   input [3:0]                       dfi_odt              ,
   input [3:0]                       dfi_wrdata_en        ,
   input [8*MEM_DQ_WIDTH-1:0]        dfi_wrdata           ,
   input [8*MEM_DM_WIDTH-1:0]        dfi_wrdata_mask      ,
   output[8*MEM_DQ_WIDTH-1:0]        dfi_rddata           ,
   output                            dfi_rddata_valid     ,
   input                             dfi_reset_n          ,
//   input                             dfi_ctrlupd_req      ,
//   output reg                        dfi_ctrlupd_ack      ,
   output reg                        dfi_phyupd_req       ,
   input                             dfi_phyupd_ack       ,
   output reg                        dfi_init_complete    ,

   output [3:0]                       read_cmd             ,
   output reg [3:0]                   phy_ck               ,
   output                             phy_rst              ,
   output  [4*MEM_ADDR_WIDTH-1:0]     phy_addr             ,
   output  [4*MEM_BANKADDR_WIDTH-1:0] phy_ba               ,
   output  [3:0]                      phy_cs_n             ,
   output  [3:0]                      phy_ras_n            ,
   output  [3:0]                      phy_cas_n            ,
   output  [3:0]                      phy_we_n             ,
   output  [3:0]                      phy_cke              ,
   output  [3:0]                      phy_odt              ,
   output  [3:0]                      phy_wrdata_en        ,
   output  [8*MEM_DQ_WIDTH-1:0]       phy_wrdata           ,
   output  [8*MEM_DM_WIDTH-1:0]       phy_wrdata_mask       
  );

reg [4*MEM_ADDR_WIDTH-1:0]     phy_addr_d             ;
reg [4*MEM_BANKADDR_WIDTH-1:0] phy_ba_d               ;
reg [3:0]                      phy_cs_n_d             ;
reg [3:0]                      phy_ras_n_d            ;
reg [3:0]                      phy_cas_n_d            ;
reg [3:0]                      phy_we_n_d             ;
reg [3:0]                      phy_cke_d              ;
reg [3:0]                      phy_odt_d              ;
reg [3:0]                      phy_wrdata_en_d        ;
reg [8*MEM_DQ_WIDTH-1:0]       phy_wrdata_d           ;
reg [8*MEM_DM_WIDTH-1:0]       phy_wrdata_mask_d      ;
reg [4*MEM_ADDR_WIDTH-1:0]     phy_addr_d1             ;
reg [4*MEM_BANKADDR_WIDTH-1:0] phy_ba_d1               ;
reg [3:0]                      phy_cs_n_d1             ;
reg [3:0]                      phy_ras_n_d1            ;
reg [3:0]                      phy_cas_n_d1            ;
reg [3:0]                      phy_we_n_d1             ;
reg [3:0]                      phy_cke_d1              ;
reg [3:0]                      phy_odt_d1              ;
reg [3:0]                      phy_wrdata_en_d1        ;
reg [8*MEM_DQ_WIDTH-1:0]       phy_wrdata_d1           ;
reg [8*MEM_DM_WIDTH-1:0]       phy_wrdata_mask_d1      ;

wire [3:0]                       w_phy_cs_n       ;
wire [3:0]                       w_phy_ras_n      ;
wire [3:0]                       w_phy_cas_n      ;
wire [3:0]                       w_phy_we_n       ;
wire [3:0]                       w_phy_cke        ;
wire [3:0]                       w_phy_odt        ;
wire [4*MEM_ADDR_WIDTH-1:0]      w_phy_addr       ;
wire [4*MEM_BANKADDR_WIDTH-1:0]  w_phy_ba         ;
wire [3:0]                       w_phy_wrdata_en  ;
wire [8*MEM_DQ_WIDTH-1:0]        w_phy_wrdata     ;
wire [8*MEM_DM_WIDTH-1:0]        w_phy_wrdata_mask;


reg      calib_done_r;
wire     calib_done_or;

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n) 
  begin
      if(!ddrphy_rst_n) 
           calib_done_r <= 1'b0;
      else
           calib_done_r <= calib_done;
  end

assign calib_done_or = calib_done || calib_done_r;

assign  w_phy_cs_n        = calib_done ?  dfi_cs_n    :  {3'b111,calib_cs_n }  ;                                       
assign  w_phy_ras_n       = calib_done ?  dfi_ras_n   :  {3'b111,calib_ras_n} ;                                       
assign  w_phy_cas_n       = calib_done ?  dfi_cas_n   :  {3'b111,calib_cas_n} ;                                       
assign  w_phy_we_n        = calib_done ?  dfi_we_n    :  {3'b111,calib_we_n } ;                                                                              
assign  w_phy_cke         = calib_done_or ? dfi_cke   : {4{calib_cke}};
assign  w_phy_odt         = calib_done ?  dfi_odt     : {4{calib_odt}};                                                                           
assign  w_phy_addr        = calib_done ?  dfi_address : {{(3*MEM_ADDR_WIDTH){1'b0}},calib_address};                                     
assign  w_phy_ba          = calib_done ?  dfi_bank    : {{(3*MEM_BANKADDR_WIDTH){1'b0}},calib_ba};                                                                                                                                                       
assign  w_phy_wrdata_en   = calib_done ? dfi_wrdata_en : calib_wrdata_en ;     
assign  w_phy_wrdata_mask = calib_done ? dfi_wrdata_mask : calib_wrdata_mask ;                                   
assign  w_phy_wrdata      = calib_done ? dfi_wrdata : calib_wrdata;                                              

assign  phy_rst     = calib_done ?  dfi_reset_n   : calib_rst         ; 

assign read_cmd[0] = {{w_phy_cke[0],w_phy_cs_n[0],w_phy_ras_n[0],w_phy_cas_n[0],w_phy_we_n[0]}==5'b10101};
assign read_cmd[1] = {{w_phy_cke[1],w_phy_cs_n[1],w_phy_ras_n[1],w_phy_cas_n[1],w_phy_we_n[1]}==5'b10101};
assign read_cmd[2] = {{w_phy_cke[2],w_phy_cs_n[2],w_phy_ras_n[2],w_phy_cas_n[2],w_phy_we_n[2]}==5'b10101};
assign read_cmd[3] = {{w_phy_cke[3],w_phy_cs_n[3],w_phy_ras_n[3],w_phy_cas_n[3],w_phy_we_n[3]}==5'b10101};

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) begin
          phy_cs_n_d       <=4'b1111; 
          phy_ras_n_d      <=4'b1111;
          phy_cas_n_d      <=4'b1111;
          phy_we_n_d       <=4'b1111;
          phy_odt_d        <='b0;
          phy_addr_d       <='b0;
          phy_ba_d         <='b0;
          phy_wrdata_en_d  <='b0;
          phy_wrdata_d     <='b0;
          phy_wrdata_mask_d<='b0;
          if(DDR_TYPE == 2'b10)
          phy_cke_d        <=4'b1111;
          else
          phy_cke_d        <=4'b0000;
       end
       else begin
          phy_cs_n_d       <= w_phy_cs_n          ;
          phy_ras_n_d      <= w_phy_ras_n         ;
          phy_cas_n_d      <= w_phy_cas_n         ;
          phy_we_n_d       <= w_phy_we_n          ;
          phy_cke_d        <= w_phy_cke           ;
          phy_odt_d        <= w_phy_odt           ;
          phy_addr_d       <= w_phy_addr          ;
          phy_ba_d         <= w_phy_ba            ;
          phy_wrdata_en_d  <= w_phy_wrdata_en     ;
          phy_wrdata_d     <= w_phy_wrdata        ;
          phy_wrdata_mask_d<= w_phy_wrdata_mask   ;
       end
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) begin
          phy_cs_n_d1       <=4'b1111; 
          phy_ras_n_d1      <=4'b1111;
          phy_cas_n_d1      <=4'b1111;
          phy_we_n_d1       <=4'b1111;
          phy_odt_d1        <='b0;
          phy_addr_d1       <='b0;
          phy_ba_d1         <='b0;
          phy_wrdata_en_d1  <='b0;
          phy_wrdata_d1     <='b0;
          phy_wrdata_mask_d1<='b0;
          if(DDR_TYPE == 2'b10)
          phy_cke_d1        <=4'b1111;
          else
          phy_cke_d1        <=4'b0000;
       end
       else begin
          phy_cs_n_d1       <= phy_cs_n_d         ;
          phy_ras_n_d1      <= phy_ras_n_d        ;
          phy_cas_n_d1      <= phy_cas_n_d        ;
          phy_we_n_d1       <= phy_we_n_d         ;
          phy_cke_d1        <= phy_cke_d          ;
          phy_odt_d1        <= phy_odt_d          ;
          phy_addr_d1       <= phy_addr_d         ;
          phy_ba_d1         <= phy_ba_d           ;
          phy_wrdata_en_d1  <= phy_wrdata_en_d    ;
          phy_wrdata_d1     <= phy_wrdata_d       ;
          phy_wrdata_mask_d1<= phy_wrdata_mask_d  ;
       end
  end

 assign  phy_cs_n        = (DDR_TYPE == 2'b00) ? phy_cs_n_d        : phy_cs_n_d1        ;
 assign  phy_ras_n       = (DDR_TYPE == 2'b00) ? phy_ras_n_d       : phy_ras_n_d1       ;
 assign  phy_cas_n       = (DDR_TYPE == 2'b00) ? phy_cas_n_d       : phy_cas_n_d1       ;
 assign  phy_we_n        = (DDR_TYPE == 2'b00) ? phy_we_n_d        : phy_we_n_d1        ;
 assign  phy_cke         = (DDR_TYPE == 2'b00) ? phy_cke_d         : phy_cke_d1         ;
 assign  phy_odt         = (DDR_TYPE == 2'b00) ? phy_odt_d         : phy_odt_d1         ;
 assign  phy_addr        = (DDR_TYPE == 2'b00) ? phy_addr_d        : phy_addr_d1        ;
 assign  phy_ba          = (DDR_TYPE == 2'b00) ? phy_ba_d          : phy_ba_d1          ;
 assign  phy_wrdata_en   = (DDR_TYPE == 2'b00) ? phy_wrdata_en_d   : phy_wrdata_en_d1   ;
 assign  phy_wrdata_mask = (DDR_TYPE == 2'b00) ? phy_wrdata_mask_d : phy_wrdata_mask_d1 ;
 assign  phy_wrdata      = (DDR_TYPE == 2'b00) ? phy_wrdata_d      : phy_wrdata_d1      ;

assign  dfi_rddata       =  calib_done ? o_read_data : {(8*MEM_DQ_WIDTH){1'b0}} ; 
assign  dfi_rddata_valid =  calib_done ? read_valid  : 1'b0;
  
///
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)
         dfi_init_complete   <= 1'b0;
     else if(calib_done)   
         dfi_init_complete   <= 1'b1;
  end

  reg [1:0] ddrphy_update_sync ;

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
      if(!ddrphy_rst_n) 
         ddrphy_update_sync <= 2'b0 ;
      else 
        ddrphy_update_sync  <= {ddrphy_update_sync[0],ddrphy_update};
  end
//
   always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
   begin
     if(!ddrphy_rst_n)  
         dfi_phyupd_req  <= 1'b0;
     else if (update_done | ddrphy_update_done)
         dfi_phyupd_req  <= 1'b0;
//      else if(ddrphy_update_sync[1] & ~dfi_ctrlupd_req) 
     else if(ddrphy_update_sync[1])
         dfi_phyupd_req  <= 1'b1;
   end
//phy update request
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)  
        update_cal_req   <= 1'b0;
     else if (update_done | ddrphy_update_done)
        update_cal_req   <= 1'b0;
 //    else if(dfi_phyupd_ack |dfi_ctrlupd_ack )
     else if(dfi_phyupd_ack)
        update_cal_req   <= 1'b1;
  end
//
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
     if(!ddrphy_rst_n) 
         ddrphy_update_done   <= 1'b0 ;
//     else if(~ddrphy_update_sync[1])
//         ddrphy_update_done   <= 1'b0 ;
//     else if(update_done & ~ dfi_ctrlupd_req)
//     else if(update_done )
     else
         ddrphy_update_done   <= update_done;
 end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n)   
          phy_ck   <= 4'b0000;
//     else if (dfi_dram_clk_disable_tmp  & (!dfi_phyupd_req) & (!dfi_ctrlupd_req))
//          phy_ck   <= 4'b0000;
    else 
          phy_ck   <= 4'b0101; 
  end

        
endmodule




////////////////////////////////////////////////////////////////      
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                         
// ALL RIGHTS REVERVED.                                               
////////////////////////////////////////////////////////////////      
//Description:                                                        
//Author:  wxxiao                                                     
//History: v1.0                                                       
////////////////////////////////////////////////////////////////      
`timescale 1ns/1ps                                                    
module  ips2l_ddrphy_data_slice_wrlvl_v1_0 #(
   parameter [7:0] WL_MAX_STEP       = 8'hff,
   parameter [4:0] WL_MAX_CHECK      = 5'h1f
)( 
  input            ddrphy_sysclk   ,
  input            ddrphy_rst_n    ,
  
  input            wrlvl_en        , 
  input     [7:0]  init_wrlvl_step ,                               
  input            wrlvl_dqs_req   ,
  input            wl_p_ov         ,
  output reg       wrlvl_dqs_resp  ,
  output reg       wrlvl_error     ,
                                  
  output reg       wrlvl_gatei     ,
  input            wrlvl_dq        ,
  output reg       wrlvl_dqs       ,
  output reg       wrlvl_dqs_en    ,
            
  output reg [7:0] wrlvl_step      ,
  output [7:0]     wrlvl_step_gray 
  );
  
  localparam WL_IDLE        = 3'd0;
  localparam WL_CTRL        = 3'd1;
  localparam WL_SEND_WAIT   = 3'd2;
  localparam WL_SEND        = 3'd3;
  localparam WL_DQS_CHECK   = 3'd4;
  localparam WL_ERROR       = 3'd5;
  localparam WL_DONE        = 3'd6;
  
  reg [2:0]  wl_state ;
  reg [2:0]  wl_next_state;
  
  reg [7:0]  step_cnt  ;
  reg        wrlvl_dq_r;
  reg        dq_rising ;  
  reg        dq_vld    ;  
  reg [4:0]  cnt       ;
  
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)              
       wl_state   <= WL_IDLE;   
    else
       wl_state   <= wl_next_state ;
  end
       
  always @(*) 
  begin
      wl_next_state = WL_IDLE;
      case(wl_state)
           WL_IDLE  :  begin 
                         if(wrlvl_dqs_req) 
                            wl_next_state = WL_CTRL;
                         else
                            wl_next_state = WL_IDLE;
                       end       

          WL_CTRL  :  begin                                 
//                         if(man_wrlvl_dqs)                //manual mode
//                            wl_next_state = WL_SEND_WAIT;    
                         if(step_cnt == WL_MAX_STEP)   
                            wl_next_state = WL_ERROR ;  
                         else if(wl_p_ov )  
                            wl_next_state = WL_ERROR ;  
                         else                               
                           wl_next_state = WL_SEND_WAIT;     
                      end                                   
                  
      WL_SEND_WAIT : begin                                //delay 16 cycle
                        if(cnt[4])
                            wl_next_state = WL_SEND;
                        else
                            wl_next_state = WL_SEND_WAIT; 
                     end

          WL_SEND  :  begin
                             wl_next_state = WL_DQS_CHECK ;
                       end     
                          
      WL_DQS_CHECK :  begin
                         if(cnt == WL_MAX_CHECK)
                            begin  
 //                             if(man_wrlvl_dqs)
 //                                wl_next_state = WL_CTRL; 
                              if(dq_rising)
                                 wl_next_state = WL_DONE;
                              else
                                 wl_next_state = WL_CTRL;
                            end
                         else
                         wl_next_state =  WL_DQS_CHECK;        
                       end
                                    
           WL_ERROR   :    wl_next_state = WL_ERROR ;
                        
           WL_DONE    :  begin
                            if(~wrlvl_dqs_req)
                               wl_next_state = WL_IDLE    ;
                            else
                               wl_next_state = WL_DONE    ;
                         end
       endcase
  end
       
///output           
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) 
         wrlvl_dqs_en  <= 1'b0 ;
     else if(wl_next_state != WL_IDLE)
         wrlvl_dqs_en  <= 1'b1;
     else
         wrlvl_dqs_en  <= 1'b0;
  end

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n) 
        cnt   <=  5'h0;
    else if((wl_next_state == WL_DQS_CHECK)|(wl_next_state ==WL_SEND_WAIT))
        cnt   <= cnt + 5'h1;
    else
        cnt   <= 5'h0; 
  end
     
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                         
       wrlvl_dqs   <= 1'b0;
    else 
       wrlvl_dqs   <= (wl_state == WL_SEND);
  end
       
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
   if(!ddrphy_rst_n)                                   
     wrlvl_dqs_resp  <= 1'b0;                          
   else                                                
     wrlvl_dqs_resp  <= (wl_next_state == WL_DONE);
 end
//       
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
   if(!ddrphy_rst_n)                                   
      step_cnt  <= 8'h0;
   else if (wl_next_state == WL_IDLE)
      step_cnt  <= init_wrlvl_step;  
   else if ((cnt==WL_MAX_CHECK) & (~dq_rising))
      step_cnt  <= step_cnt + 8'h1;   
 end
     
 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
 begin
   if(!ddrphy_rst_n)
      wrlvl_gatei   <= 1'b0 ;
   else if(wl_next_state == WL_CTRL)
      wrlvl_gatei   <= 1'b1;
   else if((wl_next_state==WL_SEND_WAIT) & (cnt==5'ha))
      wrlvl_gatei   <= 1'b0;
 end
 
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                                   
        wrlvl_step  <= init_wrlvl_step;
    else if (wrlvl_en == 0)
        wrlvl_step <= init_wrlvl_step;
      else if((wl_state == WL_SEND_WAIT) & (cnt==5'h4))
        wrlvl_step  <= step_cnt ;
  end
        
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)  
       dq_vld   <= 1'b0;
    else if((wl_state == WL_DQS_CHECK)&(cnt==5'h8))
       dq_vld   <= 1'b1; 
    else if(wl_state == WL_DONE)
       dq_vld   <= 1'b0;
  end
  
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                          
       wrlvl_dq_r  <= 1'b1;  //wl_setting;   //1'b1; //0;
    else if(wrlvl_dqs_en) 
      if(dq_vld)
       wrlvl_dq_r  <= wrlvl_dq ;
      else
        wrlvl_dq_r <= 1'b0;
  end
       
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                          
       dq_rising  <= 1'b0;
    else if(wl_state == WL_DONE)
       dq_rising  <= 1'b0;
    else if(dq_vld & wrlvl_dq &(~wrlvl_dq_r))
       dq_rising  <= 1'b1;
  end
       
  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
    if(!ddrphy_rst_n)                        
        wrlvl_error   <= 1'b0;
    else 
        wrlvl_error   <= (wl_state == WL_ERROR);
  end

assign wrlvl_step_gray[7] = wrlvl_step[7];
assign wrlvl_step_gray[6] = wrlvl_step[7]^wrlvl_step[6];
assign wrlvl_step_gray[5] = wrlvl_step[6]^wrlvl_step[5];
assign wrlvl_step_gray[4] = wrlvl_step[5]^wrlvl_step[4];
assign wrlvl_step_gray[3] = wrlvl_step[4]^wrlvl_step[3];
assign wrlvl_step_gray[2] = wrlvl_step[3]^wrlvl_step[2];
assign wrlvl_step_gray[1] = wrlvl_step[2]^wrlvl_step[1];
assign wrlvl_step_gray[0] = wrlvl_step[1]^wrlvl_step[0];

endmodule




////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_data_slice_wrcal_v1_0 (
  input        ddrphy_sysclk     ,
  input        ddrphy_rst_n      ,
  output reg   wrcal_check_pass  ,
  input        write_calibration ,
  input        wrcal_move_en     ,
  output reg   wrcal_move_done   ,
  input        wrdata_check_pass ,
  
  input  [7:0] dll_90_gray       ,
  input  [7:0] wrlvl_step        ,
  output [7:0] dll_90_bin        ,
  output [7:0] wl_p_dll_gray     ,
  output reg [7:0]  wl_p_dll_bin ,
  output       wl_p_ov           
);

  localparam IDLE            = 0;  
  localparam INIT_ADJ        = 1; 
  localparam CHECK_LEFT      = 2; 
  localparam MOVE_LEFT       = 3;
  localparam INIT_ADJ_AGAIN  = 4;
  localparam ADJ_AGAIN_DONE  = 5;
  localparam CHECK_RIGHT     = 6; 
  localparam MOVE_RIGHT      = 7; 
  localparam CENTER          = 8;
  localparam CENTER_ADJ_DONE = 9;
  localparam CENTER_WR       = 10;
  localparam CALIB_WAIT      = 11;
  localparam MOVE_DONE       = 12;
  localparam WR_ERROR        = 13;
  

`ifdef SIMULATION 
localparam ADJ_STEP = 8'd5;
`else                   
localparam ADJ_STEP = 8'd1;
`endif

reg [3:0]  state;
reg [7:0]  cnt;
//reg [7:0]  wl_p_dll_bin;
reg        wrcal_ov;

wire [8:0] init_wl_p_step;
reg  [8:0] dq_step_add;

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
    if(!ddrphy_rst_n)
    begin
        state <= IDLE;
        cnt <= 8'd0;
    end
    else 
    begin
        case(state)
            IDLE       : begin
                cnt <= 8'd0;
                if(write_calibration)
                state <= INIT_ADJ;
                else 
                state <= IDLE;
            end
            
            INIT_ADJ   : begin
               state <= CHECK_LEFT;
               cnt <= 8'd0;
            end
            
            CHECK_LEFT : begin
                cnt <= 8'd0;
                if(~write_calibration)
                state <= IDLE;
                else if(wrcal_move_en)
                begin
                    if((~wrdata_check_pass)|| wrcal_ov)
                    state <= INIT_ADJ_AGAIN;
                    else
                    state <= MOVE_LEFT;
                end
            end
            
            MOVE_LEFT  : begin
               if (cnt[3]) begin
                  if (~wrcal_move_en)
                     state <= CHECK_LEFT;
                  end
                  else
                  cnt <= cnt + 1;
               end
               
            INIT_ADJ_AGAIN   : begin
               if (cnt[3]) begin
//                  if (wl_p_dll_bin == init_wl_p_step)
                     state <= ADJ_AGAIN_DONE;
                  end
                  else
                  cnt <= cnt + 1;
            end

            ADJ_AGAIN_DONE : begin
               cnt <= 8'd0;
               if(~wrcal_move_en)
               state <= CHECK_RIGHT;
            end
            
            CHECK_RIGHT: begin
                cnt <= 8'd0;
                if(wrcal_move_en)
                begin
                    if((~wrdata_check_pass)|| wrcal_ov)
                    state <= CENTER;
                    else
                    state <= MOVE_RIGHT;
                end               
            end
            
            MOVE_RIGHT : begin
               if (cnt[3]) begin
                  if (~wrcal_move_en)
                     state <= CHECK_RIGHT;
                  end
                  else
                  cnt <= cnt + 1;              
            end
            
            CENTER     : begin
               if (cnt[3]) begin
//                  if (wl_p_dll_bin == dq_step_add[8:1])
                     state <= CENTER_ADJ_DONE;
                  end
                  else
                  cnt <= cnt + 1;                
            end
            
            CENTER_ADJ_DONE: begin
               cnt <= 8'd0;
               if(~wrcal_move_en)
               state <= CENTER_WR;
            end
            
            CENTER_WR : begin
                cnt <= 8'd0;
                if(wrcal_move_en)
                begin
                    if(wrdata_check_pass)
                    state <= CALIB_WAIT;
                    else
                    state <= WR_ERROR;
                end               
            end
            
            CALIB_WAIT : begin
                cnt <= 8'd0;
                if(~write_calibration)
                state <= MOVE_DONE;
                else 
                state <= CALIB_WAIT;               
            end
            
            MOVE_DONE : begin
                cnt <= 8'd0;
                if(write_calibration)
                state <= IDLE;                
            end
            
            WR_ERROR: state <= WR_ERROR; 
            default:
            state <= IDLE;
    endcase
    end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
  if(!ddrphy_rst_n) begin
      wl_p_dll_bin <= init_wl_p_step[7:0];
      wrcal_ov <= 0;
  end
  else begin
        case (state)
           IDLE,
           INIT_ADJ: begin
              wl_p_dll_bin <= init_wl_p_step[7:0];
              wrcal_ov <= 0;
           end
           INIT_ADJ_AGAIN: begin
              wrcal_ov <= 0;
  //            if(wl_p_dll_bin < init_wl_p_step)
  //            wl_p_dll_bin <= wl_p_dll_bin + 8'd1;
  //            else if(wl_p_dll_bin > init_wl_p_step)
  //            wl_p_dll_bin <= wl_p_dll_bin - 8'd1;
              wl_p_dll_bin <= init_wl_p_step[7:0];
           end
           MOVE_LEFT: begin
              if(cnt == 8'h0) begin
                  if(wl_p_dll_bin > (ADJ_STEP - 8'd1)) begin
                      wl_p_dll_bin <= wl_p_dll_bin - ADJ_STEP;
                      wrcal_ov <= 0;
                  end
                  else begin
                      wl_p_dll_bin <= wl_p_dll_bin;
                      wrcal_ov <= 1;
                  end
             end
           end       
           MOVE_RIGHT: begin
              if(cnt == 8'h0) begin
                  if(wl_p_dll_bin < (8'd255 - ADJ_STEP)) begin
                      wl_p_dll_bin <= wl_p_dll_bin + ADJ_STEP;
                      wrcal_ov <= 0;
                  end
                  else begin
                      wl_p_dll_bin <= wl_p_dll_bin;
                      wrcal_ov <= 1;
                  end
              end
           end
           CENTER: begin
              wrcal_ov <= 0;
  //            if(wl_p_dll_bin < dq_step_add[8:1])
  //            wl_p_dll_bin <= wl_p_dll_bin + 8'd1;
  //            else if(wl_p_dll_bin > dq_step_add[8:1])
  //            wl_p_dll_bin <= wl_p_dll_bin - 8'd1;
              wl_p_dll_bin <= dq_step_add[8:1];
           end         
           default: begin
              wl_p_dll_bin <= wl_p_dll_bin;
              wrcal_ov <= wrcal_ov;
           end
        endcase
          
  end
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if(!ddrphy_rst_n)
   wrcal_check_pass <= 0;
   else if(state == CALIB_WAIT)
   wrcal_check_pass <= 1;
   else
   wrcal_check_pass <= 0;
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
   if(!ddrphy_rst_n)
   wrcal_move_done <= 0;
   else if(wrcal_check_pass == 1)
   wrcal_move_done <= 1;
   else if(((state == MOVE_LEFT) & cnt[3])|((state == MOVE_RIGHT) & cnt[3]) |
            (state == ADJ_AGAIN_DONE) | (state == CENTER_ADJ_DONE) | (state == CALIB_WAIT))
   wrcal_move_done <= 1;
   else
   wrcal_move_done <= 0;
end

always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
begin
  if(!ddrphy_rst_n) begin
      dq_step_add <= 9'd0;
  end
  else begin
      if(state == IDLE)
      dq_step_add <= 9'd0;
      else if((state == CHECK_LEFT)&&(wrcal_move_en)&&((~ wrdata_check_pass) || wrcal_ov))
      dq_step_add <= dq_step_add + wl_p_dll_bin;
      else if((state == CHECK_RIGHT)&&(wrcal_move_en)&&((~ wrdata_check_pass) || wrcal_ov))
      dq_step_add <= dq_step_add + wl_p_dll_bin;
  end
end


assign dll_90_bin[7] = dll_90_gray[7];
assign dll_90_bin[6] = dll_90_bin[7]^dll_90_gray[6];
assign dll_90_bin[5] = dll_90_bin[6]^dll_90_gray[5];
assign dll_90_bin[4] = dll_90_bin[5]^dll_90_gray[4];
assign dll_90_bin[3] = dll_90_bin[4]^dll_90_gray[3];
assign dll_90_bin[2] = dll_90_bin[3]^dll_90_gray[2];
assign dll_90_bin[1] = dll_90_bin[2]^dll_90_gray[1];
assign dll_90_bin[0] = dll_90_bin[1]^dll_90_gray[0];

assign init_wl_p_step = {1'b0,dll_90_bin} + {1'b0,wrlvl_step};
assign wl_p_ov = init_wl_p_step[8];

assign wl_p_dll_gray[7] = wl_p_dll_bin[7];
assign wl_p_dll_gray[6] = wl_p_dll_bin[7]^wl_p_dll_bin[6];
assign wl_p_dll_gray[5] = wl_p_dll_bin[6]^wl_p_dll_bin[5];
assign wl_p_dll_gray[4] = wl_p_dll_bin[5]^wl_p_dll_bin[4];
assign wl_p_dll_gray[3] = wl_p_dll_bin[4]^wl_p_dll_bin[3];
assign wl_p_dll_gray[2] = wl_p_dll_bin[3]^wl_p_dll_bin[2];
assign wl_p_dll_gray[1] = wl_p_dll_bin[2]^wl_p_dll_bin[1];
assign wl_p_dll_gray[0] = wl_p_dll_bin[1]^wl_p_dll_bin[0];

endmodule




////////////////////////////////////////////////////////////////     
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                        
// ALL RIGHTS REVERVED.                                              
////////////////////////////////////////////////////////////////     
//Description:                                                       
//Author:  wxxiao                                                    
//History: v1.0                                                      
////////////////////////////////////////////////////////////////     
`timescale 1ns/1ps                                                   
module  ips2l_ddrphy_data_slice_v1_0 #(
   parameter [1:0] DDR_TYPE      = 2'b00 ,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR
   parameter TEST_DATA_PATTERN0  = 64'h55_aa_55_aa_08_f7_08_f7,
   parameter TEST_DATA_PATTERN1  = 64'h7f_9f_7f_9f_80_fe_80_fe,
   parameter TEST_DATA_PATTERN2  = 64'hf0_0f_f0_0f_01_ff_01_ff,
   parameter TEST_DATA_PATTERN3  = 64'hdf_aa_df_aa_55_aa_55_aa,
   parameter GATE_MODE           = 0    ,
   parameter SC_LDO_CTRL         = 2'b00,
   parameter SC_DLY_2X           = 1'b0 ,    //1'b0  1x delay chain, 1'b1 2x delay chain   
   parameter WL_MAX_STEP         = 8'hff,
   parameter WL_MAX_CHECK        = 5'h1f,
   parameter MIN_DQSI_WIN        = 9'd10   
)( 
  input [4:0]      mc_rl                ,
  input            force_read_clk_ctrl  ,
  input [2:0]      init_read_clk_ctrl   ,
  input [3:0]      init_slip_step       ,
  input            force_samp_position  ,
  input [7:0]      init_samp_position_even, 
  input [7:0]      init_samp_position_odd,
 
  input            ddrphy_sysclk        ,
  input            ddrphy_rst_n         ,
  input            phy_clk_p            ,
  input            sysclk_p             ,
  input            ddrphy_dqs_rst       ,
  input            ddrphy_dqs_training_rstn,
  input            ddrphy_iol_rst       ,
//wrlvl   
  input            wrlvl_en             ,
  input [7:0]      init_wrlvl_step      ,
  input            wrlvl_dqs_req        ,
  output           wrlvl_dqs_resp       ,
  output           wrlvl_error          ,  
//dqs    
  input            gatecal_start        ,
  output           gate_check_pass      ,
  output           gate_adj_done        ,
  output           gate_cal_error       ,
  input            gate_move_en         ,
  input            rddata_cal           ,
  output           rddata_check_pass    ,
  
  output           wrcal_check_pass     ,
  input            write_calibration    ,
  input            wrcal_move_en        ,
  output           wrcal_move_done      ,
    
  input            eye_calibration      ,
  output           eyecal_check_pass    ,
  output           eyecal_move_done     ,
  input            eyecal_move_en       ,

  input [3:0]      read_cmd             ,

  input [1:0]      comp_val             ,
  input            comp_dir             ,
  input            dqs_gate_comp_en     ,
  output           dqs_gate_comp_done   ,
  output [1:0]     dqs_drift            ,
  output           dll_lock             ,
  input            dll_rstn             ,
  input            dll_freeze           ,
  input            dll_update_n         ,

  input            init_adj_rdel        ,
  output           adj_rdel_done        ,
  input            rdel_calibration     ,
  output           rdel_calib_done      ,
  output           rdel_calib_error     ,
  input            rdel_move_en         ,
  output           rdel_move_done       ,
  input            bitslip_ctrl         ,
//rdata  
  output    	   read_valid           ,
  output [63:0]    read_data            ,
//wdata
  input [3:0]      phy_wrdata_en        ,
  input [7:0]      phy_wrdata_mask      ,
  input [63:0]     phy_wrdata           ,
  inout            dqs                  ,
  inout            dqs_n                ,
  inout [7:0]      dq                   ,
  output           dm                   ,
  output [65:0]    debug_data
  ); 

                              
//wl
  wire            wrlvl_dqs       ;
  wire            wrlvl_dqs_en    ;
                                   
  wire            dqs_gate_vld    ;
//rdel 
  wire            rdel_cal_vld    ;

wire wrlvl_dq;
wire rdel_ov;
wire ddrphy_read_valid;
wire [63:0] ddrphy_rdata; 
wire ddrphy_dgts;
wire ddrphy_gatei;
wire rdel_rvalid0;
wire rdel_rvalid1;
wire [7:0] wrlvl_step;
wire [2:0] rdel_ctrl;
wire [3:0] dqs_gate_ctrl;
wire [2:0] read_clk_ctrl; 
wire [7:0] adj_wrdq_en     ;
wire [63:0]adj_wrdq        ;
wire [7:0] adj_wrdqs_en    ;
wire [7:0] adj_wrdqs       ;
wire [7:0] adj_wrdata_mask ;
wire wclk;
wire wclk_del;
wire ioclk_dq;
wire dqsi_del;
wire dqsib_del;
wire [2:0] ififo_waddr;
wire [2:0] ififo_raddr;
wire dqs_in;
wire dqso;
wire dqsot;
wire dqst;
wire [7:0] pado;
wire [7:0] padot;
wire padt;
wire [7:0] dq_in;
wire [7:0] dq_in_dly;
wire pado_dm;
wire padot_dm;

wire [3:0] coarse_slip_step;  
wire [3:0] gate_win_size;

wire [7:0] dll_90_bin;
wire [7:0] dll_90_gray;
wire [7:0] dll_45_gray;
wire [7:0] wl_p_dll_gray;
wire [7:0] wrlvl_step_gray;
wire [7:0] dqs_even_gray;
wire [7:0] dqs_odd_gray;
wire dqs_gate_sample;
wire wl_p_ov;

wire wrdata_check_pass;

wire phy_clk_2x_n     ;
wire phy_clk_2x_p     ;
wire sysclkb_n        ;
wire sysclkb_p        ;
wire [7:0] idly_set   ;
wire wrlvl_gatei      ;
wire [7:0] dqs_even_bin        ;
wire [7:0] dqs_odd_bin         ;
wire [8:0] total_margin_even   ;
wire [8:0] total_margin_odd    ;
wire [7:0] wl_p_dll_bin        ;   
wire wrcal_gatei   ;
wire do_cas_out;
wire to_cas_out;
wire term_cas_out;


assign debug_data[3:0] = coarse_slip_step;
assign debug_data[6:4] = read_clk_ctrl[2:0];
assign debug_data[10:7] = gate_win_size[3:0];
assign debug_data[11]  = gate_check_pass;
assign debug_data[12]  = rddata_check_pass;
assign debug_data[20:13]  = dqs_even_bin;                                                                                                        
assign debug_data[28:21] = dqs_odd_bin;
assign debug_data[37:29] = total_margin_even;
assign debug_data[46:38] = total_margin_odd ;
assign debug_data[47]    = eyecal_check_pass;
assign debug_data[55:48] = wrlvl_step;
assign debug_data[56]    = wl_p_ov;
assign debug_data[57]    = wrlvl_dq;
assign debug_data[65:58] = wl_p_dll_bin;

assign wrlvl_dq = |dq_in_dly;
assign wrcal_gatei = wrcal_move_en;

assign ddrphy_gatei = (write_calibration == 1) ? wrcal_gatei : wrlvl_gatei;

 ips2l_ddrphy_data_slice_wrlvl_v1_0 #(
  .WL_MAX_STEP      (WL_MAX_STEP    ),
  .WL_MAX_CHECK     (WL_MAX_CHECK   )
 ) ddrphy_data_slice_wrlvl(               
  .ddrphy_sysclk    (ddrphy_sysclk  ),
  .ddrphy_rst_n     (ddrphy_rst_n   ),
                                    
  .wrlvl_en         (wrlvl_en       ),
  .init_wrlvl_step  (init_wrlvl_step),   
  .wrlvl_dqs_req    (wrlvl_dqs_req  ),
  .wrlvl_dqs_resp   (wrlvl_dqs_resp ),
  .wl_p_ov          (wl_p_ov        ),
  .wrlvl_error      (wrlvl_error    ),
                                    
  .wrlvl_gatei      (wrlvl_gatei    ),
  .wrlvl_dq         (wrlvl_dq       ),
  .wrlvl_dqs        (wrlvl_dqs      ),
  .wrlvl_dqs_en     (wrlvl_dqs_en   ),
                                    
  .wrlvl_step       (wrlvl_step     ),
  .wrlvl_step_gray  (wrlvl_step_gray)
  );

ips2l_ddrphy_data_slice_wrcal_v1_0  ddrphy_data_slice_wrcal(
  .ddrphy_sysclk     (ddrphy_sysclk     ),
  .ddrphy_rst_n      (ddrphy_rst_n      ),
  .wrcal_check_pass  (wrcal_check_pass  ),
  .write_calibration (write_calibration ),
  .wrcal_move_en     (wrcal_move_en     ),
  .wrcal_move_done   (wrcal_move_done   ),
  .wrdata_check_pass (wrdata_check_pass ),
                                        
  .dll_90_gray       (dll_90_gray       ),
  .wrlvl_step        (wrlvl_step        ),
  .dll_90_bin        (dll_90_bin        ),
  .wl_p_dll_gray     (wl_p_dll_gray     ),
  .wl_p_dll_bin      (wl_p_dll_bin      ),
  .wl_p_ov           (wl_p_ov           )
);


 ips2l_ddrphy_data_slice_dqs_gate_cal_v1_0 #(
  .GATE_MODE            (GATE_MODE           )
 )ddrphy_data_slice_dqs_gate_cal(
  .mc_rl                (mc_rl               ),
  .init_read_clk_ctrl   (init_read_clk_ctrl  ),       
  .init_slip_step       (init_slip_step      ),
  .force_read_clk_ctrl  (force_read_clk_ctrl ),       

  .ddrphy_sysclk        (ddrphy_sysclk       ),
  .ddrphy_rst_n         (ddrphy_rst_n        ),

  .gatecal_start        (gatecal_start       ),
  .gate_check_pass      (gate_check_pass     ),
  .gate_adj_done        (gate_adj_done       ),
  .gate_cal_error       (gate_cal_error      ),
  .gate_move_en         (gate_move_en        ), 
  .rddata_cal           (rddata_cal          ),

  .read_cmd             (read_cmd            ), 

  .comp_val             (comp_val            ),
  .comp_dir             (comp_dir            ),
  .dqs_gate_comp_en     (dqs_gate_comp_en    ),
  .dqs_gate_comp_done   (dqs_gate_comp_done  ),
  
  .dbg_dqs_gate_cal     (                    ),
  .ddrphy_dgts          (ddrphy_dgts         ), 
  .dqs_gate_sample      (dqs_gate_sample     ),
  .dqs_gate_vld         (dqs_gate_vld        ),
  .coarse_slip_step     (coarse_slip_step    ),
  .gate_win_size        (gate_win_size       ),
  .dqs_gate_ctrl        (dqs_gate_ctrl       ),
  .read_clk_ctrl        (read_clk_ctrl       )
  );     

 ips2l_ddrphy_dqsi_rdel_cal_v1_0 #(
  .MIN_DQSI_WIN             (MIN_DQSI_WIN        )
 )ddrphy_dqsi_rdel_cal(  
  .force_samp_position      (force_samp_position ), 
  .init_samp_position_even  (init_samp_position_even),
  .init_samp_position_odd   (init_samp_position_odd),

  .ddrphy_sysclk            (ddrphy_sysclk       ),
  .ddrphy_rst_n             (ddrphy_rst_n        ),
  .dll_90_bin               (dll_90_bin          ),
  .rdel_rvalid0             (rdel_rvalid0        ),
  .rdel_rvalid1             (rdel_rvalid1        ),
  .init_adj_rdel            (init_adj_rdel       ),  
  .adj_rdel_done            (adj_rdel_done       ),     
                            
  .rdel_calibration         (rdel_calibration    ),
  .rdel_calib_done          (rdel_calib_done     ),
  .rdel_calib_error         (rdel_calib_error    ),    
                            
  .rdel_move_en             (rdel_move_en        ),
  .rdel_move_done           (rdel_move_done      ), 
                            
  .eye_calibration          (eye_calibration     ),
  .eyecal_check_pass        (eyecal_check_pass   ),
  .eyecal_move_done         (eyecal_move_done    ),
  .eyecal_move_en           (eyecal_move_en      ),
                            
  .rdel_cal_vld             (rdel_cal_vld        ),
  .dqs_even_gray            (dqs_even_gray       ),
  .dqs_odd_gray             (dqs_odd_gray        ),
  .dqs_even_bin             (dqs_even_bin        ),
  .dqs_odd_bin              (dqs_odd_bin         ),
  .total_margin_even        (total_margin_even   ),
  .total_margin_odd         (total_margin_odd    ),
  .idly_set                 (idly_set            )
);
                                                                 
 ips2l_ddrphy_dqs_rddata_align_v1_0 #(
  .TEST_DATA_PATTERN0   (TEST_DATA_PATTERN0  ),
  .TEST_DATA_PATTERN1   (TEST_DATA_PATTERN1  ),
  .TEST_DATA_PATTERN2   (TEST_DATA_PATTERN2  ),
  .TEST_DATA_PATTERN3   (TEST_DATA_PATTERN3  )
 )ddrphy_dqs_rddata_align(
  .ddrphy_sysclk        (ddrphy_sysclk       ),
  .ddrphy_rst_n         (ddrphy_rst_n        ),

  .ddrphy_read_valid    (ddrphy_read_valid   ),
  .ddrphy_rdata         (ddrphy_rdata        ),
  .read_valid           (read_valid          ),
  .read_data            (read_data           ),
  .gate_adj_done        (gate_adj_done       ),
  .rddata_check_pass    (rddata_check_pass   ),
  .bitslip_ctrl         (bitslip_ctrl        ),
  .bitslip_dq           (bitslip_dq          ),

  .dqs_gate_vld         (dqs_gate_vld        ),  
  
  .write_calibration    (write_calibration   ),
  .wrcal_move_done      (wrcal_move_done     ),
  .wrdata_check_pass    (wrdata_check_pass   ),
  
  .eye_calibration      (eye_calibration     ),
  .eyecal_move_done     (eyecal_move_done    ),
  
  .rdel_cal_vld         (rdel_cal_vld        ),
  .rdel_rvalid0         (rdel_rvalid0        ), 
  .rdel_rvalid1         (rdel_rvalid1        )
   );

 ips2l_ddrphy_wdata_path_adj_v1_0 #(
  .DQ_WIDTH          (8               )
 )ddrphy_wdata_path_adj(  
  .ddrphy_sysclk     (ddrphy_sysclk   ),
  .ddrphy_rst_n      (ddrphy_rst_n    ), 
                                      
  .phy_wrdata_en     (phy_wrdata_en   ),
  .phy_wrdata_mask   (phy_wrdata_mask ),
  .phy_wrdata        (phy_wrdata      ),
  .wrlvl_dqs_en      (wrlvl_dqs_en    ),
  .wrlvl_dqs         (wrlvl_dqs       ),
                                      
  .adj_wrdq_en       (adj_wrdq_en     ),
  .adj_wrdq          (adj_wrdq        ),
  .adj_wrdqs_en      (adj_wrdqs_en    ),
  .adj_wrdqs         (adj_wrdqs       ),
  .adj_wrdata_mask   (adj_wrdata_mask )
   );

GTP_DDC_E2 #(
 .CLKA_GATE_EN     ("TRUE"),         
 .WCLK_DELAY_SEL   ("FALSE"),        
 .DDC_MODE         ("QUAD_RATE"),    
 .R_EXTEND         ("FALSE"),        
 .DELAY_SEL        (SC_DLY_2X),      
 .GRS_EN           ("TRUE"),         
 .IFIFO_GENERIC    ("FALSE"),        
 .RADDR_INIT       (3'b000),         
 .DATA_RATE        (SC_LDO_CTRL)     
)u_ddc_dq(
    //output
  .WCLK                (wclk),
  .WCLK_DELAY          (wclk_del),
  .DQSI_DELAY          (dqsi_del),
  .DQSIB_DELAY         (dqsib_del),
  .DGTS                (ddrphy_dgts  ),
  .IFIFO_WADDR         (ififo_waddr  ),
  .IFIFO_RADDR         (ififo_raddr  ),
  .READ_VALID          (ddrphy_read_valid),
  .DQS_DRIFT           (dqs_drift),
  .DRIFT_DETECT_ERR    (),
  .DQS_DRIFT_STATUS    (),
  .DQS_SAMPLE          (dqs_gate_sample),
  .RST                 (ddrphy_dqs_rst),
  .RST_TRAINING_N      (ddrphy_dqs_training_rstn),
  .CLKA                (phy_clk_p),
  .CLKB                (sysclk_p),
  .DQSI                (dqs_in),
  .DQSIB               ( ),
  .DELAY_STEP0         (wrlvl_step_gray),
  .DELAY_STEP1         (dqs_even_gray),
  .DELAY_STEP2         (dqs_odd_gray),
  .DELAY_STEP3         (dll_45_gray),
  .DELAY_STEP4         (wl_p_dll_gray),
  .DQS_GATE_CTRL       (dqs_gate_ctrl),
  .GATE_SEL            (read_clk_ctrl[2]),
  .CLK_GATE_CTRL       (read_clk_ctrl[1:0]),
  .CLKA_GATE           (ddrphy_gatei)
 );

GTP_DLL_E2 #(
   .GRS_EN              ("TRUE"),         
   .CAL_INIT            (8'b00011111),    
   .DELAY_STEP_OFFSET   (0),          
   .DELAY_SEL           (SC_DLY_2X),      
   .FAST_LOCK           ("FALSE"),        
   .FDIV                (2'b10),          
   .INT_CLK             (1'b0),           
   .UPD_DLY             (2'b01)           
)u_dll_dq(
    .CLKIN         (phy_clk_p),           // IOCLK_2X
    .SYS_CLK       (sysclk_p),            // SYSCLK
    .PWD           (dll_freeze),          // DLL_FREEZE
    .RST           (~dll_rstn),     
    .UPDATE_N      (dll_update_n),     
    .LOCK          (dll_lock),     
    .DELAY_STEP    (dll_90_gray),                    // DLL_90CODE_GRAY
    .DELAY_STEP1   (dll_45_gray)                  // DLL_45CODE_GRAY
    );

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),               
   .OSERDES_MODE     ("HMSDR8TO1"), 
   .TSERDES_EN       ("TRUE"),       
   .UPD0_SHIFT_EN    ("FALSE"),                 
   .UPD1_SHIFT_EN    ("FALSE"),                 
   .INIT_SET         (2'b00),                
   .GRS_TYPE_DQ      ("RESET"),              
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),        
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),        
   .GRS_TYPE_TQ      ("RESET"),              
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),        
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),        
   .TRI_EN           ("TRUE"),              
   .TBYTE_EN         ("FALSE"),              
   .MIPI_EN          ("FALSE"),              
   .OCASCADE_EN      ("FALSE")               
)u_tserdes0_dqs(
   .RST             (ddrphy_iol_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (sysclk_p),
   .SERCLK          (phy_clk_p),
   .OCLK            (wclk),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_wrdqs_en),
   .TI              (2'b00),
   .TBYTE_IN        (),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (),
   .DO              (dqst)
);

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"),  
   .TSERDES_EN       ("TRUE"),         
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("FALSE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_tserdes1_dq(
   .RST             (ddrphy_iol_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (sysclk_p),
   .SERCLK          (phy_clk_p),
   .OCLK            (wclk_del),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_wrdq_en),
   .TI              (2'b00),
   .TBYTE_IN        (),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (),
   .DO              (padt)
);

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"), 
   .TSERDES_EN       ("FALSE"),          
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_dqs(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (sysclk_p),
   .SERCLK          (phy_clk_p),
   .OCLK            (wclk),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_wrdqs),
   .TI              (),
   .TBYTE_IN        (dqst),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (dqsot),
   .DO              (dqso)
);


generate
if (DDR_TYPE == 2'b10) begin     //LPDDR
GTP_IOBUF u_iobuf_dqs(
   .O                                    (dqs_in),
   .IO                                   (dqs),   
   .I                                    (dqso),
   .T                                    (dqsot)
);
end
else begin
GTP_IOBUFCO u_iobufco_dqs(
    .O            (dqs_in),
    .IO           (dqs   ), 
    .IOB          (dqs_n ),
    .I            (dqso  ), 
    .T            (dqsot  )
    );
end
endgenerate


//DQ
genvar i;
generate
for (i=0; i<8; i=i+1)
begin: dq_loop

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"), 
   .TSERDES_EN       ("FALSE"),          
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_dq(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (sysclk_p),
   .SERCLK          (phy_clk_p),
   .OCLK            (wclk_del),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_wrdq[i*8+7: i*8]),
   .TI              (),
   .TBYTE_IN        (padt),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padot[i]),
   .DO              (pado[i])
);

 GTP_IODELAY_E2 #(
 .DELAY_STEP_SEL     ("PORT"), 
 .DELAY_STEP_VALUE   (8'd0)   
 )u_iodelay_dq(
 .DO                 (dq_in_dly[i]),
 .DI                 (dq_in[i]),
 .DELAY_SEL          (SC_DLY_2X),
 .DELAY_STEP         (idly_set)  
 );

GTP_ISERDES_E2 #(
    .ISERDES_MODE     ("HMDDR1TO8"),         
    .CASCADE_MODE     ("MASTER"),           
    .BITSLIP_EN       ("TRUE"),           
    .GRS_EN           ("TRUE"),            
    .NUM_ICE          (1'b0),              
    .GRS_TYPE_Q0      ("RESET"),           
    .GRS_TYPE_Q1      ("RESET"),           
    .GRS_TYPE_Q2      ("RESET"),           
    .GRS_TYPE_Q3      ("RESET"),           
    .LRS_TYPE_Q0      ("ASYNC_RESET"),     
    .LRS_TYPE_Q1      ("ASYNC_RESET"),     
    .LRS_TYPE_Q2      ("ASYNC_RESET"),     
    .LRS_TYPE_Q3      ("ASYNC_RESET")      
)u_iserdes_dq(
    .RST             (ddrphy_dqs_rst),
    .ICE0            (1'b1),
    .ICE1            (1'b1),
    .DESCLK          (phy_clk_p),
    .ICLK            (dqsi_del),
    .OCLK            (wclk_del),
    .ICLKDIV         (sysclk_p),
    .DI              (dq_in_dly[i]),
    .BITSLIP         (bitslip_dq),
    .ISHIFTIN0       (1'b0),
    .ISHIFTIN1       (1'b0),
    .IFIFO_WADDR     (ififo_waddr),
    .IFIFO_RADDR     (ififo_raddr),
    .DO              (ddrphy_rdata[i*8+7:i*8]),
    .ISHIFTOUT0      (),
    .ISHIFTOUT1      ()
);

// input parts  
GTP_IOBUF u_iobuf_dq
     (
     .O  (dq_in[i]),
     .IO (dq[i]),
     .I  (pado[i]),
     .T  (padot[i])
     );   

end
endgenerate

GTP_OSERDES_E2 #(
   .GRS_EN           ("TRUE"),                
   .OSERDES_MODE     ("HMSDR8TO1"), 
   .TSERDES_EN       ("FALSE"),          
   .UPD0_SHIFT_EN    ("FALSE"),                  
   .UPD1_SHIFT_EN    ("FALSE"),                  
   .INIT_SET         (2'b00),                 
   .GRS_TYPE_DQ      ("RESET"),               
   .LRS_TYPE_DQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_DQ3     ("ASYNC_RESET"),         
   .GRS_TYPE_TQ      ("RESET"),               
   .LRS_TYPE_TQ0     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ1     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ2     ("ASYNC_RESET"),         
   .LRS_TYPE_TQ3     ("ASYNC_RESET"),         
   .TRI_EN           ("TRUE"),               
   .TBYTE_EN         ("TRUE"),               
   .MIPI_EN          ("FALSE"),               
   .OCASCADE_EN      ("FALSE")                
)u_oserdes_dm(
   .RST             (ddrphy_dqs_rst), 
   .OCE             (1'b1),
   .TCE             (1'b1),
   .OCLKDIV         (sysclk_p),
   .SERCLK          (phy_clk_p),
   .OCLK            (wclk_del),
   .MIPI_CTRL       (1'b0),
   .UPD0_SHIFT      (1'b0),
   .UPD1_SHIFT      (1'b0),
   .OSHIFTIN0       (1'b0),
   .OSHIFTIN1       (1'b0),
   .DI              (adj_wrdata_mask),
   .TI              (),
   .TBYTE_IN        (padt),
   .OSHIFTOUT0      (),
   .OSHIFTOUT1      (),
   .TQ              (padot_dm),
   .DO              (pado_dm)
);

GTP_OUTBUFT u_outbuft_dm
(
    .O   (dm),
    .I   (pado_dm), 
    .T   (padot_dm)
);
        
endmodule
        
   
   
   
   
   
   
   
   
   
   
   
   
   
   
        
        
        
        
        
                                                 
    




////////////////////////////////////////////////////////////////    
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                       
// ALL RIGHTS REVERVED.                                             
////////////////////////////////////////////////////////////////    
//Description:                                                      
//Author:  wxxiao                                                   
//History: v1.0                                                     
////////////////////////////////////////////////////////////////    
`timescale 1ns/1ps                                                  
module ips2l_ddrphy_data_slice_dqs_gate_cal_v1_0 #(
    parameter  GATE_MODE       =  0
)(
    input [4:0]    mc_rl                ,
    input [2:0]    init_read_clk_ctrl   ,       
    input [3:0]    init_slip_step       ,
    input          force_read_clk_ctrl  ,       
                              
    input          ddrphy_sysclk        ,
    input          ddrphy_rst_n         ,

    input          gatecal_start        ,
    output         gate_check_pass      ,
    output         gate_adj_done        ,
    output         gate_cal_error       ,
    input          gate_move_en         , 
    input          rddata_cal           ,

    input  [3:0]   read_cmd             , 

    input [1:0]    comp_val             ,
    input          comp_dir             ,
    input          dqs_gate_comp_en     ,
    output         dqs_gate_comp_done   ,
                       
    output [15:0]  dbg_dqs_gate_cal     ,
    input          ddrphy_dgts          , 
    input          dqs_gate_sample      ,
    output         dqs_gate_vld         ,
    output [3:0]   coarse_slip_step     ,
    output [3:0]   gate_win_size        ,
    output [3:0]   dqs_gate_ctrl        ,
    output [2:0]   read_clk_ctrl        
  );     

  ips2l_ddrphy_dqs_gate_coarse_cal_v1_0  ddrphy_dqs_gate_coarse_cal(                     
      .mc_rl             (mc_rl            ),
      .ddrphy_sysclk     (ddrphy_sysclk    ),
      .ddrphy_rst_n      (ddrphy_rst_n     ),
                                           
      .read_cmd          (read_cmd         ),
      .gatecal_start     (gatecal_start    ),
      .rddata_cal        (rddata_cal       ),
      
      .coarse_slip_step  (coarse_slip_step ),
      .dqs_gate_ctrl     (dqs_gate_ctrl    ),
      .dqs_gate_vld      (dqs_gate_vld     )
   );                                                               
 
  ips2l_ddrphy_gatecal_v1_0 #(
      .GATE_MODE           (GATE_MODE           )
   )ddrphy_gatecal(
      .init_read_clk_ctrl  (init_read_clk_ctrl  ),    
      .init_slip_step      (init_slip_step      ),    
      .force_read_clk_ctrl (force_read_clk_ctrl ),    

      .ddrphy_sysclk       (ddrphy_sysclk       ),    
      .ddrphy_rst_n        (ddrphy_rst_n        ),    

      .comp_val            (comp_val            ) ,
      .comp_dir            (comp_dir            ) ,
      .dqs_gate_comp_en    (dqs_gate_comp_en    ),
      .dqs_gate_comp_done  (dqs_gate_comp_done  ),

      .gatecal_start       (gatecal_start       ),    
      .gate_check_pass     (gate_check_pass     ),    
      .gate_adj_done       (gate_adj_done       ),    
      .gate_cal_error      (gate_cal_error      ),    
      .dqs_gate_vld        (dqs_gate_vld        ),    
      .gate_move_en        (gate_move_en        ),    

      .coarse_slip_step    (coarse_slip_step    ),    
      .read_clk_ctrl       (read_clk_ctrl       ), 
      .gate_win_size       (gate_win_size       ),   
      .ddrphy_dgts         (ddrphy_dgts         ),
      .dqs_gate_sample     (dqs_gate_sample     )
    );    
                

endmodule                                                       




////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//////////////////////////////////////////////////////////////
//Decription:
//Author: wxxiao
//Hitory: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_cpd_ctrl_v1_0 
(
input  dps_clk           ,
input  ddr_rstn          ,
input  ddrphy_cpd_start  ,
input  ddrphy_cpd_up_dnb ,
input  ddrphy_cpd_lock   ,
input  gpll_dps_done     ,
output ddrphy_cpd_rstn   ,
output ddrphy_cpd_done   ,
output reg gpll_dps_en   ,
output reg gpll_dps_dir  
);

  localparam  CPD_RST    = 4'd0;
  localparam  CPD_CTRL   = 4'd1;
  localparam  CPD_WAIT   = 4'd2;
  localparam  CPD_DELAY  = 4'd3;
  localparam  CPD_LOCK   = 4'd4;
  localparam  CPD_DEC    = 4'd5;
  localparam  CPD_DONE   = 4'd6;

`ifdef SIMULATION
localparam FAST_CPD = 1;
`else                                                              
localparam FAST_CPD = 0;      
`endif
  
`ifdef SIMULATION                                                  
localparam DELAY_TIME  = 4'd0;
`else                                                              
localparam DELAY_TIME  = 4'd1;      
`endif

`ifdef SIMULATION
localparam S_DELAY_TIME = 8'd0;
`else 
localparam S_DELAY_TIME = 8'd200;
`endif

reg [3:0] cpd_state;
reg [2:0] cpd_up_d;
reg [1:0] cpd_lock_d;
reg [1:0] dps_done_d;
reg [3:0] delay_cnt;
reg [5:0] dec_cnt;
reg [3:0] cnt;
reg [5:0] time_out;
reg ddrphy_cpd_start_d0,ddrphy_cpd_start_d1;
reg [7:0] sure_delay;

always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)
    cpd_up_d <= 3'b000;
    else
    cpd_up_d <= {cpd_up_d[1:0],ddrphy_cpd_up_dnb};
end


always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)begin
        cpd_lock_d <= 2'b00;
        dps_done_d <= 2'b00;
        ddrphy_cpd_start_d0 <= 0;
        ddrphy_cpd_start_d1 <= 0;
    end
    else begin
        cpd_lock_d <= {cpd_lock_d[0],ddrphy_cpd_lock};
        dps_done_d <= {dps_done_d[0],gpll_dps_done};
        ddrphy_cpd_start_d0 <= ddrphy_cpd_start;
        ddrphy_cpd_start_d1 <= ddrphy_cpd_start_d0;
    end
end

always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)
    delay_cnt <= 4'd0;
    else if(cpd_state == CPD_DELAY)
    delay_cnt <= delay_cnt + 4'd1;
    else 
    delay_cnt <= 4'd0;
end

always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)
    time_out <= 6'd0;
    else if(cpd_state == CPD_WAIT)
    time_out <= time_out + 6'd1;
    else 
    time_out <= 6'd0;
end

always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)
    cpd_state <= CPD_RST;
    else begin
        case(cpd_state)
            CPD_RST:begin
                if(ddrphy_cpd_start_d1)
                cpd_state <= CPD_DELAY;
            end
            CPD_CTRL:begin
                  if(cpd_lock_d[1] == 1'b1)
                  cpd_state <= CPD_LOCK;
                  else 
                  cpd_state <= CPD_WAIT;
            end
            CPD_WAIT:begin
                if((dps_done_d[1] == 1'b1)||(time_out == 6'd20))
                cpd_state <= CPD_DELAY;
            end
            CPD_DELAY:begin
                if(delay_cnt == DELAY_TIME)
                begin
                    if(cpd_lock_d[1] == 1'b1)
                    cpd_state <= CPD_LOCK;
                    else
                    cpd_state <= CPD_CTRL;
                end
            end
            CPD_LOCK:begin
                if(cpd_up_d != 3'b000)
                cpd_state <= CPD_DEC;
                else if((cpd_up_d == 3'b000)&&(sure_delay == S_DELAY_TIME))
                cpd_state <= CPD_DONE;
            end
            CPD_DEC:begin
                cpd_state <= CPD_WAIT;
            end
            CPD_DONE:begin
                cpd_state <= CPD_DONE;
            end
            default:
            cpd_state <= CPD_RST;
        endcase
    end
end

always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)
    sure_delay <= 8'd0;
    else if(cpd_state == CPD_LOCK)
    sure_delay <= sure_delay + 8'd1;
    else 
    sure_delay <= 8'd0;
end

always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)
    gpll_dps_en <= 0;
    else if((cpd_state == CPD_RST) || (cpd_state == CPD_DONE))
    gpll_dps_en <= 0;
    else if((cpd_state == CPD_DEC)||(cpd_state == CPD_CTRL))
    gpll_dps_en <= 1;
    else
    gpll_dps_en <= FAST_CPD;
end

always @(posedge dps_clk or negedge ddr_rstn)
begin
    if(!ddr_rstn)
    gpll_dps_dir <= 0;
    else if(cpd_state == CPD_CTRL)
    gpll_dps_dir <= ~cpd_up_d[2];
    else if(cpd_state == CPD_DEC)
    gpll_dps_dir <= 0;
end
 
assign ddrphy_cpd_rstn = ~(cpd_state == CPD_RST);
assign ddrphy_cpd_done = cpd_state == CPD_DONE;

endmodule





////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//////////////////////////////////////////////////////////////
//Decription:
//Author: wxxiao
//Hitory: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module  ips2l_ddrphy_control_path_adj_v1_0 #(
  parameter [1:0] DDR_TYPE      = 2'b00,
  parameter MEM_ADDR_WIDTH      = 16   ,
  parameter MEM_BANKADDR_WIDTH  = 3    ,
  parameter SLIP_BIT_NUM        = 2
)(
    input         ddrphy_sysclk  ,
    input         ddrphy_rst_n  ,

    input [3:0]   phy_cke       ,
    input [3:0]   phy_cs_n      ,
    input [3:0]   phy_ras_n     ,
    input [3:0]   phy_cas_n     ,
    input [3:0]   phy_we_n      ,
    input [4*MEM_ADDR_WIDTH-1:0]       phy_addr      ,
    input [4*MEM_BANKADDR_WIDTH-1:0]   phy_ba        ,
    input [3:0]   phy_odt       ,
    input [3:0]   phy_ck        ,

    output [7:0]  adj_cke       ,
    output [7:0]  adj_cs_n      ,
    output [7:0]  adj_ras_n     ,
    output [7:0]  adj_cas_n     ,
    output [7:0]  adj_we_n      ,
    output [8*MEM_ADDR_WIDTH-1:0]     adj_addr      ,
    output [8*MEM_BANKADDR_WIDTH-1:0] adj_ba        ,
    output [7:0]  adj_odt       ,
    output [7:0]  adj_ck        
  );
  reg [3:0]  phy_cke_r  ;
  reg [3:0]  phy_cs_n_r ;
  reg [3:0]  phy_ras_n_r;
  reg [3:0]  phy_cas_n_r;
  reg [3:0]  phy_we_n_r ;
  reg [4*MEM_ADDR_WIDTH-1:0]      phy_addr_r ;
  reg [4*MEM_BANKADDR_WIDTH-1:0]  phy_ba_r   ;
  reg [3:0]  phy_odt_r  ;

  always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
  begin
     if(!ddrphy_rst_n) begin
        if(DDR_TYPE == 2'b10)
        phy_cke_r      <= 4'b1111  ;
        else
        phy_cke_r      <= 4'b0000  ;
        phy_cs_n_r     <= 4'b1111  ;
        phy_ras_n_r    <= 4'b1111  ;
        phy_cas_n_r    <= 4'b1111  ;
        phy_we_n_r     <= 4'b1111  ;
        phy_addr_r     <= {4*MEM_ADDR_WIDTH{1'b0}};
        phy_ba_r       <= {4*MEM_BANKADDR_WIDTH{1'b0}};
        phy_odt_r      <= 4'b0  ;
     end
     else begin
        phy_cke_r      <= phy_cke  ;
        phy_cs_n_r     <= phy_cs_n  ;
        phy_ras_n_r    <= phy_ras_n ;
        phy_cas_n_r    <= phy_cas_n ;
        phy_we_n_r     <= phy_we_n ;
        phy_addr_r     <= phy_addr ;
        phy_ba_r       <= phy_ba   ;
        phy_odt_r      <= phy_odt  ;
     end
  end

  assign adj_cke   = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_cke  ,phy_cke_r  ):slip_1bit(phy_cke ,phy_cke_r );
  assign adj_cs_n  = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_cs_n ,phy_cs_n_r ):slip_1bit(phy_cs_n,phy_cs_n_r );
  assign adj_ras_n = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_ras_n,phy_ras_n_r):slip_1bit(phy_ras_n,phy_ras_n_r);
  assign adj_cas_n = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_cas_n,phy_cas_n_r):slip_1bit(phy_cas_n,phy_cas_n_r);
  assign adj_we_n  = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_we_n ,phy_we_n_r ):slip_1bit(phy_we_n, phy_we_n_r);
  assign adj_odt   = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_odt  ,phy_odt_r  ):slip_1bit(phy_odt, phy_odt_r );
  assign adj_ck    = {phy_ck,phy_ck};

genvar gen_j;
generate
   for(gen_j=0; gen_j<MEM_BANKADDR_WIDTH; gen_j=gen_j+1) begin : mem_baddr
      assign adj_ba[gen_j*8+7:gen_j*8] = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_ba[gen_j*4+3:gen_j*4], phy_ba_r[gen_j*4+3:gen_j*4]) : 
                                                                slip_1bit(phy_ba[gen_j*4+3:gen_j*4], phy_ba_r[gen_j*4+3:gen_j*4]); 
   end
endgenerate

genvar gen_k;
generate
   for(gen_k=0; gen_k<MEM_ADDR_WIDTH; gen_k=gen_k+1) begin : mem_addr
      assign adj_addr[gen_k*8+7:gen_k*8] = (SLIP_BIT_NUM == 2) ? slip_2bit(phy_addr[gen_k*4+3:gen_k*4], phy_addr_r[gen_k*4+3:gen_k*4]) : 
                                                               slip_1bit(phy_addr[gen_k*4+3:gen_k*4], phy_addr_r[gen_k*4+3:gen_k*4]); 
   end
endgenerate

//********************************************************************************************
    function [7:0] slip_1bit; //slip 0.5bit actually
        input [4-1:0]    data;
        input [4-1:0]    data_d;
        
        slip_1bit = {data[3], data[2], data[2], data[1], data[1], data[0], data[0], data_d[3]};
    endfunction
    
    function [7:0] slip_2bit; //slip 1.5bit actually
        input [4-1:0]    data;
        input [4-1:0]    data_d;
        
        slip_2bit = {data[2], data[1], data[1], data[0], data[0], data_d[3], data_d[3], data_d[2]};
    endfunction  


endmodule




////////////////////////////////////////////////////////////////   
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC                      
// ALL RIGHTS REVERVED.                                            
////////////////////////////////////////////////////////////////   
//Description:                                                     
//Author:  wxxiao                                                  
//History: v1.0                                                    
////////////////////////////////////////////////////////////////   
`timescale 1ns/1ps  
module ips2l_ddrphy_calib_top_v1_0 #(
   parameter [1:0]   DDR_TYPE     =  2'b00     ,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR
   parameter         WRCAL_EN     =  1         ,
   parameter         EYECAL_EN    =  1         ,
   parameter [19:0]  T200US       =  20'd20000 ,
   parameter [19:0]  T500US       =  20'd50000 ,
   parameter [7:0]   T400NS       =  8'd40     ,
   parameter [7:0]   TMRD         =  8'd1      ,
   parameter [7:0]   TMOD         =  8'd3      ,
   parameter [7:0]   TXPR         =  8'd17     ,
   parameter [7:0]   TRP          =  8'd2      ,
   parameter [9:0]   TZQINIT      =  10'd128   ,
   parameter [7:0]   TRFC         =  8'd16     ,
   parameter [7:0]   TRCD         =  8'd2      ,
   parameter [3:0]   REF_CNT      =  4'd9      ,
   parameter  TEST_DATA_PATTERN0  =  64'h55_aa_55_aa_08_f7_08_f7,
   parameter  TEST_DATA_PATTERN1  =  64'h7f_9f_7f_9f_80_fe_80_fe,
   parameter  TEST_DATA_PATTERN2  =  64'hf0_0f_f0_0f_01_ff_01_ff,
   parameter  TEST_DATA_PATTERN3  =  64'hdf_aa_df_aa_55_aa_55_aa,
   parameter  MEM_ADDR_WIDTH      =  16        ,
   parameter  MEM_BANKADDR_WIDTH  =  3         ,
   parameter  MEM_DQ_WIDTH        =  16        ,
   parameter  MEM_DM_WIDTH        =  2         ,
   parameter  MEM_DQS_WIDTH       =  2         

)(     
///parameter
  input [4:0]     mc_wl               ,
  input [15:0]    mr0                 ,
  input [15:0]    mr1                 ,
  input [15:0]    mr2                 ,
  input [15:0]    mr3                 ,
  
//clk                                 
  input           ddrphy_sysclk        ,
  input           ddrphy_rst_n        ,
  output          calib_done          ,
  output          update_done         ,

  output          ddrphy_rst_req      ,
  input           ddrphy_rst_ack      ,

  input           wrlvl_en           ,
  output          wrlvl_dqs_req      ,
  input           wrlvl_dqs_resp     ,
  input           wrlvl_error        ,
  
  output          gatecal_start      ,   
  input           gate_check_pass    ,
  input           gate_adj_done      ,
  input           gate_cal_error     ,
  output          gate_move_en       ,

  output          rddata_cal         , 
  input           rddata_check_pass  ,

  output          init_adj_rdel       ,
  input           adj_rdel_done       ,

  output          rdel_calibration    ,
  input           rdel_calib_done     ,
  input           rdel_calib_error    ,
  output          rdel_move_en        ,
  input           rdel_move_done      ,
  output          bitslip_ctrl        ,
  
  input           wrcal_check_pass   , 
  output          write_calibration  ,
  output          wrcal_move_en      ,
  input           wrcal_move_done    ,

  output          eye_calibration    ,  
  input           eyecal_check_pass  ,
  input           eyecal_move_done   ,
  output          eyecal_move_en     ,

  input           write_debug         ,
  input           dqgt_debug          ,
  input  [7:0]    rdel_rd_cnt         ,
  
  output          dfi_error           ,
  output [29:0]   debug_calib_ctrl    ,
  
  input           update_cal_req     ,
  input  [2*MEM_DQS_WIDTH-1:0]     update_comp_val    ,
  input  [MEM_DQS_WIDTH-1:0]       update_comp_dir    ,
  output  [2*MEM_DQS_WIDTH-1:0]    comp_val           ,
  output  [MEM_DQS_WIDTH-1:0]      comp_dir           ,
  output          dqs_gate_comp_en   ,
  input           dqs_gate_comp_done ,    

  output [MEM_BANKADDR_WIDTH-1:0]  calib_ba      ,
  output [MEM_ADDR_WIDTH-1:0]      calib_address ,
  output          calib_cs_n          ,
  output          calib_ras_n         ,
  output          calib_cas_n         ,
  output          calib_we_n          ,
  output          calib_cke           ,
  output          calib_odt           ,
  output          calib_rst           ,
  output [3:0]    calib_wrdata_en     ,
  output [MEM_DQ_WIDTH*8-1:0]   calib_wrdata     ,
  output [MEM_DM_WIDTH*8-1:0]   calib_wrdata_mask                
  );

  wire        init_start   ;
  wire        init_done    ;
  wire        init_rst     ;
  wire [MEM_BANKADDR_WIDTH-1:0]  init_ba      ;
  wire [MEM_ADDR_WIDTH-1:0]      init_address ;
  wire        init_cs_n    ;
  wire        init_ras_n   ;
  wire        init_cas_n   ;
  wire        init_we_n    ;
  wire        init_cke     ;
  wire        init_odt     ;
  wire [3:0]  dbg_main     ;
  wire [3:0]  dbg_init     ;
  wire [3:0]  dbg_wrcal    ;
  wire [3:0]  dbg_eyecal   ;

  wire        wrlvl_start  ;
  wire        wrlvl_done   ;
  wire [MEM_BANKADDR_WIDTH-1:0]  wrlvl_ba     ;
  wire [MEM_ADDR_WIDTH-1:0]      wrlvl_address;
  wire        wrlvl_cs_n   ;
  wire        wrlvl_ras_n  ;
  wire        wrlvl_cas_n  ;
  wire        wrlvl_we_n   ;
  wire        wrlvl_cke    ;
  wire        wrlvl_odt    ;
  wire [3:0]  dbg_wrlvl    ;

  wire        rdcal_start  ;
  wire        rdcal_done   ;
  wire [MEM_BANKADDR_WIDTH-1:0]  rdcal_ba       ;
  wire [MEM_ADDR_WIDTH-1:0]      rdcal_address  ;
  wire        rdcal_cs_n     ;
  wire        rdcal_ras_n    ;
  wire        rdcal_cas_n    ;
  wire        rdcal_we_n     ;
  wire        rdcal_cke      ;
  wire        rdcal_odt      ;
  wire        ddrphy_rst_rreq;
  wire        rdcalib_error  ;
  wire [MEM_DQ_WIDTH*8-1:0] rdcal_wrdata      ;
  wire [3:0]  rdcal_wrdata_en   ; 

  wire        wrcal_start  ;
  wire        wrcal_done   ;
  wire [MEM_BANKADDR_WIDTH-1:0]  wrcal_ba       ;
  wire [MEM_ADDR_WIDTH-1:0]      wrcal_address  ;
  wire        wrcal_cs_n     ;
  wire        wrcal_ras_n    ;
  wire        wrcal_cas_n    ;
  wire        wrcal_we_n     ;
  wire        wrcal_cke      ;
  wire        wrcal_odt      ;
  wire [MEM_DQ_WIDTH*8-1:0] wrcal_wrdata      ;
  wire [3:0]  wrcal_wrdata_en   ;

  wire        eyecal_start  ;
  wire        eyecal_done   ;
  wire [MEM_BANKADDR_WIDTH-1:0]  eyecal_ba       ;
  wire [MEM_ADDR_WIDTH-1:0]      eyecal_address  ;
  wire        eyecal_cs_n     ;
  wire        eyecal_ras_n    ;
  wire        eyecal_cas_n    ;
  wire        eyecal_we_n     ;
  wire        eyecal_cke      ;
  wire        eyecal_odt      ;

  wire        update_start      ;

  wire [4:0]  dbg_rdcal         ;
  wire        calib_error       ;
  wire [3:0]  dbg_upcal;

  assign  calib_error        = wrlvl_error | rdcalib_error ;
  assign  dfi_error          = calib_error;
  assign  calib_wrdata       = update_start ? {(MEM_DQ_WIDTH*8){1'b0}}  :
                               wrcal_start ? wrcal_wrdata : rdcal_wrdata ;       
  assign  calib_wrdata_en    = update_start ? 4'b0000                   : 
                               wrcal_start ? wrcal_wrdata_en : rdcal_wrdata_en   ;
  assign  calib_wrdata_mask  = {(MEM_DM_WIDTH*8){1'b0}};

  assign  ddrphy_rst_req = ddrphy_rst_rreq;
  assign  calib_rst      = init_rst;

  assign  debug_calib_ctrl = {dbg_main,dbg_init,dbg_wrlvl,dbg_rdcal,dbg_wrcal,dbg_eyecal,dbg_upcal,calib_error};  //4 4 4 5 4 4 4 1

  ips2l_ddrphy_main_ctrl_v1_0 #(
   .DDR_TYPE        (DDR_TYPE      ),
//   .WRCAL_EN        (WRCAL_EN      ),
   .EYECAL_EN       (EYECAL_EN     )
  )ddrphy_main_ctrl(
   //port             
   .ddrphy_sysclk   (ddrphy_sysclk  ),
   .ddrphy_rst_n    (ddrphy_rst_n   ),
   .update_cal_req  (update_cal_req ),  
   .init_start      (init_start     ),
   .init_done       (init_done      ),
   .wrlvl_en        (wrlvl_en       ),
   .wrlvl_start     (wrlvl_start    ),
   .wrlvl_done      (wrlvl_done     ),                      
   .rdcal_start     (rdcal_start    ),
   .rdcal_done      (rdcal_done     ),
   .wrcal_start     (wrcal_start    ),
   .wrcal_done      (wrcal_done     ),
   .eyecal_start    (eyecal_start   ),
   .eyecal_done     (eyecal_done    ),   
   .update_start    (update_start   ),
   .update_done     (update_done    ),
   .dbg_main        (dbg_main       ),
   .calib_done      (calib_done     )
//   .enter_dpd       (1'b0           ),
//   .exit_dpd        (1'b0           )
  );

  ips2l_ddrphy_init_v1_0 #( 
  .DDR_TYPE            (DDR_TYPE          ),
  .T200US              (T200US            ),
  .T500US              (T500US            ),
  .T400NS              (T400NS            ),
  .TMRD                (TMRD              ),
  .TMOD                (TMOD              ),
  .TXPR                (TXPR              ),
  .TRP                 (TRP               ),
  .TRFC                (TRFC              ),
  .TZQINIT             (TZQINIT           ),
  .REF_CNT             (REF_CNT           ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH    ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH)
  )ddrphy_init(
  .ddrphy_sysclk   (ddrphy_sysclk ),
  .ddrphy_rst_n   (ddrphy_rst_n ),

  .init_start     (init_start   ),
  .init_done      (init_done    ), 
  .mr0            (mr0          ),
  .mr1            (mr1          ),
  .mr2            (mr2          ),
  .mr3            (mr3          ),
  .dbg_init       (dbg_init     ),

  .init_rst       (init_rst     ),
  .init_ba        (init_ba      ),
  .init_address   (init_address ),
  .init_cs_n      (init_cs_n    ),
  .init_ras_n     (init_ras_n   ),
  .init_cas_n     (init_cas_n   ),
  .init_we_n      (init_we_n    ),
  .init_cke       (init_cke     ),
  .init_odt       (init_odt     )
 );

 ips2l_ddrphy_wrlvl_v1_0 #(
  .TMOD                (TMOD              ),
  .TRFC                (TRFC              ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH    ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH)
 )ddrphy_wrlvl(
  .mr1_ddr3        (mr1            ),
  .ddrphy_sysclk   (ddrphy_sysclk  ),
  .ddrphy_rst_n    (ddrphy_rst_n   ),

  .wrlvl_start     (wrlvl_start    ),
  .wrlvl_done      (wrlvl_done     ),
  .wrlvl_error     (wrlvl_error    ),
  .wrlvl_dqs_req   (wrlvl_dqs_req  ),
  .wrlvl_dqs_resp  (wrlvl_dqs_resp ),
  .dbg_wrlvl       (dbg_wrlvl      ),

  .wrlvl_ba        (wrlvl_ba       ),
  .wrlvl_address   (wrlvl_address  ),
  .wrlvl_cs_n      (wrlvl_cs_n     ),
  .wrlvl_ras_n     (wrlvl_ras_n    ),
  .wrlvl_cas_n     (wrlvl_cas_n    ),
  .wrlvl_we_n      (wrlvl_we_n     ),
  .wrlvl_cke       (wrlvl_cke      ),
  .wrlvl_odt       (wrlvl_odt      )
 );
                     
  ips2l_ddrphy_rdcal_v1_0 #(    
  .DDR_TYPE            (DDR_TYPE           ),
  .TRFC                (TRFC               ),
  .TRCD                (TRCD               ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH     ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH ),
  .MEM_DQ_WIDTH        (MEM_DQ_WIDTH       )
  )ddrphy_rdcal(
   .mc_wl              (mc_wl             ),
   .ddrphy_sysclk      (ddrphy_sysclk     ),
   .ddrphy_rst_n       (ddrphy_rst_n      ),
   .rdcal_start        (rdcal_start       ),
   .rdcal_done         (rdcal_done        ),

   .ddrphy_rst_req     (ddrphy_rst_rreq   ),
   .ddrphy_rst_ack     (ddrphy_rst_ack    ),

   .gatecal_start      (gatecal_start     ),
   .gate_check_pass    (gate_check_pass   ),
   .gate_adj_done      (gate_adj_done     ),
   .gate_cal_error     (gate_cal_error    ),
   .gate_move_en       (gate_move_en      ),

   .rddata_cal         (rddata_cal        ), 
   .rddata_check_pass  (rddata_check_pass ),
   .init_adj_rdel      (init_adj_rdel     ),
   .adj_rdel_done      (adj_rdel_done     ),

   .rdel_calibration   (rdel_calibration  ),
   .rdel_calib_done    (rdel_calib_done   ),
   .rdel_calib_error   (rdel_calib_error  ),
   .rdel_move_en       (rdel_move_en      ),
   .rdel_move_done     (rdel_move_done    ),

   .write_debug        (write_debug       ),
   .dqgt_debug         (dqgt_debug        ),
   .rdel_rd_cnt        (rdel_rd_cnt       ),

   .bitslip_ctrl       (bitslip_ctrl      ),
   .rdcalib_error      (rdcalib_error     ),
   .dbg_rdcal          (dbg_rdcal         ),

   .rdcal_ba           (rdcal_ba          ),
   .rdcal_address      (rdcal_address     ),
   .rdcal_cs_n         (rdcal_cs_n        ),
   .rdcal_ras_n        (rdcal_ras_n       ),
   .rdcal_cas_n        (rdcal_cas_n       ),
   .rdcal_we_n         (rdcal_we_n        ),
   .rdcal_cke          (rdcal_cke         ),
   .rdcal_odt          (rdcal_odt         ),
   .rdcal_wrdata       (rdcal_wrdata      ),
   .rdcal_wrdata_en    (rdcal_wrdata_en   )
  );

ips2l_ddrphy_wrcal_v1_0 #(
  .WRCAL_EN            (WRCAL_EN           ),
  .TRFC                (TRFC               ),
  .TRCD                (TRCD               ),
  .TEST_DATA_PATTERN0  (TEST_DATA_PATTERN0 ),
  .TEST_DATA_PATTERN1  (TEST_DATA_PATTERN1 ),
  .TEST_DATA_PATTERN2  (TEST_DATA_PATTERN2 ),
  .TEST_DATA_PATTERN3  (TEST_DATA_PATTERN3 ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH     ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH ),
  .MEM_DQ_WIDTH        (MEM_DQ_WIDTH       )
)ddrphy_wrcal(
   .mc_wl              (mc_wl              ),
   .ddrphy_sysclk      (ddrphy_sysclk      ),
   .ddrphy_rst_n       (ddrphy_rst_n       ),
   .wrcal_start        (wrcal_start        ),
   .wrcal_done         (wrcal_done         ),

   .wrcal_check_pass   (wrcal_check_pass   ),
   .write_calibration  (write_calibration  ),
   .wrcal_move_en      (wrcal_move_en      ),
   .wrcal_move_done    (wrcal_move_done    ),
   
   .wrcal_ba           (wrcal_ba          ),
   .wrcal_address      (wrcal_address     ),
   .wrcal_cs_n         (wrcal_cs_n        ),
   .wrcal_ras_n        (wrcal_ras_n       ),
   .wrcal_cas_n        (wrcal_cas_n       ),
   .wrcal_we_n         (wrcal_we_n        ),
   .wrcal_cke          (wrcal_cke         ),
   .wrcal_odt          (wrcal_odt         ),
   .wrcal_wrdata       (wrcal_wrdata      ),
   .wrcal_wrdata_en    (wrcal_wrdata_en   ),
   .dbg_wrcal          (dbg_wrcal         )
);

ips2l_ddrphy_eyecal_v1_0 #(
  .TRFC                (TRFC               ),
  .TRCD                (TRCD               ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH     ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH ),
  .MEM_DQ_WIDTH        (MEM_DQ_WIDTH       )
)ddrphy_eyecal(
   .ddrphy_sysclk      (ddrphy_sysclk     ),
   .ddrphy_rst_n       (ddrphy_rst_n      ),
                                          
   .eyecal_start       (eyecal_start      ),
   .eyecal_done        (eyecal_done       ),
   .eye_calibration    (eye_calibration   ),
   .eyecal_check_pass  (eyecal_check_pass ),
   .eyecal_move_done   (eyecal_move_done  ),
   .eyecal_move_en     (eyecal_move_en    ),
                                          
   .eyecal_ba          (eyecal_ba         ),
   .eyecal_address     (eyecal_address    ),
   .eyecal_cs_n        (eyecal_cs_n       ),
   .eyecal_ras_n       (eyecal_ras_n      ),
   .eyecal_cas_n       (eyecal_cas_n      ),
   .eyecal_we_n        (eyecal_we_n       ),
   .eyecal_cke         (eyecal_cke        ),
   .eyecal_odt         (eyecal_odt        ),
   .dbg_eyecal         (dbg_eyecal        )
);

   ips2l_ddrphy_calib_mux_v1_0 #(
     .DDR_TYPE            (DDR_TYPE          ),  
     .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH    ),
     .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH)
     )ddrphy_calib_mux (
     .ddrphy_sysclk       (ddrphy_sysclk    ),
     .ddrphy_rst_n        (ddrphy_rst_n     ),
                                            
     .init_start          (init_start       ),
     .init_ba             (init_ba          ),
     .init_address        (init_address     ),
     .init_cs_n           (init_cs_n        ),
     .init_ras_n          (init_ras_n       ),
     .init_cas_n          (init_cas_n       ),
     .init_we_n           (init_we_n        ),
     .init_cke            (init_cke         ),
     .init_odt            (init_odt         ),
                                            
     .wrlvl_start         (wrlvl_start      ),
     .wrlvl_ba            (wrlvl_ba         ),
     .wrlvl_address       (wrlvl_address    ),
     .wrlvl_cs_n          (wrlvl_cs_n       ),
     .wrlvl_ras_n         (wrlvl_ras_n      ),
     .wrlvl_cas_n         (wrlvl_cas_n      ),
     .wrlvl_we_n          (wrlvl_we_n       ),
     .wrlvl_cke           (wrlvl_cke        ),
     .wrlvl_odt           (wrlvl_odt        ),
                                            
     .rdcal_start         (rdcal_start      ),
     .rdcal_ba            (rdcal_ba         ),
     .rdcal_address       (rdcal_address    ),
     .rdcal_cs_n          (rdcal_cs_n       ),
     .rdcal_ras_n         (rdcal_ras_n      ),
     .rdcal_cas_n         (rdcal_cas_n      ),
     .rdcal_we_n          (rdcal_we_n       ),
     .rdcal_cke           (rdcal_cke        ),
     .rdcal_odt           (rdcal_odt        ),

     .wrcal_start         (wrcal_start      ),
     .wrcal_ba            (wrcal_ba         ),
     .wrcal_address       (wrcal_address    ),
     .wrcal_cs_n          (wrcal_cs_n       ),
     .wrcal_ras_n         (wrcal_ras_n      ),
     .wrcal_cas_n         (wrcal_cas_n      ),
     .wrcal_we_n          (wrcal_we_n       ),
     .wrcal_cke           (wrcal_cke        ),
     .wrcal_odt           (wrcal_odt        ),
                          
     .eyecal_start        (eyecal_start     ),
     .eyecal_ba           (eyecal_ba        ),
     .eyecal_address      (eyecal_address   ),
     .eyecal_cs_n         (eyecal_cs_n      ),
     .eyecal_ras_n        (eyecal_ras_n     ),
     .eyecal_cas_n        (eyecal_cas_n     ),
     .eyecal_we_n         (eyecal_we_n      ),
     .eyecal_cke          (eyecal_cke       ),
     .eyecal_odt          (eyecal_odt       ),
                          
     .update_start        (update_start     ), 
                                            
     .calib_ba            (calib_ba         ),
     .calib_address       (calib_address    ),
     .calib_cs_n          (calib_cs_n       ),
     .calib_ras_n         (calib_ras_n      ),
     .calib_cas_n         (calib_cas_n      ),
     .calib_we_n          (calib_we_n       ),
     .calib_cke           (calib_cke        ),
     .calib_odt           (calib_odt        )
    );

   ips2l_ddrphy_upcal_v1_0 #(
     .MEM_DQS_WIDTH      (MEM_DQS_WIDTH     )
   )ddrphy_upcal(
     .ddrphy_sysclk      (ddrphy_sysclk     ), 
     .ddrphy_rst_n       (ddrphy_rst_n      ), 
     
     .update_start       (update_start      ), 
     .update_done        (update_done       ), 
   
 //    .dll_update_ack     (dll_update_ack    ), 
//     .dll_update_req     (dll_update_req    ), 

     .update_comp_val    (update_comp_val   ),
     .update_comp_dir    (update_comp_dir   ),

     .comp_val           (comp_val          ),
     .comp_dir           (comp_dir          ),
     .dqs_gate_comp_en   (dqs_gate_comp_en  ),
     .dqs_gate_comp_done (dqs_gate_comp_done),
     .dbg_upcal          (dbg_upcal         )
    );

endmodule  




////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ips2l_ddrphy_calib_mux_v1_0 #(
  parameter [1:0] DDR_TYPE      = 2'b00,  //2'b00:DDR3  2'b01:DDR2  2'b10:LPDDR
  parameter MEM_ADDR_WIDTH      = 16,
  parameter MEM_BANKADDR_WIDTH  = 3    
)(
  input        ddrphy_sysclk   ,
  input        ddrphy_rst_n   ,

  input        init_start     ,
  input        wrlvl_start    ,
  input        rdcal_start    ,
  input        wrcal_start    ,
  input        eyecal_start   ,
  input        update_start   , 
     
  input [MEM_BANKADDR_WIDTH-1:0]   init_ba        ,
  input [MEM_ADDR_WIDTH-1:0]       init_address   ,
  input                            init_cs_n      ,
  input                            init_ras_n     ,
  input                            init_cas_n     ,
  input                            init_we_n      ,
  input                            init_cke       ,
  input                            init_odt       ,

  input [MEM_BANKADDR_WIDTH-1:0]   wrlvl_ba       ,
  input [MEM_ADDR_WIDTH-1:0]       wrlvl_address  ,
  input                            wrlvl_cs_n     ,
  input                            wrlvl_ras_n    ,
  input                            wrlvl_cas_n    ,
  input                            wrlvl_we_n     ,
  input                            wrlvl_cke      ,
  input                            wrlvl_odt      ,

  input [MEM_BANKADDR_WIDTH-1:0]   rdcal_ba       ,
  input [MEM_ADDR_WIDTH-1:0]       rdcal_address  ,
  input                            rdcal_cs_n     ,
  input                            rdcal_ras_n    ,
  input                            rdcal_cas_n    ,
  input                            rdcal_we_n     ,
  input                            rdcal_cke      ,
  input                            rdcal_odt      ,

   input [MEM_BANKADDR_WIDTH-1:0]  wrcal_ba       ,
   input [MEM_ADDR_WIDTH-1:0]      wrcal_address  ,
   input                           wrcal_cs_n     ,
   input                           wrcal_ras_n    ,
   input                           wrcal_cas_n    ,
   input                           wrcal_we_n     ,
   input                           wrcal_cke      ,
   input                           wrcal_odt      ,
   
   input [MEM_BANKADDR_WIDTH-1:0]  eyecal_ba      ,
   input [MEM_ADDR_WIDTH-1:0]      eyecal_address ,
   input                           eyecal_cs_n    ,
   input                           eyecal_ras_n   ,
   input                           eyecal_cas_n   ,
   input                           eyecal_we_n    ,
   input                           eyecal_cke     ,
   input                           eyecal_odt     , 
//  input [MEM_BANKADDR_WIDTH-1:0]   upcal_ba       ,
//  input [MEM_ADDR_WIDTH-1:0]       upcal_address  ,
//  input                            upcal_cs_n     ,
//  input                            upcal_ras_n    ,
//  input                            upcal_cas_n    ,
//  input                            upcal_we_n     ,
//  input                            upcal_cke      ,
//  input                            upcal_odt      ,

  output reg [MEM_BANKADDR_WIDTH-1:0] calib_ba        ,
  output reg [MEM_ADDR_WIDTH-1:0]     calib_address   ,
  output reg                       calib_cs_n      ,
  output reg                       calib_ras_n     ,
  output reg                       calib_cas_n     ,
  output reg                       calib_we_n      ,
  output reg                       calib_cke       ,
  output reg                       calib_odt
 );

 always @(posedge ddrphy_sysclk or negedge ddrphy_rst_n)
     if(!ddrphy_rst_n)  begin
        calib_ba        <= {MEM_BANKADDR_WIDTH{1'b0}};
        calib_address   <= {MEM_ADDR_WIDTH{1'b0}};
        calib_cs_n      <= 1'b1;
        calib_ras_n     <= 1'b0;
        calib_cas_n     <= 1'b0;
        calib_we_n      <= 1'b0;
        calib_odt       <= 1'b0;
        if(DDR_TYPE == 2'b10)
        calib_cke       <= 1'b1;
        else
        calib_cke       <= 1'b0;
     end
     else begin
         case({init_start,wrlvl_start,rdcal_start,update_start,wrcal_start,eyecal_start})
                  6'b100000: begin                             //init
                             calib_ba       <= init_ba       ;
                             calib_address  <= init_address  ;
                             calib_cs_n     <= init_cs_n     ;
                             calib_ras_n    <= init_ras_n    ;
                             calib_cas_n    <= init_cas_n    ;
                             calib_we_n     <= init_we_n     ;
                             calib_cke      <= init_cke      ;
                             calib_odt      <= init_odt      ;
                           end

                  6'b010000: begin                             //wrlvl
                             calib_ba       <= wrlvl_ba         ;
                             calib_address  <= wrlvl_address    ;
                             calib_cs_n     <= wrlvl_cs_n       ;
                             calib_ras_n    <= wrlvl_ras_n      ;
                             calib_cas_n    <= wrlvl_cas_n      ;
                             calib_we_n     <= wrlvl_we_n       ;
                             calib_cke      <= wrlvl_cke        ;
                             calib_odt      <= wrlvl_odt        ;
                           end

                  6'b001000: begin                            //rdcal
                              calib_ba       <= rdcal_ba        ;
                              calib_address  <= rdcal_address   ;
                              calib_cs_n     <= rdcal_cs_n      ;
                              calib_ras_n    <= rdcal_ras_n     ;
                              calib_cas_n    <= rdcal_cas_n     ;
                              calib_we_n     <= rdcal_we_n      ;
                              calib_cke      <= rdcal_cke       ;
                              calib_odt      <= rdcal_odt       ;
                           end

                   6'b000100:begin                            //update
                               calib_ba        <= {MEM_BANKADDR_WIDTH{1'b0}};
                               calib_address   <= {MEM_ADDR_WIDTH{1'b0}};    
                               calib_cs_n      <= 1'b1; 
                               calib_ras_n     <= 1'b1; 
                               calib_cas_n     <= 1'b1; 
                               calib_we_n      <= 1'b1; 
                               calib_cke       <= 1'b1;     
                               calib_odt       <= 1'b0;
                           end
                           
                   6'b000010: begin                            //wrcal
                              calib_ba       <= wrcal_ba        ;
                              calib_address  <= wrcal_address   ;
                              calib_cs_n     <= wrcal_cs_n      ;
                              calib_ras_n    <= wrcal_ras_n     ;
                              calib_cas_n    <= wrcal_cas_n     ;
                              calib_we_n     <= wrcal_we_n      ;
                              calib_cke      <= wrcal_cke       ;
                              calib_odt      <= wrcal_odt       ;
                           end

                   6'b000001: begin                            //eyecal
                              calib_ba       <= eyecal_ba        ;
                              calib_address  <= eyecal_address   ;
                              calib_cs_n     <= eyecal_cs_n      ;
                              calib_ras_n    <= eyecal_ras_n     ;
                              calib_cas_n    <= eyecal_cas_n     ;
                              calib_we_n     <= eyecal_we_n      ;
                              calib_cke      <= eyecal_cke       ;
                              calib_odt      <= eyecal_odt       ;
                           end

                   default: begin
                               calib_ba        <= {MEM_BANKADDR_WIDTH{1'b0}};
                               calib_address   <= {MEM_ADDR_WIDTH{1'b0}};    
                               calib_cs_n      <= 1'b1; 
                               calib_ras_n     <= 1'b1; 
                               calib_cas_n     <= 1'b1; 
                               calib_we_n      <= 1'b1; 
                               if(DDR_TYPE == 2'b10)
                               calib_cke       <= 1'b1;
                               else
                               calib_cke       <= 1'b0;     
                               calib_odt       <= 1'b0;     
                             end
               endcase
   end

endmodule




module ips2l_ddrphy_gpll_v1_0 #( 
parameter   real CLKIN_FREQ =  50.0,
parameter   BANDWIDTH  = "OPTIMIZED",
parameter   IDIV       =  2,
parameter   FDIV       =  64.0,
parameter   DUTYF      =  64,
parameter   ODIV0      =  4.0,
parameter   ODIV1      =  16,
parameter   DUTY0      =  4      
)(
input   clk_in0,
input   pll_rst,
//input   glogen,
input   dps_clk,
input   dps_en ,
input   dps_dir,
input   clkout0_gate,
output  clkout0,
output  clkout0n,
output  clkout1,
output  clkout1n,
output  dps_done,
output  pll_lock
);

parameter  ODIV2   =  4;
parameter  ODIV3   =  8;
parameter  ODIV4   =  16;
parameter  ODIV5   =  32;
parameter  ODIV6   =  64;


GTP_GPLL #(
  .CLKIN_FREQ         (CLKIN_FREQ), 
  .LOCK_MODE          (1'b0      ), 
  .STATIC_RATIOI      (IDIV   ),    
  .STATIC_RATIOM      (1   ),    
  .STATIC_RATIO0      (ODIV0),      
  .STATIC_RATIO1      (ODIV1),      
  .STATIC_RATIO2      (ODIV2),      
  .STATIC_RATIO3      (ODIV3),      
  .STATIC_RATIO4      (ODIV4),      
  .STATIC_RATIO5      (ODIV5),      
  .STATIC_RATIO6      (ODIV6),      
  .STATIC_RATIOF      (FDIV ),      
  .STATIC_DUTY0       (DUTY0),      
  .STATIC_DUTY1       (ODIV1),      
  .STATIC_DUTY2       (ODIV2),      
  .STATIC_DUTY3       (ODIV3),      
  .STATIC_DUTY4       (ODIV4),      
  .STATIC_DUTY5       (ODIV5),      
  .STATIC_DUTY6       (ODIV6),      
  .STATIC_DUTYF       (DUTYF ),      
  .STATIC_PHASE       (0),          
  .STATIC_PHASE0      (0),          
  .STATIC_PHASE1      (0),          
  .STATIC_PHASE2      (0),          
  .STATIC_PHASE3      (0),          
  .STATIC_PHASE4      (0),          
  .STATIC_PHASE5      (0),          
  .STATIC_PHASE6      (0),          
  .STATIC_PHASEF      (0),          
  .STATIC_CPHASE0     (0),          
  .STATIC_CPHASE1     (0),          
  .STATIC_CPHASE2     (0),          
  .STATIC_CPHASE3     (0),          
  .STATIC_CPHASE4     (0),          
  .STATIC_CPHASE5     (0),          
  .STATIC_CPHASE6     (0),          
  .STATIC_CPHASEF     (0),          
  .CLK_DPS0_EN        ("TRUE" ),    
  .CLK_DPS1_EN        ("FALSE"),    
  .CLK_DPS2_EN        ("FALSE"),    
  .CLK_DPS3_EN        ("FALSE"),    
  .CLK_DPS4_EN        ("FALSE"),    
  .CLK_DPS5_EN        ("FALSE"),    
  .CLK_DPS6_EN        ("FALSE"),    
  .CLK_DPSF_EN        ("FALSE"),    
  .CLK_CAS5_EN        ("FALSE"),    
  .CLKOUT0_SYN_EN     ("TRUE" ),    
  .CLKOUT1_SYN_EN     ("FALSE"),    
  .CLKOUT2_SYN_EN     ("FALSE"),    
  .CLKOUT3_SYN_EN     ("FALSE"),    
  .CLKOUT4_SYN_EN     ("FALSE"),    
  .CLKOUT5_SYN_EN     ("FALSE"),    
  .CLKOUT6_SYN_EN     ("FALSE"),    
  .CLKOUTF_SYN_EN     ("FALSE"),    
  .SSC_MODE           ("DISABLE"),  
  .SSC_FREQ           (50.0),       
  .INTERNAL_FB        ("CLKOUTF"),  
  .EXTERNAL_FB        ("DISABLE"),  
  .BANDWIDTH          (BANDWIDTH)
 )u_gpll(
  .CLKOUT0                  (clkout0    ),
  .CLKOUT0N                 (clkout0n   ),
  .CLKOUT1                  (clkout1),
  .CLKOUT1N                 (clkout1n),
  .CLKOUT2                  (),
  .CLKOUT2N                 (),
  .CLKOUT3                  (),
  .CLKOUT3N                 (),
  .CLKOUT4                  (),
  .CLKOUT5                  (),
  .CLKOUT6                  (),
  .CLKOUTF                  (),
  .CLKOUTFN                 (),
  .LOCK                     (pll_lock),
  .DPS_DONE                 (dps_done),
  .APB_RDATA                (),
  .APB_READY                (),
  .CLKIN1                   (clk_in0 ),
  .CLKIN2                   (1'b0    ),
  .CLKFB                    (1'b0    ),
  .CLKIN_SEL                (1'b0    ),
  .DPS_CLK                  (dps_clk ),
  .DPS_EN                   (dps_en  ),
  .DPS_DIR                  (dps_dir ),
  .CLKOUT0_SYN              (clkout0_gate),
  .CLKOUT1_SYN              (1'b0),
  .CLKOUT2_SYN              (1'b0),
  .CLKOUT3_SYN              (1'b0),
  .CLKOUT4_SYN              (1'b0),
  .CLKOUT5_SYN              (1'b0),
  .CLKOUT6_SYN              (1'b0),
  .CLKOUTF_SYN              (1'b0),
  .PLL_PWD                  (1'b0),
  .RST                      (pll_rst),
  .APB_CLK                  (1'b0 ),
  .APB_RST_N                (1'b0 ),
  .APB_ADDR                 (5'b00000),
  .APB_SEL                  (1'b0),
  .APB_EN                   (1'b0),
  .APB_WRITE                (1'b0),
  .APB_WDATA                (16'd0)
 );

endmodule




module ips2l_ddrphy_ppll_v1_0 #(
parameter  real CLKIN_FREQ =  50.0,
parameter  BANDWIDTH  = "OPTIMIZED",
parameter  IDIV       =  2,
parameter  FDIV       =  64,
parameter  ODIVPHY    =  4      //8'd2:800  8'd4:400
)(
input   clk_in0,
input   pll_rst,
input   clkoutphy_gate,
output  clkout0,
output  clkout0n,
output  clkoutphy,
output  clkoutphyn,
output  pll_lock
);

parameter   ODIV0   =  16;    //100
parameter   ODIV1   =  2;
parameter   ODIV2   =  4;
parameter   ODIV3   =  8;
parameter   ODIV4   =  16;

GTP_PPLL #(
   .CLKIN_FREQ         (CLKIN_FREQ),   
   .LOCK_MODE          (1'b0   ),      
   .STATIC_RATIOI      (IDIV   ),      
   .STATIC_RATIOM      (1      ),      
   .STATIC_RATIO0      (ODIV0  ),      
   .STATIC_RATIO1      (ODIV1  ),      
   .STATIC_RATIO2      (ODIV2  ),      
   .STATIC_RATIO3      (ODIV3  ),      
   .STATIC_RATIO4      (ODIV4  ),      
   .STATIC_RATIOPHY    (ODIVPHY),      
   .STATIC_RATIOF      (FDIV   ),      
   .STATIC_DUTY0       (ODIV0  ),      
   .STATIC_DUTY1       (ODIV1  ),      
   .STATIC_DUTY2       (ODIV2  ),      
   .STATIC_DUTY3       (ODIV3  ),      
   .STATIC_DUTY4       (ODIV4  ),      
   .STATIC_DUTYPHY     (ODIVPHY),      
   .STATIC_DUTYF       (FDIV   ),      
   .STATIC_PHASE0      (0),            
   .STATIC_PHASE1      (0),            
   .STATIC_PHASE2      (0),            
   .STATIC_PHASE3      (0),            
   .STATIC_PHASE4      (0),            
   .STATIC_PHASEPHY    (0),            
   .STATIC_PHASEF      (0),            
   .STATIC_CPHASE0     (0),            
   .STATIC_CPHASE1     (0),            
   .STATIC_CPHASE2     (0),            
   .STATIC_CPHASE3     (0),            
   .STATIC_CPHASE4     (0),            
   .STATIC_CPHASEPHY   (0),            
   .STATIC_CPHASEF     (0),            
   .CLKOUT0_SYN_EN     ("FALSE"),      
   .CLKOUT1_SYN_EN     ("FALSE"),      
   .CLKOUT2_SYN_EN     ("FALSE"),      
   .CLKOUT3_SYN_EN     ("FALSE"),      
   .CLKOUT4_SYN_EN     ("FALSE"),      
   .CLKOUTPHY_SYN_EN   ("TRUE"),       
   .CLKOUTF_SYN_EN     ("FALSE"),      
   .INTERNAL_FB        ("CLKOUTF"),    
   .EXTERNAL_FB        ("DISABLE"),    
   .BANDWIDTH          (BANDWIDTH)   
    )u_ppll(
   .CLKOUT0          (clkout0   ),               
   .CLKOUT0N         (clkout0n  ),
   .CLKOUT1          (),
   .CLKOUT1N         (),
   .CLKOUT2          (),
   .CLKOUT2N         (),
   .CLKOUT3          (),
   .CLKOUT3N         (),
   .CLKOUT4          (),
   .CLKOUTPHY        (clkoutphy),
   .CLKOUTPHYN       (clkoutphyn),
   .CLKOUTF          (),
   .CLKOUTFN         (),
   .LOCK             (pll_lock),
   .APB_RDATA        (),
   .APB_READY        (),
   .CLKIN1           (clk_in0),
   .CLKIN2           (1'b0),
   .CLKFB            (1'b0),
   .CLKIN_SEL        (1'b0),
   .CLKOUT0_SYN      (1'b0),
   .CLKOUT1_SYN      (1'b0),
   .CLKOUT2_SYN      (1'b0),
   .CLKOUT3_SYN      (1'b0),
   .CLKOUT4_SYN      (1'b0),
   .CLKOUTPHY_SYN    (clkoutphy_gate),
   .CLKOUTF_SYN      (1'b0),
   .PLL_PWD          (1'b0),
   .RST              (pll_rst),
   .APB_CLK          (1'b0),
   .APB_RST_N        (1'b0),
   .APB_ADDR         (5'd0),
   .APB_SEL          (1'b0),
   .APB_EN           (1'b0),
   .APB_WRITE        (1'b0),
   .APB_WDATA        (16'd0)
    );

//   PPLL u_ppll( 
//     .SC_ALDO_LOAD_CTRL                 (1'b0),
//     .SC_ALDO_LPF_ADJ                   (2'b00),
//     .SC_ALDO_TEST                      (2'b11),
//     .SC_ALDO_TEST_EN                   (1'b0),
//     .SC_ALDO_VREF_ADJ                  (3'b000),
//     .SC_ALDO_VREF_SEL                  (4'b0000),
//     .SC_CLKFBOUT_GATE_EN               (1'b0),
//     .SC_CLKINORFB_DLYSEL               (2'b00),
//     .SC_CLKINORFB_DLYSET               (6'd0),
//     .SC_CLKIN_STASEL                   (1'b0),
//     .SC_CLKOUT0_GATE_EN                (1'b0),
//     .SC_CLKOUT1_GATE_EN                (1'b0),
//     .SC_CLKOUT2_GATE_EN                (1'b0),
//     .SC_CLKOUT3_GATE_EN                (1'b0),
//     .SC_CLKOUT4_GATE_EN                (1'b0),
//     .SC_CLKOUTPHY_GATE_EN              (1'b1),
//     .SC_CP_CUR_SEL                     (4'b0000),
//     .SC_CP_SELFBIAS_SEL                (2'b00),
//     .SC_DLDO_LOAD_CTRL                 (1'b0),
//     .SC_DLDO_TEST                      (2'b10),
//     .SC_DLDO_TEST_EN                   (1'b0),
//     .SC_DLDO_VREF_ADJ                  (3'b000),
//     .SC_DLDO_VREF_SEL                  (4'b0000),
//     .SC_DYNSEL_ENABLE                  (1'b0),
//     .SC_FDIV_CPHASE                    (7'd0),
//     .SC_FDIV_DUTY                      (FDIV),
//     .SC_FDIV_FPHASE                    (3'd0),
//     .SC_FDIV_MUXSEL_EN                 (1'b1),
//     .SC_FDIV_RATIO                     (FDIV),
//     .SC_FEEDBK_SEL                     (4'b0000),
//     .SC_FREQDETECT_BYPASSREXT_EN       (1'b0),
//     .SC_FREQDETECT_BYPASSR_EXT         (1'b0),
//     .SC_FREQDETECT_EN                  (1'b1),
//     .SC_FREQ_LOCKDET_MODE_SEL          (1'b0),
//     .SC_FREQ_LOCKDET_RSTNCTRL          (1'b0),
//     .SC_FREQ_LOCKDET_SET               (5'd28),
//     .SC_GLOGEN_ENABLE                  (1'b1),
//     .SC_ICP_BASE_SEL                   (2'b00),
//     .SC_IDIV_RATIO                     (IDIV),      // idiv /2
//     .SC_LDO_R_BYPASS_ENABLE            (1'b0),
//     .SC_LOCK_FILTER_PD                 (1'b1),
//     .SC_LPF_C                          (1'b0),
//     .SC_LPF_R                          (3'b000),
//     .SC_MDIV_RATIO                     (8'd1),
//     .SC_ODIV0_CPHASE                   (7'd0),
//     .SC_ODIV0_DUTY                     (ODIV0),
//     .SC_ODIV0_FPHASE                   (3'd0),
//     .SC_ODIV0_MUXSEL_EN                (1'b1),
//     .SC_ODIV0_RATIO                    (ODIV0),
//     .SC_ODIV1_CPHASE                   (7'd0),
//     .SC_ODIV1_DUTY                     (ODIV1),
//     .SC_ODIV1_FPHASE                   (3'd0),
//     .SC_ODIV1_MUXSEL_EN                (1'b1),
//     .SC_ODIV1_RATIO                    (ODIV1),
//     .SC_ODIV2_CPHASE                   (7'd0),
//     .SC_ODIV2_DUTY                     (ODIV2),
//     .SC_ODIV2_FPHASE                   (3'd0),
//     .SC_ODIV2_MUXSEL_EN                (1'b1),
//     .SC_ODIV2_RATIO                    (ODIV2),
//     .SC_ODIV3_CPHASE                   (7'd0),
//     .SC_ODIV3_DUTY                     (ODIV3),
//     .SC_ODIV3_FPHASE                   (3'd0),
//     .SC_ODIV3_MUXSEL_EN                (1'b1),
//     .SC_ODIV3_RATIO                    (ODIV3),
//     .SC_ODIV4_CPHASE                   (7'd0),
//     .SC_ODIV4_DUTY                     (ODIV4),
//     .SC_ODIV4_FPHASE                   (3'd0),
//     .SC_ODIV4_MUXSEL_EN                (1'b1),
//     .SC_ODIV4_RATIO                    (ODIV4),
//     .SC_ODIVPHY_CPHASE                 (7'd0),
//     .SC_ODIVPHY_DUTY                   (ODIVPHY),
//     .SC_ODIVPHY_FPHASE                 (3'd0),
//     .SC_ODIVPHY_MUXSEL_EN              (1'b1),
//     .SC_ODIVPHY_RATIO                  (ODIVPHY),
//     .SC_PFDEN_ENABLE                   (1'b1),
//     .SC_PFDTOP_CLKTEST_EN              (1'b0),
//     .SC_PFDTOP_CLKTEST_SEL             (1'b0),
//     .SC_PFDTOP_LSTEST_SEL              (3'b000),
//     .SC_PFD_DEADZONE                   (2'b00),
//     .SC_PLL_PWD_ENABLE                 (1'b0),
//     .SC_PLL_RST_ENABLE                 (1'b1),       //pll_rst enable
//     .SC_PLL_USE_APB                    (1'b0),
//     .SC_PPLL_DCTEST_SEL                (2'b00),
//     .SC_PPLL_VCTRL_TEST_EN             (1'b0),
//     .SC_VCTRL_INIT                     (2'b00),   
//     .CLKFBOUT                          (),
//     .CLKFBOUTN                         (),
//     .CLKOUT0                           (clkout0),
//     .CLKOUT0N                          (clkout0n),
//     .CLKOUT1                           (),
//     .CLKOUT1N                          (),
//     .CLKOUT2                           (),
//     .CLKOUT2N                          (),
//     .CLKOUT3                           (),
//     .CLKOUT3N                          (),
//     .CLKOUT4                           (),
//     .CLKOUT4N                          (),
//     .CLKOUTPHY                         (clkoutphy),
//     .CLKOUTPHYN                        (clkoutphyn),
//     .DCTEST_OUT                        (),
//     .LDO_ANA_TEST_MUX                  (),
//     .LDO_DIG_TEST_MUX                  (),
//     .LOCKOUT_CAS                       (),
//     .PLL_LOCK                          (pll_lock),
//     .PPLL_VCTRL_TEST                   (),
//     .PRDATA                            (),
//     .PREADY                            (),
//     .TEST_SO                           (),
//     .PFDTOP_CLK_TEST                   (),
//     .PLL_LS_TEST                       (),
//     .VCC                               (VCC),
//     .VCCA_PPLL                         (VCC),
//     .VSS                               (VSS),
//     .VSSA_PPLL                         (VSS),
//     .CLKFBOUT_GATE                     (1'b0),
//     .CLKOUT0_GATE                      (1'b0),
//     .CLKOUT1_GATE                      (1'b0),
//     .CLKOUT2_GATE                      (1'b0),
//     .CLKOUT3_GATE                      (1'b0),
//     .CLKOUT4_GATE                      (1'b0),
//     .CLKOUTPHY_GATE                    (clkoutphy_gate),
//     .CLK_FB                            (1'b0),
//     .CLK_IN0                           (clk_in0),
//     .CLK_IN1                           (1'b0),
//     .DYNSEL_CLKIN                      (1'b0),
//     .GLOGEN                            (glogen),
//     .GRS_N                             (glogen),
//     .GWEN                              (1'b1),
//     .LOCKIN_CAS                        (1'b1),
//     .PADDR                             (5'd0),
//     .PCLK                              (1'b0),
//     .PENABLE                           (1'b0),
//     .PFDEN                             (1'b1),
//     .PLL_PWD                           (1'b0),
//     .PLL_RST                           (pll_rst),
//     .PORN_1P8                          (VCC),
//     .PRESETN                           (1'b0),
//     .PSEL                              (1'b0),
//     .PWDATA                            (16'd0),
//     .PWRITE                            (1'b0),
//     .TEST_CLK                          (1'b1),
//     .TEST_MODE_N                       (1'b1),
//     .TEST_RSTN                         (1'b1),
//     .TEST_SE_N                         (1'b1),
//     .TEST_SI                           (1'b1),
//     .VREF1_ALDO_PPLL                   (VCC),
//     .VREF1_DLDO_PPLL                   (VCC),
//     .VREF2_ALDO_PPLL                   (VCC),
//     .VREF2_DLDO_PPLL                   (VCC)
//   );


endmodule



// Generated by IP Generator (Version trunk build 41360)


//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//
// THE SOURCE CODE CONTAINED HEREIN IS PROPRIETARY TO PANGO MICROSYSTEMS, INC.
// IT SHALL NOT BE REPRODUCED OR DISCLOSED IN WHOLE OR IN PART OR USED BY
// PARTIES WITHOUT WRITTEN AUTHORIZATION FROM THE OWNER.
//
//////////////////////////////////////////////////////////////////////////////
//
// Library:
// Filename:pgm_distributed_fifo_v1_1.v
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1 ns / 1 ps
module pgm_distributed_fifo_v1_1 
#(
  parameter  ADDR_WIDTH               = 10            ,
  parameter  DATA_WIDTH               = 32            ,
  parameter  RST_TYPE                 = "ASYNC"       ,
  parameter  OUT_REG                  = 0             ,
  parameter  FIFO_TYPE                = "ASYNC_FIFO"  ,
  parameter  ALMOST_FULL_NUM          = 4             ,
  parameter  ALMOST_EMPTY_NUM         = 4             
)(
    input  wire  [DATA_WIDTH-1 : 0]      wr_data         ,
    input  wire                          wr_en           ,
                                                         
    input  wire                          wr_clk          ,
    input  wire                          wr_rst          ,
                                                         
    output wire                          full            ,
    output wire                          almost_full     ,
                                                         
    output wire  [ADDR_WIDTH : 0]        wr_water_level  ,
                                                         
                                                         
    output wire  [DATA_WIDTH-1 : 0]      rd_data         ,
    input  wire                          rd_en           ,
                                                         
    input  wire                          rd_clk          ,
    input  wire                          rd_rst          ,
                                                         
    output wire                          empty           ,
    output wire                          almost_empty    ,
                                                         
    output wire  [ADDR_WIDTH : 0]        rd_water_level  
);  

//    localparam ADDR_WIDTH = 4 ; //@IPC int 4,10
//
//    localparam DATA_WIDTH = 36 ; //@IPC int 1,256
////
//    localparam OUT_REG = 0 ; //@IPC bool
//
//    localparam RST_TYPE = "ASYNC" ; //@IPC enum ASYNC,SYNC
//
//    localparam FIFO_TYPE = "ASYNC_FIFO" ; //@IPC enum ASYNC_FIFO,SYNC_FIFO
//
//    localparam ALMOST_FULL_NUM = 12 ; //@IPC int 4,1024
//
//    localparam ALMOST_EMPTY_NUM = 4 ; //@IPC int 4,1024

    localparam WR_WATER_LEVEL_ENABLE = 1 ; //@IPC bool

    localparam RD_WATER_LEVEL_ENABLE = 1 ; //@IPC bool


ipm_distributed_fifo_v1_2_pgm_distributed_fifo_v1_1
 #(
  .ADDR_WIDTH       (ADDR_WIDTH      ) ,  // fifo ADDR_WIDTH width 4 -- 10
  .DATA_WIDTH       (DATA_WIDTH      ) ,  // write data width 4 -- 256
  .OUT_REG          (OUT_REG         ) ,  // output register   legal value:0 or 1
  .RST_TYPE         (RST_TYPE        ) ,
  .FIFO_TYPE        (FIFO_TYPE       ) ,  // fifo type legal value "SYN" or "ASYN"
  .ALMOST_FULL_NUM  (ALMOST_FULL_NUM ) ,  // almost full number
  .ALMOST_EMPTY_NUM (ALMOST_EMPTY_NUM)    // almost full number
)u_ipm_distributed_fifo_pgm_distributed_fifo_v1_1
 (
  .wr_data          (wr_data         ) ,  // input write data
  .wr_en            (wr_en           ) ,  // input write enable 1 active
  
  .wr_clk           (wr_clk          ) ,  // input write clock
  .wr_rst           (wr_rst          ) ,  // input write reset
  
  .full             (full            ) ,  // input write full  flag 1 active
  .almost_full      (almost_full     ) ,  // output write almost full
  
  .wr_water_level   (wr_water_level  ) ,  // output write water level
  
  .rd_data          (rd_data         ) ,  // output read data
  .rd_en            (rd_en           ) ,  // input  read enable
  
  .rd_clk           (rd_clk          ) ,  // input  read clock
  .rd_rst           (rd_rst          ) ,  // input read reset
  
  .empty            (empty           ) ,  // output read empty
  
  .rd_water_level   (rd_water_level  ) ,
  
  .almost_empty     (almost_empty    )
);
endmodule




//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//
// THE SOURCE CODE CONTAINED HEREIN IS PROPRIETARY TO PANGO MICROSYSTEMS, INC.
// IT SHALL NOT BE REPRODUCED OR DISCLOSED IN WHOLE OR IN PART OR USED BY
// PARTIES WITHOUT WRITTEN AUTHORIZATION FROM THE OWNER.
//
//////////////////////////////////////////////////////////////////////////////
//
// Library:
// Filename:ipm_distributed_fifo_ctr_v1_0.v
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1 ns / 1 ps

module ipm_distributed_fifo_ctr_v1_0 #(

  parameter  DEPTH            = 9             ,           // write adn read address width 4 -- 10
  parameter  FIFO_TYPE        = "ASYNC_FIFO"  ,           // ASYN_FIFO or SYN_FIFO
  parameter  ALMOST_FULL_NUM  = 4             ,
  parameter  ALMOST_EMPTY_NUM = 4
)
(
  input  wire                           wr_clk          ,           //write clock
  input  wire                           w_en            ,           //write enable 1 active
  output wire [DEPTH-1 : 0]             wr_addr         ,           //write address
  input  wire                           wrst            ,           //write reset
  output wire                           wfull           ,           //write full flag 1 active
  output wire                           almost_full     ,           //output write almost full
  output reg  [DEPTH : 0]               wr_water_level  ,           //output write water level

  input  wire                           rd_clk          ,           //read clock
  input  wire                           r_en            ,           //read enable 1 active
  output wire [DEPTH-1 : 0]             rd_addr         ,           //read address
  input  wire                           rrst            ,           //read reset
  output wire                           rempty          ,           //read empty  1 active
  output wire                           almost_empty    ,           //output read almost empty
  output reg  [DEPTH : 0]               rd_water_level              //output read water level
);
//**************************************************************************************************************
//declare inner variables
  //write address operation variables
reg [DEPTH : 0]  wptr               ;          //write pointer
reg [DEPTH : 0]  wrptr1             ;          //1st read-domain to write-domain synchronizer
reg [DEPTH : 0]  wrptr2             ;          //2nd read-domain to write-domain synchronizer
reg [DEPTH : 0]  wbin               ;          //write current binary  pointer
reg [DEPTH : 0]  wbnext             ;          //write next binary  pointer
reg [DEPTH : 0]  wgnext             ;          //write next gray pointer
reg              waddr_msb          ;          //the MSB of waddr
wire             wgnext_2ndmsb      ;          //the second MSB of wgnext
wire             wrptr2_2ndmsb      ;          //the second MSB of wrptr2

//read address operation variables
reg [DEPTH : 0]  rptr               ;          //read pointer
reg [DEPTH : 0]  rwptr1             ;          //1st  write-domain to read-domain synchronizer
reg [DEPTH : 0]  rwptr2             ;          //2nd  write-domain to read-domain synchronizer
reg [DEPTH : 0]  rbin               ;          //read current binary  pointer
reg [DEPTH : 0]  rbnext             ;          //read next binary  pointer
reg [DEPTH : 0]  rgnext             ;          //read next gray pointer
reg              raddr_msb          ;          //the MSB of raddr

reg [DEPTH : 0]  wrptr2_b           ;          //wrptr2 into binary
reg [DEPTH : 0]  rwptr2_b           ;          //rwptr2 into binary
//**************************************************************************************************************
reg              asyn_wfull         ;
reg              asyn_almost_full   ;
reg              asyn_rempty        ;
reg              asyn_almost_empty  ;
reg              syn_wfull          ;
reg              syn_almost_full    ;
reg              syn_rempty         ;
reg              syn_almost_empty   ;
//main code
//**************************************************************************************************************
generate
if(FIFO_TYPE == "ASYNC_FIFO")
begin:ASYN_CTRL
//write gray pointer generate
    integer  i;
    always@(*)
    begin
        for(i = 0;i <= DEPTH;i = i+1 )  //gray to binary converter
            wbin[i] = ^(wptr >> i);
    end
    always@(*)
    begin
        if(!wfull)
            wbnext = wbin + w_en;
        else
            wbnext = wbin;
    end
    always@(*)
    begin
        wgnext = (wbnext >> 1) ^ wbnext;          //binary to gray converter
    end
    always@( posedge wr_clk or posedge wrst )
    begin
        if(wrst)
        begin
            wptr <=0;
            waddr_msb <=0;
        end
        else
        begin
           wptr <= wgnext;
           waddr_msb <= wgnext[DEPTH] ^ wgnext[DEPTH-1];
        end
    end
    //read domain to write domain synchronizer
    always@( posedge wr_clk or posedge wrst )
    begin
        if(wrst)
            {wrptr2,wrptr1} <= 0;
        else
            {wrptr2,wrptr1} <= {wrptr1,rptr};
    end

    always@(*)
    begin
        for(i = 0;i <= DEPTH;i = i+1 )  //gray to binary converter
            wrptr2_b[i] = ^(wrptr2 >> i);
    end

    //generate fifo write full flag
    assign  wgnext_2ndmsb = wgnext[DEPTH] ^ wgnext[DEPTH-1];
    assign  wrptr2_2ndmsb = wrptr2[DEPTH] ^ wrptr2[DEPTH-1];
    //**************************************************************************************************************
    //read gray pointer generate
    integer  j;
    always@(*)
    begin
        for(j = 0;j <= DEPTH;j = j+1 )  //gray to binary converter
            rbin[j] = ^(rptr >> j);
    end

    always@(*)
    begin
        if(!rempty)
            rbnext = rbin + r_en;
        else
            rbnext = rbin;
        rgnext = (rbnext >> 1) ^ rbnext;          //binary to gray converter
    end

    always@( posedge rd_clk or posedge rrst )
    begin
        if(rrst)
        begin
            rptr <=0;
            raddr_msb <=0;
        end
        else
        begin
            rptr <= rgnext;
            raddr_msb <= rgnext[DEPTH] ^ rgnext[DEPTH-1];
        end
    end
    //read domain to write domain synchronizer
    always@(posedge rd_clk or posedge rrst)
    begin
        if(rrst)
            {rwptr2,rwptr1} <= 0;
        else
            {rwptr2,rwptr1} <= {rwptr1,wptr};
    end
    always@(*)
    begin
        for(i = 0;i <= DEPTH;i = i+1 )  //gray to binary converter
            rwptr2_b[i] = ^(rwptr2 >> i);
    end
    //generate asyn_fifo write full flag
    always@(posedge wr_clk or posedge wrst)
    begin
        if(wrst)
            asyn_wfull <= 1'b0;
        else
            asyn_wfull <= ( (wgnext[DEPTH] != wrptr2[DEPTH]) &&
	                      (wgnext_2ndmsb == wrptr2_2ndmsb) &&
	                      (wgnext[DEPTH-2:0] == wrptr2[DEPTH-2:0]) );
    end
	//generate asyn_fifo write almost full flag
	always@(posedge wr_clk or posedge wrst)
	begin
	    if(wrst)
	        asyn_almost_full <= 1'b0;
	    else if (wbnext[DEPTH:0] < wrptr2_b[DEPTH:0])
	        asyn_almost_full <= ({1'b1,wbnext[DEPTH:0]} - {1'b0,wrptr2_b[DEPTH:0]} >= ALMOST_FULL_NUM );
	    else
	        asyn_almost_full <= ((wbnext[DEPTH:0] - wrptr2_b[DEPTH:0]) >= ALMOST_FULL_NUM );
	end
	//asyn_fifo read empty flag generate
	always@(posedge rd_clk or posedge rrst)
	begin
	    if(rrst)
	        asyn_rempty <= 1'b1;
	    else
	        asyn_rempty <= (rgnext == rwptr2);
	end
	//generate asyn_fifo read almost empty flag
	always@(posedge rd_clk or posedge rrst)
	begin
	    if(rrst)
	        asyn_almost_empty <= 1'b1;
	    else if(rwptr2_b[DEPTH:0] < rbnext[DEPTH:0])
	        asyn_almost_empty <= ({1'b1,rwptr2_b[DEPTH:0]} - {1'b0,rbnext[DEPTH:0]} <= ALMOST_EMPTY_NUM );
	    else
	        asyn_almost_empty <= ((rwptr2_b[DEPTH:0] - rbnext[DEPTH:0]) <= ALMOST_EMPTY_NUM );
	end
end
else
begin:SYN_CTRL
    //write operation
    always@(*)
    begin
        if(!wfull)
            wbnext = wptr + w_en;
        else
            wbnext = wptr;
    end
    always@(*)
    begin
        wgnext =  wbnext;    // syn fifo
    end
    always@( posedge wr_clk or posedge wrst )
    begin
        if(wrst)
        begin
            wptr <=0;
            waddr_msb <=0;
        end
        else
        begin
            wptr <= wgnext;
            waddr_msb <= wgnext[DEPTH-1];
        end
    end
    always@(*)
    begin
        wrptr2 = rptr;    // syn fifo
    end
    always@(*)
    begin
        wrptr2_b = rptr;    // syn fifo
    end
    //generate fifo write full flag
    assign  wgnext_2ndmsb = wgnext[DEPTH-1];
    assign  wrptr2_2ndmsb = wrptr2[DEPTH-1];
    //**************************************************************************************************************
    //read operation
    always@(*)
    begin
        if(!rempty)
            rbnext = rptr + r_en;
        else
            rbnext = rptr;
    end
    always@(*)
    begin
        rgnext = rbnext;
    end
    always@( posedge rd_clk or posedge rrst )
    begin
        if(rrst)
        begin
            rptr <=0;
            raddr_msb <=0;
        end
        else
        begin
            rptr <= rgnext;
            raddr_msb <= rgnext[DEPTH-1];
        end
    end
    always@(*)
    begin
        rwptr2   =  wptr;    //syn fifo
    end
    always@(*)
    begin
        rwptr2_b =  wptr;    //syn fifo
    end
    //generate syn_fifo write full flag
    always@(posedge wr_clk or posedge wrst)
    begin
        if(wrst)
            syn_wfull <= 1'b0;
        else
            syn_wfull <= ((wgnext[DEPTH] != rgnext[DEPTH]) &&
	                     (wgnext[DEPTH-1:0] == rgnext[DEPTH-1:0]) );
    end
	//generate syn_fifo write almost full flag
	always@(posedge wr_clk or posedge wrst)
	begin
	    if(wrst)
	        syn_almost_full <= 1'b0;
	    else if (wbnext[DEPTH:0] < rbnext[DEPTH:0])
	        syn_almost_full <= ({1'b1,wbnext[DEPTH:0]} - {1'b0,rbnext[DEPTH:0]} >= ALMOST_FULL_NUM );
	    else
	        syn_almost_full <= ((wbnext[DEPTH:0] - rbnext[DEPTH:0]) >= ALMOST_FULL_NUM );
	end
	//syn_fifo read empty flag generate
	always@(posedge rd_clk or posedge rrst)
	begin
	    if(rrst)
	        syn_rempty <= 1'b1;
	    else
	        syn_rempty <= (rgnext == wgnext);
	end
	//generate syn_fifo read almost empty flag
	always@(posedge rd_clk or posedge rrst)
	begin
	    if(rrst)
	        syn_almost_empty <= 1'b1;
	    else if (wbnext[DEPTH:0] < rbnext[DEPTH:0])
	        syn_almost_empty <= ({1'b1,wbnext[DEPTH:0]} - {1'b0,rbnext[DEPTH:0]} <= ALMOST_EMPTY_NUM );
	    else
	        syn_almost_empty <= ((wbnext[DEPTH:0] - rbnext[DEPTH:0]) <= ALMOST_EMPTY_NUM );
	end
end

endgenerate

//write  flex memory address generate
assign  wr_addr = {waddr_msb,wptr[DEPTH-2:0]};

//generate fifo write full flag
assign wfull = (FIFO_TYPE == "ASYNC_FIFO") ? asyn_wfull : syn_wfull;

//generate fifo write almost full flag
assign almost_full  = (FIFO_TYPE == "ASYNC_FIFO") ? asyn_almost_full : syn_almost_full;

//generate write water level flag
always@(posedge wr_clk or posedge wrst)
begin
    if(wrst)
        wr_water_level <= 'b0;
    else if (wbnext[DEPTH:0] < wrptr2_b[DEPTH:0])
        wr_water_level <= ({1'b1,wbnext[DEPTH:0]} - {1'b0,wrptr2_b[DEPTH:0]});
    else
        wr_water_level <= ( wbnext[DEPTH:0] - wrptr2_b[DEPTH:0] );
end

//read flex memory address generate
assign  rd_addr = {raddr_msb,rptr[DEPTH-2:0]};

//fifo read empty flag generate
assign rempty  = (FIFO_TYPE == "ASYNC_FIFO") ? asyn_rempty : syn_rempty;

//generate fifo read almost empty flag
assign almost_empty  = (FIFO_TYPE == "ASYNC_FIFO") ? asyn_almost_empty : syn_almost_empty;

//generate read water level flag
always@(posedge rd_clk or posedge rrst)
begin
    if(rrst)
        rd_water_level <= 'b0;
    else if (rwptr2_b[DEPTH:0] < rbnext[DEPTH:0])
        rd_water_level <= ({1'b1,rwptr2_b[DEPTH:0]} - {1'b0,rbnext[DEPTH:0]});
    else
        rd_water_level <= ( rwptr2_b[DEPTH:0] - rbnext[DEPTH:0] );
end




endmodule



// Generated by IP Generator (Version trunk build 41360)


//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//
// THE SOURCE CODE CONTAINED HEREIN IS PROPRIETARY TO PANGO MICROSYSTEMS, INC.
// IT SHALL NOT BE REPRODUCED OR DISCLOSED IN WHOLE OR IN PART OR USED BY
// PARTIES WITHOUT WRITTEN AUTHORIZATION FROM THE OWNER.
//
//////////////////////////////////////////////////////////////////////////////
//
// Library:
// Filename:ipm_distributed_fifo_v1_2_pgm_distributed_fifo_v1_1.v
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1 ns / 1 ps

module ipm_distributed_fifo_v1_2_pgm_distributed_fifo_v1_1
 #(
  parameter  ADDR_WIDTH               = 10            ,  // fifo depth width 4 -- 10
  parameter  DATA_WIDTH               = 32            ,  // write data width 1 -- 256
  parameter  RST_TYPE                 = "ASYNC"       ,  // reset type   "ASYNC" "SYNC"
  parameter  OUT_REG                  = 0             ,  // output register   legal value:0 or 1
  parameter  FIFO_TYPE                = "ASYNC_FIFO"  ,  // fifo type legal value "SYNC_FIFO" or "ASYNC_FIFO"
  parameter  ALMOST_FULL_NUM          = 4             ,  // almost full number
  parameter  ALMOST_EMPTY_NUM         = 4                // almost full number
 )
 (
  input     [DATA_WIDTH-1 : 0]        wr_data         ,  // input write data
  input                               wr_en           ,  // input write enable 1 active
  input                               wr_clk          ,  // input write clock
  output                              full            ,  // output write full  flag 1 active
  input                               wr_rst          ,  // input write reset
  output                              almost_full     ,  // output write almost full
  output    [ADDR_WIDTH : 0]          wr_water_level  ,  // output write water level

  output    [DATA_WIDTH-1 : 0]        rd_data         ,  // output read data
  input                               rd_en           ,  // input  read enable
  input                               rd_clk          ,  // input  read clock
  output                              empty           ,  // output read empty
  input                               rd_rst          ,  // input read reset
  output                              almost_empty    ,
  output    [ADDR_WIDTH : 0]          rd_water_level
);


//declare inner variables
wire  [ADDR_WIDTH-1 : 0]  wr_addr         ;
wire  [ADDR_WIDTH-1 : 0]  rd_addr         ;
wire                      wr_en_real      ;

assign wr_en_real =  wr_en & (~full);

//instance sdpram
ipm_distributed_sdpram_v1_2_pgm_distributed_fifo_v1_1
#(
 .ADDR_WIDTH(ADDR_WIDTH )  ,    //address width   range:4-10
 .DATA_WIDTH(DATA_WIDTH )  ,    //data width      range:4-256
 .RST_TYPE  (RST_TYPE   )  ,    //reset type   "ASYNC_RESET" "SYNC_RESET"
 .OUT_REG   (OUT_REG    )
 ) ipm_distributed_sdpram_pgm_distributed_fifo_v1_1
 (
  .wr_data  (wr_data    )  ,
  .wr_addr  (wr_addr    )  ,
  .rd_addr  (rd_addr    )  ,
  .wr_clk   (wr_clk     )  ,
  .rd_clk   (rd_clk     )  ,
  .wr_en    (wr_en_real )  ,
  .rst      (rd_rst     )  ,
  .rd_data  (rd_data    )
 );


ipm_distributed_fifo_ctr_v1_0
 #(
  .DEPTH            (ADDR_WIDTH      ),     // write and read address width 4-- 10
  .FIFO_TYPE        (FIFO_TYPE       ),
  .ALMOST_FULL_NUM  (ALMOST_FULL_NUM ),
  .ALMOST_EMPTY_NUM (ALMOST_EMPTY_NUM)

)u_ipm_distributed_fifo_ctr
(
  .wr_clk           (wr_clk          ),     //write clock
  .w_en             (wr_en           ),     //write enable 1 active
  .wr_addr          (wr_addr         ),     //write address
  .wrst             (wr_rst          ),     //write reset
  .wfull            (full            ),     //write full flag 1 active
  .almost_full      (almost_full     ),
  .wr_water_level   (wr_water_level  ),

  .rd_clk           (rd_clk          ),     //read clock
  .r_en             (rd_en           ),     //read enable 1 active
  .rd_addr          (rd_addr         ),     //read address
  .rrst             (rd_rst          ),     //read reset
  .rempty           (empty           ),     //read empty  1 active
  .almost_empty     (almost_empty    ),
  .rd_water_level   (rd_water_level  )

);

endmodule




// Generated by IP Generator (Version trunk build 41360)



//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//
// THE SOURCE CODE CONTAINED HEREIN IS PROPRIETARY TO PANGO MICROSYSTEMS, INC.
// IT SHALL NOT BE REPRODUCED OR DISCLOSED IN WHOLE OR IN PART OR USED BY
// PARTIES WITHOUT WRITTEN AUTHORIZATION FROM THE OWNER.
//
//////////////////////////////////////////////////////////////////////////////
//
// Library:
// Filename:ipm_distributed_sdpram_v1_2_pgm_distributed_fifo_v1_1.v
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1 ns / 1 ps

module ipm_distributed_sdpram_v1_2_pgm_distributed_fifo_v1_1
    #(
      parameter  ADDR_WIDTH     	      = 4          ,    //address width   range:4-10
      parameter  DATA_WIDTH     	      = 4          ,    //data width      range:1-256
      parameter  RST_TYPE                 = "ASYNC"    ,    //reset type   "ASYNC" "SYNC"
      parameter  OUT_REG                  = 0          ,    //output options :non_register(0)  register(1)
      parameter  INIT_FILE                = "NONE"     ,    //legal value:"NONE" or "initial file name"
      parameter  FILE_FORMAT              = "BIN"           //initial data format : "BIN" or "HEX"
     )
     (
      input   wire [DATA_WIDTH-1:0]       wr_data      ,
      input   wire [ADDR_WIDTH-1:0]       wr_addr      ,
      input   wire [ADDR_WIDTH-1:0]       rd_addr      ,
      input   wire                        wr_clk       ,
      input   wire                        rd_clk       ,
      input   wire                        wr_en        ,
      input   wire                        rst          ,
      output  wire [DATA_WIDTH-1:0]       rd_data
     )/* synthesis syn_ramstyle = "select_ram" */;


wire                                      asyn_rst     ;
wire                                      syn_rst      ;
wire  [DATA_WIDTH-1:0]                    q            ;
reg   [DATA_WIDTH-1:0]                    q_reg        ;

reg   [DATA_WIDTH-1:0]                    mem [2**ADDR_WIDTH-1:0];

//***********************************************************************reset*******************************************************************
assign  asyn_rst  = (RST_TYPE == "ASYNC") ? rst : 0  ;
assign  syn_rst   = (RST_TYPE == "SYNC" ) ? rst : 0  ;

//initialize sdpram
generate
    integer i,j;
    if (INIT_FILE != "NONE") begin
        if (FILE_FORMAT == "BIN") begin
            initial begin
                $readmemb(INIT_FILE,mem);
            end
        end
        else if (FILE_FORMAT == "HEX") begin
            initial begin
                $readmemh(INIT_FILE,mem);
            end
        end
    end
    else begin
        initial begin
            for (i=0;i<2**ADDR_WIDTH;i=i+1) begin
                for (j=0;j<DATA_WIDTH;j=j+1) begin
                    mem[i][j] = 1'b0;
                end
            end
        end
    end
endgenerate

//write & read
generate
    always @(posedge wr_clk) begin
        if(wr_en)
            mem[wr_addr] <= wr_data;
    end

    assign q = mem[rd_addr];

    if (RST_TYPE == "ASYNC") begin
        always@(posedge rd_clk or posedge asyn_rst)
        begin
            if(asyn_rst)
                q_reg <= {DATA_WIDTH{1'b0}};
            else
                q_reg <= q;
        end
    end
    else if (RST_TYPE == "SYNC") begin
        always@(posedge rd_clk)
        begin
            if(syn_rst)
                q_reg <= {DATA_WIDTH{1'b0}};
            else
                q_reg <= q;
        end
    end
endgenerate

assign rd_data = (OUT_REG == 1) ? q_reg : q;

endmodule




// Generated by IP Generator (Version 2020.1-SP5 build 56918)


    
////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module ddr3 #(
 
   parameter MEM_ROW_ADDR_WIDTH   = 15         ,
    
   parameter MEM_COL_ADDR_WIDTH   = 10         ,
   
   parameter MEM_BADDR_WIDTH      = 3          ,
  
  parameter MEM_DQ_WIDTH         =  32         ,
  
  parameter MEM_DM_WIDTH         =  32/8        ,
  
  parameter MEM_DQS_WIDTH        =  32/8       ,
   
   parameter CTRL_ADDR_WIDTH     = MEM_ROW_ADDR_WIDTH + MEM_COL_ADDR_WIDTH + MEM_BADDR_WIDTH        
  )(                                                              
   input                              ref_clk        ,            
   input                              resetn         ,            
   output                             ddr_init_done  ,            
   output                             core_clk       ,            
   output                             pll_lock       ,            
   output                             ddrphy_cpd_lock,      
                                                                  
   input [CTRL_ADDR_WIDTH-1:0]        axi_awaddr     ,            
   input                              axi_awuser_ap  ,
   input [3:0]                        axi_awuser_id  ,
   input [3:0]                        axi_awlen      ,
   output                             axi_awready    ,
   input                              axi_awvalid    ,

   input [MEM_DQ_WIDTH*8-1:0]         axi_wdata      ,
   input [MEM_DQ_WIDTH*8/8-1:0]       axi_wstrb      ,
   output                             axi_wready     ,
   output [3:0]                       axi_wusero_id  ,
   output                             axi_wusero_last,

   input [CTRL_ADDR_WIDTH-1:0]        axi_araddr     ,
   input                              axi_aruser_ap  ,
   input [3:0]                        axi_aruser_id  ,
   input [3:0]                        axi_arlen      ,
   output                             axi_arready    ,
   input                              axi_arvalid    ,

   output[MEM_DQ_WIDTH*8-1:0]         axi_rdata      ,
   output[3:0]                        axi_rid        ,
   output                             axi_rlast      ,
   output                             axi_rvalid     ,

   input                              apb_clk        ,
   input                              apb_rst_n      ,
   input                              apb_sel        ,
   input                              apb_enable     ,
   input [7:0]                        apb_addr       ,
   input                              apb_write      ,
   output                             apb_ready      ,
   input [15:0]                       apb_wdata      ,
   output[15:0]                       apb_rdata      ,
   output [29:0]                      debug_calib_ctrl     ,
   output [66*MEM_DQS_WIDTH -1:0]     debug_data           ,
   
   output                             mem_rst_n            ,                       
   output                             mem_ck               ,
   output                             mem_ck_n             ,
   output                             mem_cke              ,
   output                             mem_cs_n             ,
   output                             mem_ras_n            ,
   output                             mem_cas_n            ,
   output                             mem_we_n             , 
   output                             mem_odt              ,
   output [MEM_ROW_ADDR_WIDTH-1:0]    mem_a                ,   
   output [MEM_BADDR_WIDTH-1:0]       mem_ba               ,   
   inout [MEM_DQS_WIDTH-1:0]          mem_dqs              ,
   inout [MEM_DQS_WIDTH-1:0]          mem_dqs_n            ,
   inout [MEM_DQ_WIDTH-1:0]           mem_dq               ,
   output [MEM_DM_WIDTH-1:0]          mem_dm               
);
//MR0_DDR3
localparam [0:0] DDR3_PPD      = 1'b1;

localparam [2:0] DDR3_WR       =  6 - 4; 

localparam [0:0] DDR3_DLL      = 1'b1;
localparam [0:0] DDR3_TM       = 1'b0;
localparam [0:0] DDR3_RBT      = 1'b0;

localparam [3:0] DDR3_CL       = (6 - 4) * 2; 
    
localparam [1:0] DDR3_BL       = 2'b00;
localparam [15:0] MR0_DDR3     = {3'b000, DDR3_PPD, DDR3_WR, DDR3_DLL, DDR3_TM, DDR3_CL[3:1], DDR3_RBT, DDR3_CL[0], DDR3_BL};
//MR1_DDR3
localparam [0:0] DDR3_QOFF     = 1'b0;
localparam [0:0] DDR3_TDQS     = 1'b0;

localparam [2:0] DDR3_RTT_NOM  = 3'b001;       

localparam [0:0] DDR3_LEVEL    = 1'b0;

localparam [1:0] DDR3_DIC      = 2'b00;

localparam [1:0] DDR3_AL       = 2'b10;     
localparam [0:0] DDR3_DLL_EN   = 1'b0;
localparam [15:0] MR1_DDR3 = {1'b0, DDR3_QOFF, DDR3_TDQS, 1'b0, DDR3_RTT_NOM[2], 1'b0, DDR3_LEVEL, DDR3_RTT_NOM[1], DDR3_DIC[1], DDR3_AL, DDR3_RTT_NOM[0], DDR3_DIC[0], DDR3_DLL_EN};
//MR2_DDR3
localparam [1:0] DDR3_RTT_WR   = 2'b00;
localparam [0:0] DDR3_SRT      = 1'b0;
localparam [0:0] DDR3_ASR      = 1'b0;

localparam [2:0] DDR3_CWL      = 5 - 5;

localparam [2:0] DDR3_PASR     = 3'b000;
localparam [15:0] MR2_DDR3     = {5'b00000, DDR3_RTT_WR, 1'b0, DDR3_SRT, DDR3_ASR, DDR3_CWL, DDR3_PASR};
//MR3_DDR3
localparam [0:0] DDR3_MPR      = 1'b0;
localparam [1:0] DDR3_MPR_LOC  = 2'b00;
localparam [15:0] MR3_DDR3     = {13'b0, DDR3_MPR, DDR3_MPR_LOC};

//MR_DDR2
localparam [2:0] DDR2_BL       = 3'b011;
localparam [0:0] DDR2_BT       = 1'b0; //Sequential

localparam [2:0] DDR2_CL       = 3'd5;

localparam [0:0] DDR2_TM       = 1'b0;
localparam [0:0] DDR2_DLL      = 1'b1;

localparam [2:0] DDR2_WR       =  6 - 1; 

localparam [0:0] DDR2_PD       = 1'b0;
localparam [15:0]  MR_DDR2     = {3'b000,DDR2_PD,DDR2_WR,DDR2_DLL,DDR2_TM,DDR2_CL,DDR2_BT,DDR2_BL};

//EMR1_DDR2
localparam [0:0] DDR2_DLL_EN      = 1'b0;

localparam [0:0] DDR2_DIC      = 1'b0;

localparam [1:0] DDR2_RTT_NOM  = 2'b01;     

localparam [2:0] DDR2_AL       = 3'd3; 
 
localparam [2:0] DDR2_OCD      = 3'b000;
localparam [0:0] DDR2_DQS      = 1'b0;
localparam [0:0] DDR2_RDQS     = 1'b0;
localparam [0:0] DDR2_QOFF     = 1'b0;
localparam [15:0] EMR1_DDR2    = {3'b000,DDR2_QOFF,DDR2_RDQS,DDR2_DQS,DDR2_OCD,DDR2_RTT_NOM[1],DDR2_AL,DDR2_RTT_NOM[0],DDR2_DIC,DDR2_DLL_EN};

localparam [15:0] EMR2_DDR2    =16'h0000;
localparam [15:0] EMR3_DDR2    =16'h0000;
 
//MR_LPDDR
localparam [2:0] LPDDR_BL      = 3'b011;
localparam [0:0] LPDDR_BT      = 1'b0;

localparam [2:0] LPDDR_CL      = 3'd3;

localparam [15:0] MR_LPDDR    = {9'd0,LPDDR_CL,LPDDR_BT,LPDDR_BL};

//EMR_LPDDR

localparam [2:0] LPDDR_DS      = 3'b000;

localparam [15:0] EMR_LPDDR    = {8'd0,LPDDR_DS,5'd0};


  localparam         MEM_TYPE     =  "DDR3"      ;
 
localparam DDR_TYPE = (MEM_TYPE == "DDR3") ? 2'b00 : (MEM_TYPE == "DDR2") ? 2'b01 : (MEM_TYPE == "LPDDR") ? 2'b10 : 2'b00;
 
  localparam [7:0]   PHY_TMRD         =  4/4   ;

  localparam [7:0]   PHY_TMOD         =  12/4   ;
  
  localparam [7:0]   PHY_TXPR         =  31   ;
  
  localparam [7:0]   PHY_TRP          =  2   ;
  
  localparam [7:0]   PHY_TRFC         =  30   ;
    
  localparam [7:0]   PHY_TRCD         =  2   ;
            
  localparam DDRC_TXSDLL               = 512  ;
   
  localparam DDRC_TXP                  = 3   ;
 
  localparam DDRC_TFAW                 = 18   ;

  localparam DDRC_TRAS                 = 15   ;
   
  localparam DDRC_TRCD                 = 6   ;
    
  localparam DDRC_TREFI                = 3120   ;
   
  localparam DDRC_TRFC                 = 120   ;
     
  localparam DDRC_TRC                  = 20   ;

  localparam DDRC_TRP                  = 6   ;

  localparam DDRC_TRRD                 = 4   ;  

  localparam DDRC_TRTP                 = 3   ;

  localparam DDRC_TWR                  = 6   ;

  localparam DDRC_TWTR                 = 3    ;
 

wire                              dfi_phyupd_req  ;
wire                              dfi_phyupd_ack  ;
wire                              dfi_init_complete;
wire [4*MEM_ROW_ADDR_WIDTH-1:0]   dfi_address     ;
wire [4*MEM_BADDR_WIDTH-1:0]      dfi_bank        ;
wire [4-1:0]                      dfi_cs_n        ;
wire [4-1:0]                      dfi_ras_n       ;
wire [4-1:0]                      dfi_cas_n       ;
wire [4-1:0]                      dfi_we_n        ;
wire [4-1:0]                      dfi_cke         ;
wire [4-1:0]                      dfi_odt         ;
wire [2*4*MEM_DQ_WIDTH-1:0]       dfi_wrdata      ;
wire [4-1:0]                      dfi_wrdata_en   ;
wire [2*4*MEM_DQ_WIDTH/8-1:0]     dfi_wrdata_mask ;
wire [2*4*MEM_DQ_WIDTH-1:0]       dfi_rddata      ;
wire                              dfi_rddata_valid;
wire ddrphy_sysclk;
wire ddr_rstn;

    
ips2l_rst_sync_v1_0 u_ips_rst_sync(
    .rclk           (ref_clk           ),
    .sync_din       (resetn            ),
    .sync_dout      (ddr_rstn          )
);

assign core_clk = ddrphy_sysclk;
                                             
pgs_mc3q_wrapper_v1_2 #(
   .DDR_TYPE           (DDR_TYPE           ),
   .RADDR_WIDTH        (1                  ),
   .MEM_ROW_ADDR_WIDTH (MEM_ROW_ADDR_WIDTH ),
   .MEM_COL_ADDR_WIDTH (MEM_COL_ADDR_WIDTH ),
   .MEM_BADDR_WIDTH    (MEM_BADDR_WIDTH    ),
   .MEM_DQ_WIDTH       (MEM_DQ_WIDTH       ),
   .CTRL_ADDR_WIDTH    (CTRL_ADDR_WIDTH    ),                                             
   .MR0_DDR3           (MR0_DDR3       ),
   .MR1_DDR3           (MR1_DDR3       ),
   .MR2_DDR3           (MR2_DDR3       ),
   .MR3_DDR3           (MR3_DDR3       ),
   .MR_DDR2            (MR_DDR2        ),
   .EMR1_DDR2          (EMR1_DDR2      ),
   .EMR2_DDR2          (EMR2_DDR2      ),
   .EMR3_DDR2          (EMR3_DDR2      ),
   .MR_LPDDR           (MR_LPDDR       ),
   .EMR_LPDDR          (EMR_LPDDR      ),
                                           
   .TXSDLL             (DDRC_TXSDLL    ),
   .TXP                (DDRC_TXP       ),
   .TFAW               (DDRC_TFAW      ),
   .TRAS               (DDRC_TRAS      ),
   .TRCD               (DDRC_TRCD      ),
   .TREFI              (DDRC_TREFI     ),
   .TRFC               (DDRC_TRFC      ),
   .TRC                (DDRC_TRC       ),
   .TRP                (DDRC_TRP       ),
   .TRRD               (DDRC_TRRD      ),
   .TRTP               (DDRC_TRTP      ),
   .TWR                (DDRC_TWR       ),
   .TWTR               (DDRC_TWTR      ) 
  )u_ips_ddrc_top(
   .clk                (ddrphy_sysclk     ),
   .rst_n              (ddr_rstn          ),

   .phy_init_done      (dfi_init_complete ),
   .ddr_init_done      (ddr_init_done     ),

   .axi_awaddr         (axi_awaddr        ),
   .axi_awuser_ap      (axi_awuser_ap     ),
   .axi_awuser_id      (axi_awuser_id     ),
   .axi_awlen          (axi_awlen         ),
   .axi_awready        (axi_awready       ),
   .axi_awvalid        (axi_awvalid       ),

   .axi_wdata          (axi_wdata         ),
   .axi_wstrb          (axi_wstrb         ),
   .axi_wready         (axi_wready        ),
   .axi_wusero_id      (axi_wusero_id     ),
   .axi_wusero_last    (axi_wusero_last   ),

   .axi_araddr         (axi_araddr        ),
   .axi_aruser_ap      (axi_aruser_ap     ),
   .axi_aruser_id      (axi_aruser_id     ),
   .axi_arlen          (axi_arlen         ),
   .axi_arready        (axi_arready       ),
   .axi_arvalid        (axi_arvalid       ),

   .axi_rdata          (axi_rdata         ),
   .axi_rid            (axi_rid           ),
   .axi_rlast          (axi_rlast         ),
   .axi_rvalid         (axi_rvalid        ),

   .apb_clk            (apb_clk           ),
   .apb_rst_n          (apb_rst_n         ),
   .apb_sel            (apb_sel           ),
   .apb_enable         (apb_enable        ),
   .apb_addr           (apb_addr          ),
   .apb_write          (apb_write         ),
   .apb_ready          (apb_ready         ),
   .apb_wdata          (apb_wdata         ),
   .apb_rdata          (apb_rdata         ),
   .apb_int            (                  ),

   .dfi_phyupd_req     (dfi_phyupd_req    ),
   .dfi_phyupd_ack     (dfi_phyupd_ack    ),

   .dfi_address        (dfi_address       ),
   .dfi_bank           (dfi_bank          ),
   .dfi_cs_n           (dfi_cs_n          ),
   .dfi_ras_n          (dfi_ras_n         ),
   .dfi_cas_n          (dfi_cas_n         ),
   .dfi_we_n           (dfi_we_n          ),
   .dfi_cke            (dfi_cke           ),
   .dfi_odt            (dfi_odt           ),
   .dfi_wrdata         (dfi_wrdata        ),
   .dfi_wrdata_en      (dfi_wrdata_en     ),
   .dfi_wrdata_mask    (dfi_wrdata_mask   ),
   .dfi_rddata         (dfi_rddata        ),
   .dfi_rddata_valid   (dfi_rddata_valid  )
   );


 ddr3_ddrphy_top  #(
  .MEM_TYPE            (MEM_TYPE           ),
  .TMRD                (PHY_TMRD           ),
  .TMOD                (PHY_TMOD           ),
  .TXPR                (PHY_TXPR           ),
  .TRP                 (PHY_TRP            ),
  .TRFC                (PHY_TRFC           ),
  .TRCD                (PHY_TRCD           ),
  .MEM_ADDR_WIDTH      (MEM_ROW_ADDR_WIDTH ),
  .MEM_BANKADDR_WIDTH  (MEM_BADDR_WIDTH    ),
  .MEM_DQ_WIDTH        (MEM_DQ_WIDTH       ),
  .MEM_DM_WIDTH        (MEM_DM_WIDTH       ),
  .MEM_DQS_WIDTH       (MEM_DQS_WIDTH      )
 )u_ddrphy_top(
  .ref_clk                (ref_clk               ),
  .ddr_rstn               (ddr_rstn              ),
  .pll_lock               (pll_lock              ),
  .ddrphy_cpd_lock        (ddrphy_cpd_lock       ),
  .ddrphy_sysclk          (ddrphy_sysclk         ),
  .force_read_clk_ctrl    (1'b0),
  .init_slip_step         ({MEM_DQS_WIDTH{4'd0}} ),  
  .init_read_clk_ctrl     ({MEM_DQS_WIDTH{3'd0}} ),
  .force_samp_position    (1'b0 ),
  .init_samp_position_even({MEM_DQS_WIDTH{1'b0,7'd0}} ),
  .init_samp_position_odd ({MEM_DQS_WIDTH{1'b0,7'd0}} ),
  .wrlvl_en               (1'b1 ),
  .init_wrlvl_step        ({MEM_DQS_WIDTH{8'd0}} ),

  .dfi_address           (dfi_address           ),
  .dfi_bank              (dfi_bank              ),
  .dfi_cs_n              (dfi_cs_n              ),
  .dfi_cas_n             (dfi_cas_n             ),
  .dfi_ras_n             (dfi_ras_n             ),
  .dfi_we_n              (dfi_we_n              ),
  .dfi_cke               (dfi_cke               ),
  .dfi_odt               (dfi_odt               ),
  .dfi_wrdata_en         (dfi_wrdata_en         ),
  .dfi_wrdata            (dfi_wrdata            ),
  .dfi_wrdata_mask       (dfi_wrdata_mask       ),
  .dfi_rddata            (dfi_rddata            ),
  .dfi_rddata_valid      (dfi_rddata_valid      ),
  .dfi_reset_n           (1'b1           ),       
  .dfi_phyupd_req        (dfi_phyupd_req        ),
  .dfi_phyupd_ack        (dfi_phyupd_ack        ),
  .dfi_init_complete     (dfi_init_complete     ),
  .debug_calib_ctrl      (debug_calib_ctrl      ),
  .debug_data            (debug_data            ),
  .mem_rst_n             (mem_rst_n             ),
  .mem_ck                (mem_ck                ),
  .mem_ck_n              (mem_ck_n              ),
  .mem_cke               (mem_cke               ),
  .mem_cs_n              (mem_cs_n              ),
  .mem_ras_n             (mem_ras_n             ),
  .mem_cas_n             (mem_cas_n             ),
  .mem_we_n              (mem_we_n              ),
  .mem_odt               (mem_odt               ),
  .mem_a                 (mem_a                 ),
  .mem_ba                (mem_ba                ),
  .mem_dqs               (mem_dqs               ),
  .mem_dqs_n             (mem_dqs_n             ),
  .mem_dq                (mem_dq                ),
  .mem_dm                (mem_dm                )
);

endmodule





// Generated by IP Generator (Version 2020.1-SP5 build 56918)


    
////////////////////////////////////////////////////////////////
// Copyright (c) 2019 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
////////////////////////////////////////////////////////////////
//Description:
//Author:  wxxiao
//History: v1.0
////////////////////////////////////////////////////////////////
`timescale 1ns/1ps
module  ddr3_ddrphy_top  #(

  parameter         MEM_TYPE     =  "DDR3"      ,
 
  parameter [7:0]   TMRD         =  4/4   ,

  parameter [7:0]   TMOD         =  12/4   ,
  
  parameter [7:0]   TXPR         =  31  ,
  
  parameter [7:0]   TRP          =  2   ,
  
  parameter [7:0]   TRFC         =  30   ,
    
  parameter [7:0]   TRCD         =  2   ,
  
  parameter MEM_ADDR_WIDTH       =  15        ,

  parameter MEM_BANKADDR_WIDTH   =  3         ,
  
  parameter MEM_DQ_WIDTH         =  32        ,
  
  parameter MEM_DM_WIDTH         =  32/8         ,
  
  parameter MEM_DQS_WIDTH        =  32/8 
           
)(
//clk
  input                              ref_clk              ,
  input                              ddr_rstn             ,
  output                             pll_lock             ,
  output                             ddrphy_cpd_lock      ,
  output                             ddrphy_sysclk        ,

//rst                                                      
  input                              force_read_clk_ctrl  ,  
  input [3*MEM_DQS_WIDTH-1:0]        init_read_clk_ctrl   ,  
  input [4*MEM_DQS_WIDTH-1:0]        init_slip_step       ,  
  input                              force_samp_position  ,  
  input [8*MEM_DQS_WIDTH-1:0]        init_samp_position_even,
  input [8*MEM_DQS_WIDTH-1:0]        init_samp_position_odd, 
  input                              wrlvl_en             ,  
  input [8*MEM_DQS_WIDTH-1:0]        init_wrlvl_step      ,  
  
//dfi                                           
  input  [4*MEM_ADDR_WIDTH-1:0]      dfi_address          ,
  input  [4*MEM_BANKADDR_WIDTH-1:0]  dfi_bank             ,
  input  [3:0]                       dfi_cs_n             ,
  input  [3:0]                       dfi_cas_n            ,
  input  [3:0]                       dfi_ras_n            ,
  input  [3:0]                       dfi_we_n             ,
  input  [3:0]                       dfi_cke              ,
  input  [3:0]                       dfi_odt              ,
  input  [3:0]                       dfi_wrdata_en        ,
  input  [8*MEM_DQ_WIDTH-1:0]        dfi_wrdata           ,
  input  [8*MEM_DM_WIDTH-1:0]        dfi_wrdata_mask      ,
  output [8*MEM_DQ_WIDTH-1:0]        dfi_rddata           ,
  output                             dfi_rddata_valid     ,
  input                              dfi_reset_n          ,
//  input                              dfi_ctrlupd_req      ,
//  output                             dfi_ctrlupd_ack      ,
  output                             dfi_phyupd_req       ,
  input                              dfi_phyupd_ack       ,
  output                             dfi_init_complete    ,
  output                             dfi_error            ,
  output                             mem_rst_n            ,
  output                             mem_ck               ,
  output                             mem_ck_n             ,
  output                             mem_cke              ,
  output                             mem_cs_n             ,
  output                             mem_ras_n            ,
  output                             mem_cas_n            ,
  output                             mem_we_n             , 
  output                             mem_odt              ,
  output [MEM_ADDR_WIDTH-1:0]        mem_a                ,
  output [MEM_BANKADDR_WIDTH-1:0]    mem_ba               ,
  inout [MEM_DQS_WIDTH-1:0]          mem_dqs              ,
  inout [MEM_DQS_WIDTH-1:0]          mem_dqs_n            ,
  inout [MEM_DQ_WIDTH-1:0]           mem_dq               ,
  output [MEM_DM_WIDTH-1:0]          mem_dm               ,
  output [29:0]                      debug_calib_ctrl     ,
  output [66*MEM_DQS_WIDTH -1:0]     debug_data
);

localparam real CLKIN_FREQ  =  50.000   ; 

localparam GPLL_BANDWIDTH = "HIGH";

localparam PPLL_BANDWIDTH = "OPTIMIZED";


localparam DDR_TYPE = (MEM_TYPE == "DDR3") ? 2'b00 : (MEM_TYPE == "DDR2") ? 2'b01 : (MEM_TYPE == "LPDDR") ? 2'b10 : 2'b00;
localparam SC_LDO_CTRL  =  2'b00     ;
localparam SC_DLY_2X    =  1'b0      ;  //1'b0  1x delay chain, 1'b1 2x delay chain 
localparam REF_CNT   = (DDR_TYPE == 2'b10) ? 8'd2 : 8'd9;
localparam EYECAL_EN    =  1         ; 

localparam PPLL_IDIV    =  1         ;

localparam PPLL_FDIV    =  32         ;

localparam PPLL_ODIVPHY =  2         ;


localparam TEST_DATA_PATTERN0  = 64'h55_aa_55_aa_08_f7_08_f7;
localparam TEST_DATA_PATTERN1  = 64'h7f_9f_7f_9f_80_fe_80_fe;
localparam TEST_DATA_PATTERN2  = 64'hf0_0f_f0_0f_01_ff_01_ff;
localparam TEST_DATA_PATTERN3  = 64'hdf_aa_df_aa_55_aa_55_aa;

localparam GPLL_IDIV  = PPLL_IDIV;
localparam real GPLL_FDIV  = PPLL_FDIV/2.0;
localparam GPLL_DUTYF  = PPLL_FDIV/2;
localparam real GPLL_ODIV0 = PPLL_ODIVPHY*4.0;
localparam GPLL_DUTY0 = PPLL_ODIVPHY*4; 
localparam GPLL_ODIV1 = PPLL_ODIVPHY*8;

//MR0_DDR3
localparam [0:0] DDR3_PPD      = 1'b1;

localparam [2:0] DDR3_WR       =  6 - 4; 

localparam [0:0] DDR3_DLL      = 1'b1;
localparam [0:0] DDR3_TM       = 1'b0;
localparam [0:0] DDR3_RBT      = 1'b0;

localparam [3:0] DDR3_CL       = (6 - 4) * 2; 
    
localparam [1:0] DDR3_BL       = 2'b00;
localparam [15:0] MR0_DDR3     = {3'b000, DDR3_PPD, DDR3_WR, DDR3_DLL, DDR3_TM, DDR3_CL[3:1], DDR3_RBT, DDR3_CL[0], DDR3_BL};
//MR1_DDR3
localparam [0:0] DDR3_QOFF     = 1'b0;
localparam [0:0] DDR3_TDQS     = 1'b0;

localparam [2:0] DDR3_RTT_NOM  = 3'b001;       

localparam [0:0] DDR3_LEVEL    = 1'b0;

localparam [1:0] DDR3_DIC      = 2'b00;

localparam [1:0] DDR3_AL       = 2'b10;     
localparam [0:0] DDR3_DLL_EN   = 1'b0;
localparam [15:0] MR1_DDR3 = {1'b0, DDR3_QOFF, DDR3_TDQS, 1'b0, DDR3_RTT_NOM[2], 1'b0, DDR3_LEVEL, DDR3_RTT_NOM[1], DDR3_DIC[1], DDR3_AL, DDR3_RTT_NOM[0], DDR3_DIC[0], DDR3_DLL_EN};
//MR2_DDR3
localparam [1:0] DDR3_RTT_WR   = 2'b00;
localparam [0:0] DDR3_SRT      = 1'b0;
localparam [0:0] DDR3_ASR      = 1'b0;

localparam [2:0] DDR3_CWL      = 5 - 5;

localparam [2:0] DDR3_PASR     = 3'b000;
localparam [15:0] MR2_DDR3     = {5'b00000, DDR3_RTT_WR, 1'b0, DDR3_SRT, DDR3_ASR, DDR3_CWL, DDR3_PASR};
//MR3_DDR3
localparam [0:0] DDR3_MPR      = 1'b0;
localparam [1:0] DDR3_MPR_LOC  = 2'b00;
localparam [15:0] MR3_DDR3     = {13'b0, DDR3_MPR, DDR3_MPR_LOC};

//MR_DDR2
localparam [2:0] DDR2_BL       = 3'b011;
localparam [0:0] DDR2_BT       = 1'b0; //Sequential

localparam [2:0] DDR2_CL       = 3'd5;

localparam [0:0] DDR2_TM       = 1'b0;
localparam [0:0] DDR2_DLL      = 1'b1;

localparam [2:0] DDR2_WR       =  6 - 1; 

localparam [0:0] DDR2_PD       = 1'b0;
localparam [15:0]  MR_DDR2     = {3'b000,DDR2_PD,DDR2_WR,DDR2_DLL,DDR2_TM,DDR2_CL,DDR2_BT,DDR2_BL};

//EMR1_DDR2
localparam [0:0] DDR2_DLL_EN      = 1'b0;

localparam [0:0] DDR2_DIC      = 1'b0;

localparam [1:0] DDR2_RTT_NOM  = 2'b01;     

localparam [2:0] DDR2_AL       = 3'd3; 
 
localparam [2:0] DDR2_OCD      = 3'b000;
localparam [0:0] DDR2_DQS      = 1'b0;
localparam [0:0] DDR2_RDQS     = 1'b0;
localparam [0:0] DDR2_QOFF     = 1'b0;
localparam [15:0] EMR1_DDR2    = {3'b000,DDR2_QOFF,DDR2_RDQS,DDR2_DQS,DDR2_OCD,DDR2_RTT_NOM[1],DDR2_AL,DDR2_RTT_NOM[0],DDR2_DIC,DDR2_DLL_EN};

localparam [15:0] EMR2_DDR2    =16'h0000;
localparam [15:0] EMR3_DDR2    =16'h0000;
 
//MR_LPDDR
localparam [2:0] LPDDR_BL      = 3'b011;
localparam [0:0] LPDDR_BT      = 1'b0;

localparam [2:0] LPDDR_CL      = 3'd3;

localparam [15:0] MR_LPDDR    = {9'd0,LPDDR_CL,LPDDR_BT,LPDDR_BL};

//EMR_LPDDR

localparam [2:0] LPDDR_DS      = 3'b000;

localparam [15:0] EMR_LPDDR    = {8'd0,LPDDR_DS,5'd0};

localparam [9:0]   TZQINIT      =  10'd128 ;


localparam DFI_CLK_PERIOD =  10000;


`ifdef SIMULATION                                                  
localparam T200US         = (210*1000*1000 / DFI_CLK_PERIOD) / 100;
`else                                                              
localparam T200US         = (210*1000*1000 / DFI_CLK_PERIOD);      
`endif

`ifdef SIMULATION                                                  
localparam T500US         = (510*1000*1000 / DFI_CLK_PERIOD) / 100;
`else                                                              
localparam T500US         = (510*1000*1000 / DFI_CLK_PERIOD);      
`endif

localparam T400NS         = 410*1000 / DFI_CLK_PERIOD;
                                  
wire ddrphy_ioclk_gate            ;
wire dll_lock                     ;
wire dll_update_n                 ;
wire ddrphy_dll_rst               ;
wire dll_update_req_rst_ctrl      ;
wire dll_update_ack_rst_ctrl      ;
wire ddrphy_rst_n                 ;
wire [4:0] mc_wl                  ;
wire [4:0] mc_rl                  ;
wire [15:0] mr0                   ;
wire [15:0] mr1                   ;
wire [15:0] mr2                   ;
wire [15:0] mr3                   ;
wire calib_done                   ;
wire update_cal_req               ;
wire update_done                  ;
wire ddrphy_rst_req               ;
wire ddrphy_rst_ack               ;
wire wrlvl_dqs_req                ;
wire wrlvl_dqs_resp               ;
wire wrlvl_error                  ;
wire gatecal_start                ;
wire gate_check_pass              ;
wire gate_adj_done                ;
wire gate_cal_error               ;
wire gate_move_en                 ;
wire rddata_cal                   ;
wire rddata_check_pass            ;
wire init_adj_rdel                ;
wire adj_rdel_done                ;
wire rdel_calibration             ;
wire rdel_calib_done              ;
wire rdel_calib_error             ;
wire rdel_move_en                 ;
wire rdel_move_done               ;
wire bitslip_ctrl                 ;
wire wrcal_check_pass             ;
wire write_calibration            ;
wire wrcal_move_en                ;
wire wrcal_move_done              ;
wire eye_calibration              ;
wire eyecal_check_pass            ;
wire eyecal_move_done             ;
wire eyecal_move_en               ;
wire [2*MEM_DQS_WIDTH-1:0] comp_val ;
wire [MEM_DQS_WIDTH-1:0]   comp_dir ;
wire dqs_gate_comp_en               ;
wire dqs_gate_comp_done             ;
wire                            calib_rst            ;
wire [MEM_BANKADDR_WIDTH-1:0]   calib_ba             ;
wire [MEM_ADDR_WIDTH-1:0]       calib_address        ;
wire                            calib_cs_n           ;
wire                            calib_ras_n          ;
wire                            calib_cas_n          ;
wire                            calib_we_n           ;
wire                            calib_cke            ;
wire                            calib_odt            ;
wire [3:0]                      calib_wrdata_en      ;
wire [8*MEM_DQ_WIDTH-1:0]       calib_wrdata         ;
wire [8*MEM_DM_WIDTH-1:0]       calib_wrdata_mask    ;
wire                            ddrphy_dqs_training_rstn;
wire [3:0]                      read_cmd                ;
wire     	                    read_valid           ;
wire [8*MEM_DQ_WIDTH-1:0]       o_read_data          ;
wire [3:0]                      phy_wrdata_en        ;
wire [8*MEM_DM_WIDTH-1:0]       phy_wrdata_mask      ;
wire [8*MEM_DQ_WIDTH-1:0]       phy_wrdata           ;
wire [3:0]                      phy_cke              ;
wire [3:0]                      phy_cs_n             ;
wire [3:0]                      phy_ras_n            ;
wire [3:0]                      phy_cas_n            ;
wire [3:0]                      phy_we_n             ;
wire [4*MEM_ADDR_WIDTH-1:0]     phy_addr             ;
wire [4*MEM_BANKADDR_WIDTH-1:0] phy_ba               ;
wire [3:0]                      phy_odt              ;
wire [3:0]                      phy_ck               ;
wire                            phy_rst              ;

wire phy_sysclk_fb;  
wire phy_ioclk_fb;
wire phy_pll_lock;
wire ddrphy_cpd_rstn;
//wire ddrphy_cpd_lock;
wire ddrphy_cpd_up_dnb;
wire ddrphy_cpd_done;
wire ddrphy_cpd_start;
wire gpll_dps_clk;
wire gpll_dps_en;
wire gpll_dps_dir;
wire gpll_dps_done;
wire gpll_lock;
wire dll_freeze; 
wire dll_update_req_training;
wire dll_update_ack_training;
wire                       ddrphy_update         ;
wire                       ddrphy_update_done    ;
wire [2*MEM_DQS_WIDTH-1:0] ddrphy_update_comp_val;
wire [MEM_DQS_WIDTH-1:0]   ddrphy_update_comp_dir;
wire [2*MEM_DQS_WIDTH-1:0] dqs_drift             ;
wire ddrphy_iol_rst;
wire gpll_clkout0;
wire gpll_clkout0n;
wire gpll_clkout1;
wire pll_refclk;
wire g_refclk;
wire logic_rstn;
wire phy_pll_rst;

assign pll_lock = phy_pll_lock & gpll_lock;

GTP_CLKBUFG u_refclk_bufg
(
   .CLKOUT(g_refclk),
   .CLKIN (ref_clk)
);

GTP_CLKBUFM u_clkbufm
(
.CLKOUT  (pll_refclk),
.CLKIN   (g_refclk)
);

ips2l_ddrphy_gpll_v1_0 #(
 .CLKIN_FREQ  (CLKIN_FREQ      ),
 .BANDWIDTH   (GPLL_BANDWIDTH  ),
 .IDIV        (GPLL_IDIV       ),
 .FDIV        (GPLL_FDIV       ),
 .DUTYF       (GPLL_DUTYF      ),
 .ODIV0       (GPLL_ODIV0      ),
 .ODIV1       (GPLL_ODIV1      ),
 .DUTY0       (GPLL_DUTY0      )   
)ddrphy_gpll(
 .clk_in0       (g_refclk)   ,
 .pll_rst       (phy_pll_rst)  ,
 .dps_clk       (gpll_dps_clk) ,
 .dps_en        (gpll_dps_en)  ,
 .dps_dir       (gpll_dps_dir) ,
 .clkout0_gate  (1'b0)         ,
 .clkout0       (gpll_clkout0) ,
// .clkout0       (),
 .clkout0n      (gpll_clkout0n),
 .clkout1       (gpll_clkout1),
 .clkout1n      (),
 .dps_done      (gpll_dps_done),
 .pll_lock      (gpll_lock)    
);

GTP_CLKBUFG u_sysclk_bufg
(
   .CLKOUT(ddrphy_sysclk),
   .CLKIN (gpll_clkout0)
);

GTP_CLKBUFG u_sysclk_bufg1
(
   .CLKOUT(gpll_dps_clk),
   .CLKIN (gpll_clkout1)
);

GTP_CLKPD u_ddrphy_cpd(
  .FLAG_PD      (ddrphy_cpd_up_dnb),
  .LOCK         (ddrphy_cpd_lock),
  .RST          (ddrphy_cpd_rstn),
  .CLK_SAMPLE   (phy_ioclk_fb),
  .CLK_CTRL     (ddrphy_sysclk),
  .CLK_PHY      (phy_sysclk_fb),
  .DONE         (ddrphy_cpd_done)
);


ips2l_ddrphy_cpd_ctrl_v1_0 ddrphy_cpd_ctrl
(
 .dps_clk            (gpll_dps_clk     ),
 .ddr_rstn           (logic_rstn       ),  
 .ddrphy_cpd_start   (ddrphy_cpd_start ),
 .ddrphy_cpd_up_dnb  (ddrphy_cpd_up_dnb),
 .ddrphy_cpd_lock    (ddrphy_cpd_lock  ),
 .ddrphy_cpd_rstn    (ddrphy_cpd_rstn  ),
 .gpll_dps_done      (gpll_dps_done    ),
 .ddrphy_cpd_done    (ddrphy_cpd_done  ),
 .gpll_dps_en        (gpll_dps_en      ),
 .gpll_dps_dir       (gpll_dps_dir     )
);
                                 
 ips2l_ddrphy_reset_ctrl_v1_0  ddrphy_reset_ctrl(
   .ddr_rstn                 (ddr_rstn                ),                    
   .ref_clk                  (g_refclk                ),
   .dll_lock                 (dll_lock                ),
   .pll_lock                 (pll_lock                ),
   .ddrphy_cpd_done          (ddrphy_cpd_done         ),
   .ddrphy_cpd_start         (ddrphy_cpd_start        ),   
   .dll_update_req_rst_ctrl  (dll_update_req_rst_ctrl ),
   .dll_update_ack_rst_ctrl  (dll_update_ack_rst_ctrl ), 
   .dll_freeze               (dll_freeze              ),
   .dll_update_req_training  (dll_update_req_training ),
   .dll_update_ack_training  (dll_update_ack_training ),
   .ddrphy_calib_done        (calib_done              ),
   .training_error           (dfi_error               ),
   .logic_rstn               (logic_rstn              ),
   .phy_pll_rst              (phy_pll_rst             ),   
   .ddrphy_dll_rst           (ddrphy_dll_rst          ),    //dll reset
   .ddrphy_rst_n             (ddrphy_rst_n            ),
   .ddrphy_dqs_rst           (ddrphy_dqs_rst          ),
   .ddrphy_iol_rst           (ddrphy_iol_rst          ),
   .ddrphy_ioclk_gate        (ddrphy_ioclk_gate       )
 );
 
 ips2l_ddrphy_dll_update_ctrl_v1_0 ddrphy_dll_update_ctrl(
   .ddrphy_sysclk            (g_refclk                ),
   .ddr_rstn                 (logic_rstn              ),
   .dll_update_req_rst_ctrl  (dll_update_req_rst_ctrl ),
   .dll_update_ack_rst_ctrl  (dll_update_ack_rst_ctrl ),
   .dll_update_req_training  (dll_update_req_training ),
   .dll_update_ack_training  (dll_update_ack_training ),
   .dll_update_n             (dll_update_n            )
 );

ips2l_ddrphy_gate_update_ctrl_v1_0 #(
  .UPDATE_EN              (1'b0              ),
  .MEM_DQS_WIDTH          (MEM_DQS_WIDTH     )
)ddrphy_gate_update_ctrl(
  .ddrphy_sysclk          (ddrphy_sysclk          ),
  .ddrphy_rst_n           (ddrphy_rst_n           ),
  .calib_done             (calib_done             ),
  .dqs_drift              (dqs_drift              ),
  .ddrphy_update_done     (ddrphy_update_done     ),
  .update_start           (ddrphy_update          ),
  .ddrphy_update_comp_val (ddrphy_update_comp_val ),
  .ddrphy_update_comp_dir (ddrphy_update_comp_dir )
);

 ips2l_ddrphy_calib_top_v1_0 #(
  .DDR_TYPE            (DDR_TYPE           ),
  .WRCAL_EN            (1'b0               ),
  .EYECAL_EN           (EYECAL_EN          ),
  .T200US              (T200US             ),
  .T500US              (T500US             ),
  .T400NS              (T400NS             ),
  .TMRD                (TMRD               ),
  .TMOD                (TMOD               ),
  .TXPR                (TXPR               ),
  .TRP                 (TRP                ),
  .TZQINIT             (TZQINIT            ),
  .TRFC                (TRFC               ),
  .TRCD                (TRCD               ),
  .REF_CNT             (REF_CNT            ),
  .TEST_DATA_PATTERN0  (TEST_DATA_PATTERN0 ),
  .TEST_DATA_PATTERN1  (TEST_DATA_PATTERN1 ),
  .TEST_DATA_PATTERN2  (TEST_DATA_PATTERN2 ),
  .TEST_DATA_PATTERN3  (TEST_DATA_PATTERN3 ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH     ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH ),
  .MEM_DQ_WIDTH        (MEM_DQ_WIDTH       ),
  .MEM_DM_WIDTH        (MEM_DM_WIDTH       ),
  .MEM_DQS_WIDTH       (MEM_DQS_WIDTH      )
  )ddrphy_calib_top(     
  .mc_wl               (mc_wl              ),
  .mr0                 (mr0                ),
  .mr1                 (mr1                ),
  .mr2                 (mr2                ),
  .mr3                 (mr3                ),

  .ddrphy_sysclk       (ddrphy_sysclk      ),
  .ddrphy_rst_n        (ddrphy_rst_n       ),
  .calib_done          (calib_done         ),
  .update_done         (update_done        ),
  .ddrphy_rst_req      (ddrphy_rst_req     ),
  .ddrphy_rst_ack      (ddrphy_rst_ack     ),
  .wrlvl_en            (wrlvl_en           ),
  .wrlvl_dqs_req       (wrlvl_dqs_req      ),
  .wrlvl_dqs_resp      (wrlvl_dqs_resp     ),
  .wrlvl_error         (wrlvl_error        ),
  .gatecal_start       (gatecal_start      ),
  .gate_check_pass     (gate_check_pass    ),
  .gate_adj_done       (gate_adj_done      ),
  .gate_cal_error      (gate_cal_error     ),
  .gate_move_en        (gate_move_en       ),
  .rddata_cal          (rddata_cal         ),
  .rddata_check_pass   (rddata_check_pass  ),
  .init_adj_rdel       (init_adj_rdel      ),
  .adj_rdel_done       (adj_rdel_done      ),
  .rdel_calibration    (rdel_calibration   ),
  .rdel_calib_done     (rdel_calib_done    ),
  .rdel_calib_error    (rdel_calib_error   ),
  .rdel_move_en        (rdel_move_en       ),
  .rdel_move_done      (rdel_move_done     ),
  .bitslip_ctrl        (bitslip_ctrl       ),
  .write_debug         (1'b0               ),
  .dqgt_debug          (1'b0               ),
  .rdel_rd_cnt         (8'd32              ),

  .wrcal_check_pass    (wrcal_check_pass   ),
  .write_calibration   (write_calibration  ),
  .wrcal_move_en       (wrcal_move_en      ),
  .wrcal_move_done     (wrcal_move_done    ),
                                           
  .eye_calibration     (eye_calibration    ),
  .eyecal_check_pass   (eyecal_check_pass  ),
  .eyecal_move_done    (eyecal_move_done   ),
  .eyecal_move_en      (eyecal_move_en     ),
  .dfi_error           (dfi_error          ),
  .debug_calib_ctrl    (debug_calib_ctrl   ),
  
  .update_cal_req      (update_cal_req     ),
  .update_comp_val     (ddrphy_update_comp_val),
  .update_comp_dir     (ddrphy_update_comp_dir),
  .comp_val            (comp_val           ),
  .comp_dir            (comp_dir           ),
  .dqs_gate_comp_en    (dqs_gate_comp_en   ),
  .dqs_gate_comp_done  (dqs_gate_comp_done ),

  .calib_ba            (calib_ba           ),
  .calib_address       (calib_address      ),
  .calib_cs_n          (calib_cs_n         ),
  .calib_ras_n         (calib_ras_n        ),
  .calib_cas_n         (calib_cas_n        ),
  .calib_we_n          (calib_we_n         ),
  .calib_cke           (calib_cke          ),
  .calib_odt           (calib_odt          ),
  .calib_rst           (calib_rst          ),
  .calib_wrdata_en     (calib_wrdata_en    ),
  .calib_wrdata        (calib_wrdata       ),
  .calib_wrdata_mask   (calib_wrdata_mask  )
  );

 ips2l_ddrphy_training_ctrl_v1_0 ddrphy_training_ctrl
 (
  .ddrphy_sysclk              (ddrphy_sysclk             ),
  .ddrphy_rst_n               (ddrphy_rst_n              ),
  .ddrphy_rst_req             (ddrphy_rst_req            ),
  .ddrphy_rst_ack             (ddrphy_rst_ack            ),
  .ddrphy_dqs_training_rstn   (ddrphy_dqs_training_rstn  )
 );

 ips2l_ddrphy_slice_top_v1_0 #(
  .CLKIN_FREQ          (CLKIN_FREQ         ), 
  .PPLL_BANDWIDTH      (PPLL_BANDWIDTH     ),
  .DDR_TYPE            (DDR_TYPE           ),
  .TEST_DATA_PATTERN0  (TEST_DATA_PATTERN0 ),
  .TEST_DATA_PATTERN1  (TEST_DATA_PATTERN1 ),
  .TEST_DATA_PATTERN2  (TEST_DATA_PATTERN2 ),
  .TEST_DATA_PATTERN3  (TEST_DATA_PATTERN3 ),
  .GATE_MODE           (1'b0               ),
  .SC_LDO_CTRL         (SC_LDO_CTRL        ),
  .SC_DLY_2X           (SC_DLY_2X          ),
  .PPLL_IDIV           (PPLL_IDIV          ),
  .PPLL_FDIV           (PPLL_FDIV          ),
  .PPLL_ODIVPHY        (PPLL_ODIVPHY       ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH     ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH ),
  .MEM_DQ_WIDTH        (MEM_DQ_WIDTH       ),
  .MEM_DQS_WIDTH       (MEM_DQS_WIDTH      ),
  .MEM_DM_WIDTH        (MEM_DM_WIDTH       )
 )ddrphy_slice_top(                          
  .mc_rl                    (mc_rl                    ),
  .force_read_clk_ctrl      (force_read_clk_ctrl      ),
  .init_read_clk_ctrl       (init_read_clk_ctrl       ),
  .init_slip_step           (init_slip_step           ),
  .force_samp_position      (force_samp_position      ),
  .init_samp_position_even  (init_samp_position_even  ),
  .init_samp_position_odd   (init_samp_position_odd   ),
  .wrlvl_en                 (wrlvl_en                 ),
  .init_wrlvl_step          (init_wrlvl_step          ),
                                           
  .ddrphy_sysclk            (ddrphy_sysclk            ),
  .ddrphy_rst_n             (ddrphy_rst_n             ),
  .phy_refclk               (pll_refclk     ),
  .phy_pll_rst              (phy_pll_rst    ),
  .clkoutphy_gate           (ddrphy_ioclk_gate), 
  .ioclkdiv_rst             (ddrphy_dqs_rst ), 
  .dll_rstn                 (~ddrphy_dll_rst),
  .dll_freeze               (dll_freeze     ),
  .dll_update_n             (dll_update_n   ),
  .phy_pll_lock             (phy_pll_lock   ),
  .phy_dll_lock             (dll_lock       ),
  .phy_sysclk_fb            (phy_sysclk_fb  ),
  .phy_ioclk_fb             (phy_ioclk_fb   ),
  .ddrphy_iol_rst           (ddrphy_iol_rst          ),
  
  .ddrphy_dqs_rst           (ddrphy_dqs_rst           ),
  .ddrphy_dqs_training_rstn (ddrphy_dqs_training_rstn ),
                        
  .wrlvl_dqs_req            (wrlvl_dqs_req            ),
  .wrlvl_dqs_resp           (wrlvl_dqs_resp           ),
  .wrlvl_error              (wrlvl_error              ),
                         
  .gatecal_start            (gatecal_start            ),
  .gate_check_pass          (gate_check_pass          ),
  .gate_adj_done            (gate_adj_done            ),
  .gate_cal_error           (gate_cal_error           ),
  .gate_move_en             (gate_move_en             ),

  .rddata_cal               (rddata_cal               ),
  .rddata_check_pass        (rddata_check_pass        ),
  .read_cmd                 (read_cmd                 ),
  
  .dqs_drift                (dqs_drift                ),
  .comp_val                 (comp_val                 ),
  .comp_dir                 (comp_dir                 ),
  .dqs_gate_comp_en         (dqs_gate_comp_en         ),
  .dqs_gate_comp_done       (dqs_gate_comp_done       ),
                        
  .init_adj_rdel            (init_adj_rdel            ),
  .adj_rdel_done            (adj_rdel_done            ),
  .rdel_calibration         (rdel_calibration         ),
  .rdel_calib_done          (rdel_calib_done          ),
  .rdel_calib_error         (rdel_calib_error         ),
  .rdel_move_en             (rdel_move_en             ),
  .rdel_move_done           (rdel_move_done           ),
  .bitslip_ctrl             (bitslip_ctrl             ),

  .wrcal_check_pass         (wrcal_check_pass        ),
  .write_calibration        (write_calibration       ),
  .wrcal_move_en            (wrcal_move_en           ),
  .wrcal_move_done          (wrcal_move_done         ),
                                                     
  .eye_calibration          (eye_calibration         ),
  .eyecal_check_pass        (eyecal_check_pass       ),
  .eyecal_move_done         (eyecal_move_done        ),
  .eyecal_move_en           (eyecal_move_en          ),
                                        
  .read_valid               (read_valid               ),
  .o_read_data              (o_read_data              ),
  .align_error              (                         ),
        
  .phy_wrdata_en            (phy_wrdata_en            ),
  .phy_wrdata_mask          (phy_wrdata_mask          ),
  .phy_wrdata               (phy_wrdata               ),
  .phy_cke                  (phy_cke                  ),
  .phy_cs_n                 (phy_cs_n                 ),
  .phy_ras_n                (phy_ras_n                ),
  .phy_cas_n                (phy_cas_n                ),
  .phy_we_n                 (phy_we_n                 ),
  .phy_addr                 (phy_addr                 ),
  .phy_ba                   (phy_ba                   ),
  .phy_odt                  (phy_odt                  ),
  .phy_ck                   (phy_ck                   ),
  .phy_rst                  (phy_rst                  ),
  .mem_rst_n                (mem_rst_n                ),
  .mem_ck                   (mem_ck                   ),
  .mem_ck_n                 (mem_ck_n                 ),
  .mem_cke                  (mem_cke                  ),
  .mem_cs_n                 (mem_cs_n                 ),
  .mem_ras_n                (mem_ras_n                ),
  .mem_cas_n                (mem_cas_n                ),
  .mem_we_n                 (mem_we_n                 ),
  .mem_odt                  (mem_odt                  ),
  .mem_a                    (mem_a                    ),
  .mem_ba                   (mem_ba                   ),
  .mem_dqs                  (mem_dqs                  ),
  .mem_dqs_n                (mem_dqs_n                ),
  .mem_dq                   (mem_dq                   ),
  .mem_dm                   (mem_dm                   ),
  .debug_data               (debug_data               )
  );                                              
 
  ips2l_ddrphy_dfi_v1_0 #(
  .DDR_TYPE            (DDR_TYPE           ),
  .MEM_ADDR_WIDTH      (MEM_ADDR_WIDTH     ),
  .MEM_BANKADDR_WIDTH  (MEM_BANKADDR_WIDTH ),
  .MEM_DQ_WIDTH        (MEM_DQ_WIDTH       ),
  .MEM_DQS_WIDTH       (MEM_DQS_WIDTH      ),
  .MEM_DM_WIDTH        (MEM_DM_WIDTH       )
 )ddrphy_dfi(
   .ddrphy_sysclk        (ddrphy_sysclk       ),
   .ddrphy_rst_n         (ddrphy_rst_n        ),
   .calib_done           (calib_done          ),
   .calib_rst            (calib_rst           ),
   .calib_ba             (calib_ba            ),
   .calib_address        (calib_address       ),
   .calib_cs_n           (calib_cs_n          ),
   .calib_ras_n          (calib_ras_n         ),
   .calib_cas_n          (calib_cas_n         ),
   .calib_we_n           (calib_we_n          ),
   .calib_cke            (calib_cke           ),
   .calib_odt            (calib_odt           ),
   .calib_wrdata_en      (calib_wrdata_en     ),
   .calib_wrdata         (calib_wrdata        ),
   .calib_wrdata_mask    (calib_wrdata_mask   ),
   .read_valid           (read_valid          ),
   .o_read_data          (o_read_data         ),
   
   .ddrphy_update        (ddrphy_update       ),
   .update_cal_req       (update_cal_req      ),
   .update_done          (update_done         ),
   .ddrphy_update_done   (ddrphy_update_done  ),
    
   .dfi_address          (dfi_address         ),
   .dfi_bank             (dfi_bank            ),
   .dfi_cs_n             (dfi_cs_n            ),
   .dfi_cas_n            (dfi_cas_n           ),
   .dfi_ras_n            (dfi_ras_n           ),
   .dfi_we_n             (dfi_we_n            ),
   .dfi_cke              (dfi_cke             ),
   .dfi_odt              (dfi_odt             ),
   .dfi_wrdata_en        (dfi_wrdata_en       ),
   .dfi_wrdata           (dfi_wrdata          ),
   .dfi_wrdata_mask      (dfi_wrdata_mask     ),
   .dfi_rddata           (dfi_rddata          ),
   .dfi_rddata_valid     (dfi_rddata_valid    ),
   .dfi_reset_n          (dfi_reset_n         ),
//   .dfi_ctrlupd_req      (dfi_ctrlupd_req     ),
//   .dfi_ctrlupd_ack      (dfi_ctrlupd_ack     ),
   .dfi_phyupd_req       (dfi_phyupd_req      ),
   .dfi_phyupd_ack       (dfi_phyupd_ack      ),
   .dfi_init_complete    (dfi_init_complete   ),
   .read_cmd             (read_cmd            ),
   .phy_ck               (phy_ck              ),
   .phy_rst              (phy_rst             ),
   .phy_addr             (phy_addr            ),
   .phy_ba               (phy_ba              ),
   .phy_cs_n             (phy_cs_n            ),
   .phy_ras_n            (phy_ras_n           ),
   .phy_cas_n            (phy_cas_n           ),
   .phy_we_n             (phy_we_n            ),
   .phy_cke              (phy_cke             ),
   .phy_odt              (phy_odt             ),
   .phy_wrdata_en        (phy_wrdata_en       ),
   .phy_wrdata           (phy_wrdata          ),
   .phy_wrdata_mask      (phy_wrdata_mask     )
  );

  ips2l_ddrphy_info_v1_0 #(
  .DDR_TYPE             (DDR_TYPE           ),
  .MEM_ADDR_WIDTH       (MEM_ADDR_WIDTH     ),
  .MEM_BANKADDR_WIDTH   (MEM_BANKADDR_WIDTH ),
  .MR0_DDR3             (MR0_DDR3           ),
  .MR1_DDR3             (MR1_DDR3           ),
  .MR2_DDR3             (MR2_DDR3           ),
  .MR3_DDR3             (MR3_DDR3           ),
  .MR_DDR2              (MR_DDR2            ),
  .EMR1_DDR2            (EMR1_DDR2          ),
  .EMR2_DDR2            (EMR2_DDR2          ),
  .EMR3_DDR2            (EMR3_DDR2          ),
  .MR_LPDDR             (MR_LPDDR           ),
  .EMR_LPDDR            (EMR_LPDDR          )
)ddrphy_info(
  .ddrphy_sysclk        (ddrphy_sysclk ),
  .ddrphy_rst_n         (ddrphy_rst_n  ),
  .calib_done           (calib_done    ),
  .phy_addr             (phy_addr      ),
  .phy_ba               (phy_ba        ),
  .phy_cs_n             (phy_cs_n      ),
  .phy_cas_n            (phy_cas_n     ),
  .phy_ras_n            (phy_ras_n     ),
  .phy_we_n             (phy_we_n      ),
  .phy_cke              (phy_cke       ),
  .mc_rl                (mc_rl         ),
  .mc_wl                (mc_wl         ),
  .mr0                  (mr0           ),
  .mr1                  (mr1           ),
  .mr2                  (mr2           ),
  .mr3                  (mr3           )
  );

endmodule





